
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "Mediumish Template for Jekyll",
    "body": "This website is built with Jekyll and Mediumish template for Jekyll. It's for demonstration purposes, no real content can be found. Mediumish template for Jekyll is compatible with Github pages, in fact even this demo is created with Github Pages and hosted with Github.  Documentation: Please, read the docs here. Questions or bug reports?: Head over to our Github repository! Buy me a coffeeThank you for your support! Your donation helps me to maintain and improve Mediumish . Buy me a coffee Documentation"
    }, {
    "id": 2,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Let's test spoilers                              :               Director Roland Suso Richter’s enigmatic psychological thriller (direct to video/DVD) was based upon screenwriter Michael Cooney’s own play “Point of Death” - a title that. . . :                                                                                                                                                                                                       11 Jan 2018                                                                                                                                                                                                                                                                                                                  Inception Movie                                                 1 2 3 4 5                                              :               Review products, books, movies, restaurant and anything you like on your Jekyll blog with Mediumish! JSON-LD ready for review property. :                                                                                                                                                                                                       11 Jan 2018                                                                                                                      All Stories:                                                             디자인패턴(4)- 설계 원칙 SOLID              :       이전 포스팅 객체지향 다형성과 추상 타입 재사용: 상속보단 조립:                                                                               Pam                01 Oct 2024                                                                                            디자인패턴(3)- 재사용 | 상속보단 조립              :       이전 포스팅 객체지향 다형성과 추상 타입:                                                                               Pam                30 Sep 2024                                                                                            토익 920점 후기              :       사실상 자랑에 가까운 게시글이다…. 정보를 위해서 이 글을 읽는 사람은 없길 바란다(정보성이라곤 전혀 없음):                                                                               Pam                25 Sep 2024                                                                                            디자인패턴(2)- 다형성과 추상 타입              :       이전 포스팅 객체지향:                                                                               Pam                24 Sep 2024                                                                                            Github Docker Migration (feat. CICD docker-compose command not found)              :       0. 개요:                                                                               Pam                04 Sep 2024                                                                                            디자인패턴(1)- 객체 지향              :       0. 개요 본 포스팅은 ‘개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴’을 읽고 정리한 포스팅이다. 디자인 패턴을 공부하게 된 계기는 단순하다. ‘어떻게 코드를 짜야 좋은 코드가 되는가’ 고민하는 것을 넘어. . . :                                                                               Pam                19 Aug 2024                                               &laquo; Prev       1        2        3        4        5        6        7        8        9        10        11      Next &raquo; "
    }, {
    "id": 4,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/page4/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/page5/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/page6/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/page7/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 11,
    "url": "http://localhost:4000/page8/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 12,
    "url": "http://localhost:4000/page9/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 13,
    "url": "http://localhost:4000/page10/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 14,
    "url": "http://localhost:4000/page11/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 15,
    "url": "http://localhost:4000/design-pattern-4/",
    "title": "디자인패턴(4)- 설계 원칙 SOLID",
    "body": "2024/10/01 - 이전 포스팅  객체지향 다형성과 추상 타입 재사용: 상속보단 조립0. 개요: 앞서 객체지향의 기본이 되는 책임 할당, 캡슐화, 다형성과 추상화, 조립을 통한 재사용에 대해 알아봤듯이 객체지향 설계는 소프트웨어의 변경을 유연하도록 돕는다. SOLID는 이러한 객체 지향적인 설계를 돕는 설계 원칙이다. SOLID는 앞서 살펴본 책임 할당, 캡슐화, 다형성과 추상화, 조립을 통한 재사용과 같은 내용들을 체계적으로 정리한 것이다.  단일 책임 원칙 (Single responseibility principle: SRP) 개방-폐쇄 원칙 (Open-closed principle: OCP) 리스코프 치환 원칙 (Liskov subsitution principle: LSP) 인터페이스 분리 원칙 (Interface segregation principle: ISP) 의존 역전 원칙 (Depencency inversion principle: DIP)1. 단일 책임 원칙:  클래스는 단 한 개의 책임을 가져야 한다.  즉, 클래스를 변경하는 이유는 단 한개여야 한다.  123456789101112131415161718192021222324public class DataViewer {		public void display() {		String data = loadHtml();		updateGui(data);	}		public String loadHtml() { //HTTP 응답을 반환한다. 		HttpClient client = new HttpClient();		client. connect(url);		return client. getResponse();	}		private void updateGui(String data) { // HTML 문자열을 GUI형태로 보여준다. 		GuiData guiModel = parseDataToGuiData(data);		tableUI. changeData(guiModel);	}			private GuiData parseDataToGuiData(String data) {		// . . . 	}		// . . . }HTTP 프로토콜을 사용하여 데이터를 읽어와 화면에 보여주는 클래스 DataViewer클래스는 HTTP 응답을 받을 뿐만 아니라, 이를 화면에 보여주는 두 가지 책임을 지니고 있다. 그렇다면 만일 서버에서 제공하는 데이터가 HTTP가 아닌 다른 형태로 바뀐다면 어떻게 될까? 코드 수정의 어려움: 123456789101112131415161718192021222324public class DataViewer {		public void display() {		byte[] data = load();		updateGui(data);	}		public byte[] loadHtml() { // 로직 변경		SocketClient client = new SocketClient();		client. connect(server, port);		return client. read();	}		private void updateGui(byte[] data) { // 변경 발생		GuiData guiModel = parseDataToGuiData(data);		tableUI. changeData(guiModel);	}		private GuiData parseDataToGuiData(byte[] data) { //변경 발생		// . . . 	}		// . . . }HTTP → Socket으로 응답 데이터가 수정되었다. HttpClient를 SocketClient로 교체한 것만으로도 해당 데이터를 사용하는 모든 메서드에 변경이 발생되었다. 이러한 문제는 하나의 클래스가 데이터를 읽는 책임과 화면에 보여주는 책임, 두가지의 책임을 지니고 있기 때문이다. 한 클래스가 지니는 책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향은 비례해서 증가한다. 즉, 코드를 절차지향적으로 만든다. 재사용의 어려움: DataViewer가 HttpClient와 GuiComp라는 두 패키지를 사용한다고 하자. 또한 데이터를 읽어오는 기능이 필요한 DataRequireClient가 DataViewer을 사용하고 있다. 이때 DataRequireClient가 필요한 것은 DataViewer와 HttpClient Jar 파일이나, DataViewer는 GuiComp를 사용하고 있으므로 실제로는 DataViewer와 HttpClient Jar 파일 뿐만 아니라 GuiComp의 Jar 파일까지 필요하게 된다.  만일 단일 책임 원칙을 적용시켜 책임을 분리한다면 DataRequireClient는 DataLoader와 HttpClient 패키지만을 사용할 수 있게 된다. 책임이란: 객체의 존재 이유란, 책임을 할당하기 위함이다. ‘단일 책임 원칙’에서 우리는 한 객체는 하나의 책임만을 지녀야 한다는 개념을 배웠다. 그러나 책임이란 것은 어떻게 구분하면 좋단 말인가?  위 이미지에서 GUIApplication은 DataViewer의 display() 메서드를 사용하고 DataProcessor는 loadData()를 사용한다. 만일 GUIApplication에서 요구되는 변경사항이 발생할 경우 DataViewer의 display()가 변경될 확률이 높다. 또한 DataProcess에서 요구되는 변경사항이 발생할 경우 DataViewer의 loadData()가 변경될 확률이 높아진다. 이렇게 서로 다른 클래스가 서로 다른 메서드를 사용하는 경우, 이 메서드들은 각기 다른 책임을 지니고 있을 확률이 높다. 2. 개방 폐쇄 원칙:  확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다.  즉, 기능을 변경하거나 확장할 수 있으면서 그 기능을 사용하는 코드는 수정하지 않는다.  기능을 변경하면서도 코드를 수정하지 않는다는 말이 생소하게 들릴 수 있으나, 이전에 한번 알아보았던 내용이다. 다형성과 추상 타입에서 우리는 여러 종류의 Reservation을 DashboardHelper을 사용하여 출력하는 법에 대해 알아보았다. 인터페이스를 통한 개방 폐쇄 원칙: 위와 같은 구조의 코드에서 DashboardHelper에 다른 Reservation을 추가해야하는 경우가 생기더라도, 우리는 코드의 수정 없이 ReservationOrder를 상속받는 Reservation 클래스를 새로 만드는 것으로 기능 추가 를 할 수 있었다. 즉, 기능을 확장하면서도 기존의 코드에 대한 변경은 발생하지 않는다. 이러한 개방 폐쇄 원칙을 구현할 수 있는 이유는 변화되는 부분(위 그림에서는 Reservation을 읽어오는 부분)을 추상화 했기 때문이다. 상속을 통한 개방 폐쇄 원칙: 12345678910111213141516171819public class ResponseSender {	private Data data;	public ResponseSender (Data data) {		this. data = data	}		public void send() {		sendHeader();		sendBody();	}			protected void sendHeader() {		// 헤더 데이터 전송	}			protected void sendBody() {		// 바디 데이터 전송	}}위 예시는 HTTP 응답 데이터를 전송하는 클래스인 ResponseSender이다. 눈여겨봐야 할 점은 sendHeader()와 sendBody()가 protected로 선언되어있다는 점이다. 12345678910public class ZippedResponseSender extends ResponseSender {	public ZippedResponseSender(Data data) {		super(data);	}		@Overried	protected void sendBody() {		//데이터 압축 처리	}}HTTP 응답 데이터를 전송할 뿐만 아니라, 응답 데이터를 압축해서 전송할 수 있도록 기능을 확장하려 한다. 이를 위해서 ResponseSender의 sendBody()를 오버라이드하여 압축 로직을 추가한 ZippedResponseSender클래스를 생성했다. 이를 통해 기존 코드에 변경을 일으키지 않은 채, 압축 기능을 추가할 수 있다. 개방 폐쇄 원칙의 위반: 개방 폐쇄 원칙을 지키지 못한 코드에서는 여러가지 특징을 확인할 수 있다. 예시를 통해 이러한 특징을을 알아가보자. 다운 캐스팅을 한다, instanceof을 사용한다. : 위와 같은 상속관계를 지니는 슈팅게임을 개발하려 한다. 이때, 화면에 캐릭터를 표시하는 코드가 아래와 같이 구현되었다. 12345678public void drawCharacter(Character character) {	if (character instanceof Missile) {		Missile missile = (Missile) character; //다운캐스팅		missile. drawSpecific();	} else {		character. draw();	}}화면에 캐릭터를 표시하는 코드 만일 Character 타입이 Missile인 경우, 별도로 drawSpecific() 메서드를 호출하도록 처리하고 있다. 이러한 구현은 Character 클래스가 확장될 때 drawCharacter() 메서드가 함께 수정될 가능성을 증가시킨다. 즉 변경에 닫혀있지 않다. 비슷한 if-else 블록이 존재한다. : 위의 예시에서, Enemy 캐릭터의 움직이는 경로를 패턴화하는 코드를 작성하려 한다. 123456789101112131415161718192021public class Enemy extends Character {	private int pathPattern;		public Enemy(int pathPattern) {		this. pathPattern = pathPattern;	}		public void draw() {		if (pathPattern == 1) {			x += 4;		}		else if (pathPattern == 2) {			y +=10;		}		else if (pathPattern == 4) {			x += 4;			y +=10;		}		// . . . 	}}Enemy 캐릭터의 움직이는 경로를 패턴화하는 코드 만일 Enemy 캐릭터에 새로운 경로 패턴을 추가하고 싶다면, 우리는 매번 새로운 if 블록을 추가하는 식으로 draw() 메서드를 수정해야 한다. 즉, Enemy 클래스는 닫혀있지 않다.  12345678910111213public class Enemy extends Character {	private PathPattern pathPattern;		public Enemy(PathPattern pathPattern) {		this. pathPattern = pathPattern;	}		public void draw() {		int x = pathPattern. nextX();		int y = pathPattern. nextY();		// . . . 	}}위와 같이 PathPattern을 추상화 하는 것으로, 우리는 Enemy클래스의 변경 없이 새로운 경로 패턴을 추가할 수 있다. 3. 리스코프 치환 원칙:  상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.  리스코프 치환 원칙은 개방 폐쇄 원칙을 받쳐주는 다형성에 대한 원칙을 제공한다. 위 원칙을 간단한 코드로 나타내면 아래와 같다. 1234567public void someMethod(SuperClass sc) {	sc. someMethod();}//. . . someMethod(new SubClass()); //정상 동작 해야한다. 상위 타입의 객체를 사용하는 메서드 리스코프 치환 원칙의 위반: 리스코프 치환 원칙은 기능의 명세에 대한 내용이다. 하위 타입이 상위 타입의 기능 명세를 위반했을 때 발생한다. 그 사례로는 아래와 같은 내용이 있다.  명세에서 벗어난 기능을 수행한다.  명세에서 벗어난 값을 리턴한다.  명세에서 벗어난 익셉션을 발생한다. 명세에서 벗어난 기능을 수행한다. : 1234567891011121314151617public class Rectangle { //직사각형	private int width;	private int height;		public void setWidth(int width) {		this. width = width;	}	public void setHeight(int height) {		this. height = height;	}	public int getWidth() {		return width;	}	public int getHeight() {		return height;	} }12345678910111213public class Square extends Rectangle { //정사각형	@Override	public void setWidth(int width) {		super. setWidth(width);		super. setHeight(width);	}		@Override	public void setHeight(int height) {		super. setWidth(height);		super. setHeight(height);	}}위 예시는 리스코프 치환 원칙을 설명할때 자주 사용되는 직사각형-정사각형 문제이다. Rectangle 클래스는 직사각형을, 그리고 Square 클래스는 Rectangle을 상속받아 정사각형을 구현한다. 이때, Rectangle의 height를 수정하는 메서드를 살펴보자.  12345public void increaseHeight(Rectangle rec) {	if (rec. getHeight() &lt;= rec. getWidth()) {		rec. setHeight(rec. getWidth() + 10);	}}Rectangle의 높이를 조절하는 메서드 위 메서드는 직사각형의 높이를 10 높이는 의도를 가지고 있다. 따라서 개발자들은 increaseHeight()의 실행 이후 직사각형은 서로 다른 width와 height를 지니고 있다고 예상할 것이다. 그러나 increaseHeight의 인자로 Square 객제가 전달되는 경우 위 가정은 깨지게 되며, increaseHeight()의 의도와 다른 방식으로 동작하게 될 것이다.  12345678public void increaseHeight(Rectangle rec) {	if (rec instanceof Square) {		// . . . 예외 발생	}	if (rec. getHeight() &lt;= rec. getWidth()) {		rec. setHeight(rec. getWidth() + 10);	}}instanceof를 사용한다면 위 문제가 해결될 수 있으나, 앞서 살펴봤듯 Instanceof의 사용은 . 그 자체가 개방 폐쇄 원칙을 위반한다. 위 문제 직사각형과 정사각형이 개념적으로는 상속관계처럼 보이나, 실제로는 그렇지 않기에 발생한다. 정사각형은 직사각형의 명세에서 벗어난 기능(가로와 세로폭을 동일하게 고정하는)을 수행한다. 따라서 실제 구현에서는 정사각형과 직사각형을 별개의 타입으로 구현해주어야 한다. 명세에서 벗어난 값을 리턴한다. : 1234567891011public class CopyUtil {	public static void copy(InputStream is, OutputStream out) {		byte[] data = new byte[512];		int len = -1;				// InputStream의 read 메서드는 스트림의 끝에 도달하면 -1을 반환한다. 		while((len = is. read(data)) != -1) {			out. write(data, 0, len);		} 	}}CopyUtil은 InputStream의 read 메서드는 스트림의 끝에 도달하면 -1을 반환한다는 명세를 사용하여 작성된 코드이다. 이때, InputStream을 상속받는 하위 클래스 SatanInputStream을 아래와 같이 구현했다.  12345public class SatanInputStream extends InputStream {	public int read(byte[] data) {		return 0; //스트림의 끝에 도달하면 0을 반환	}}만일 개발자가 CopyUtil의 copy 메서드에 InputStream 대신 SatanInputStream을 전달한다면, is. read(data)는 스트림의 끝에서 0을 반환하기에 무한루프를 발생시킨다. 이는 하위 클래스 SatanInputStream가 상위 클래스 InputStream의 명세에서 벗어난 값을 리턴했기에 발생하는 문제이다. 4. 인터페이스 분리 원칙:  인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. (클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다) 인터페이스 분리 원칙은 C나 C++과 같이 컴파일과 링크를 직접 해주는 언어를 사용할때 장점이 잘 드러난다. 그러나 C와 C++에서의 설명은 다른 책이나 포스팅을 찾아보도록 하고, 이 포스팅에서는 Java를 사용하여 설명하도록 하겠다… (현재 공부하고 있는 책에서는 C로 예시를 들었다. ) 12345678910111213141516171819202122232425262728293031public interface Worker {  void work();  void eat();}// 사무직 직원public class OfficeWorker implements Worker {  @Override  public void work() {    // . . .   }  @Override  public void eat() {    // . . .   }}// 로봇public class Robot implements Worker {  @Override  public void work() {    // . . .   }  @Override  public void eat() {    // 해당 기능이 필요하지 않으나, 인터페이스에 의해 구현해만 한다!  }}위와 코드는 Worker 인터페이스를 사용하는 OfficeWorker와 Robot의 예시이다. Robot은 eat() 메서드가 필요하지 않으나, Worker 인터페이스를 상속받은 이상 eat() 메서드를 구현해야한다. 또한 Worker 메서드에 새로운 메서드를 추가한다면, 해당 인터페이스를 사용하는 클래스 모두에서 변경이 발생하게 된다. 해당 메서드가 필요하지 않더라도 말이다.  123456789101112131415161718192021222324252627public interface Workable {  void work();}public interface Eatable {  void eat();}public class OfficeWorker implements Workable, Eatable {  @Override  public void work() {    // . . .   }  @Override  public void eat() {    // . . .   }}public class Robot implements Workable {  @Override  public void work() {    // . . .   }}인터페이스 분리 원칙이 적용된 코드 Worker 인터페이스를 각 클라이언트(OfficeWorker, Robot)이 필요로 하는 인터페이스로 분리한다면 위와 같은 문제는 사라진다. 이렇게 클라이언트 입장에서 사용하는 기능만을 제공하도록 인터페이스의 책임을 분리하는 것은 단일 책임 원칙과도 연결된다. 즉 인터페이스 분리 원칙을 따르는 것으로 인터페이스와 콘크리트 클래스의 재사용성을 높일 수 있다. 5. 의존 역전 원칙:  고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.  고수준 모듈과 저수준 모듈은 위와 같이 구분할 수 있다. 즉, 저수준 모듈은 고수준 모듈에서 사용하는 하위 기능을 실제로 어떻게 구현하는가에 대한 내용을 담고있다. 고수준 모듈의 저수준 모듈 의존: 프로젝트의 초기 요구사항이 안정화된 이후에는, 큰 틀보다는 상세 수준에서의 변경이 주로 발생한다. 따라서 만일 고수준 모듈이 저수준 모듈을 의존하고 있다면, 저수준 모듈의 변경에 따라 고수준 모듈도 함께 변경되게 된다. 1234567891011121314public int caculate() {	// . . . 		if (someCondition) {		CouponType1 type1 = . . . 		. . . 	}	else {		CouponType2 type2 = . . . 		. . . 	}	// Coupon이란 저수준 모듈이 추가될때마다	// 고수준 모듈인 가격 계산 모듈이 변경된다. }위는 쿠폰의 종류에 따라 가격을 할인해주는 가격 계산 모듈의 예시이다.  이때, 가격 계산 모듈은 개별적인 쿠폰 구현에 의존하고 있다. 이는 쿠폰의 구현이 추가되거나 변경될 때마다 가격 계산 모듈의 변경을 야기한다. 저수준 모듈의 고수준 모듈 의존: 추상화를 사용하면 저수준 모듈이 고수준 모듈을 의존하도록 할 수 있다. 앞서 살펴봤던 예시인 ReservationOrder의 예시를 살펴보면, 고수준 모듈인 DashboardHelper와 하위 모듈인 OnlineReservation과 OfflineReservation 모두 ReservationOrder에 의존하는 것으로 고수준 모듈의 변경 없이 저수준 모듈을 변경할 . 수있는 유연함을 얻을 수 있다. 이때 만들어지는 ReservationOrder의 인터페이스는 저수준 모듈보다는 고수준 모듈인 DashboardHelper의 입장에서 만들어진다.  12345678910public interface ReservationOrder {	Integer getTotalPriceOfPaidOrder();	Boolean isMenuAndStatusConfirmed();	Boolean isStatusConfirmedAndPaidWithoutNoShow();	String getMenuName();}DashboardHelper의 입장에서 만들어진 ReservationOrder 이것은 고수준 모듈이 저수준 모듈에 의존했던 상황이 역전되어, 저수준 모듈이 고수준 모듈이 고수준 모듈에 의존하게 된다는 것을 의미한다.   저수준 모듈이 고수준 모듈을 의존하도록 변경되었으나, 이는 소스코드상에서의 이야기이지 런타임에서의 의존은 여전히 고수준 모듈의 객체에서 저수준 모듈의 객체로 향한다.  런타임에서의 의존과 소스코드의 의존을 구분하도록 하자. "
    }, {
    "id": 16,
    "url": "http://localhost:4000/design-pattern-3/",
    "title": "디자인패턴(3)- 재사용 | 상속보단 조립",
    "body": "2024/09/30 - 이전 포스팅  객체지향 다형성과 추상 타입0. 개요: 객체 지향의 주요 특징 중 하나는 코드의 재사용이다. 이런 재사용을 위해 사용할 수 있는 여러 방법이 있는데, 나는 주로 상속을 사용해왔다. 그러나 코드를 재사용하기 위해 상속을 사용하는 것은 몇가지 문제점을 초래한다. 이번 챕터에서는 이에 대해 자세히 알아보도록 한다. 1. 상속과 재사용: 상속: Spring MVC의 Controller 계층구조를 통하여 상속에 대해 알아보자.  Spring MVC의 Controller간 상속관계는 위와 같다. 이때 각 객체는, 자신이 상속받고 있는 상위객체의 기능에 더불어 자신만의 기능을 추가적으로 제공한다. 이렇게 상속을 상요하면 다른 클래스의 기능을 쉽게 재사용하면서, 추가 기능을 확장할 수 있게된다. 그러나 상속은 변경의 유연성을 해한다는 치명적인 단점을 지니고있다. 2. 상속을 통한 재사용의 단점: 상위 클래스: 첫번째 포스팅에서 의존의 전이에 대해 다뤘었다.  💡   의존(Dependency)  한 객체가 다른 객체를 생성하거나, 파라미터로 전달받거나, 다른 객체의 메서드를 호출하는 것. 	한 객체의 변경사항이 다른 객체의 변경을 줄 가능성이 높아지는 것.  상속또한 다른 객체에 대한 의존을 야기한다. 따라서 의존하는 클래스의 코드의 변경은 해당 클래스를 상속받는 클래스에 또한 변경이 발생할 수 있다.  이를태면 AbstractController의 변경은 AbstractController을 상속받은 BaseCommandController와 AbstractUrlViewController의 변경을 불러일으킬수 있다. 또한 이렇게 발생한 BaseCommandController 의 변경은 BaseCommandController을 상속받은 AbstractCommandController과 AbstractFormController의 변경을 불러일으킬 수 있다. 이렇게 상속에 의해 발생한 의존에 의해 변경의 여파는 계층도를 따라 하위 클래스에 계속 전파된다. 따라서 계층도가 커질수록 상위 클래스의 변경은 점점 어려워진다. 클래스의 불필요한 증가: 경우에 따라 상속은 기능 확장에 있어서도 쓰임이 불편할 수 있다. 아래의 경우를 예시로 들어보자.  위 클래스 계층도는 파일 보관소를 구현한 Storage 클래스와, 그에 압축 기능과 암호화 기능을 추가로 구현한 파일 저장소인 CompressedStorage와 EncryptedStorage이다. 이제 여기서 기능을 더 확장하려고 한다. 압축을 한 뒤 암호화를 하는 저장소와, 암호화 한 뒤 압축하는 저장소와 암호화된 저장소에 캐시를 적용하는 저장소이다. 상속을 통해 기능을 적용해보자.  결과적인 클래스 계층은 위와 같아진다. 거기에 만일 Java를 사용한다면, 다중상속이 불가능하기에 한개의 클래스만 상속받고 별도로 기능을 구현해주어야 할 것이다. 이렇게 필요한 기능의 조합이 증가할수록 상속을 통한 기능 재사용은 클래스의 개수 증가를 불러일으킨다. 상속의 오용: 상속 자체를 잘못 사용하게 되는 경우또한 발생할 수 있다. 이번에도 예시를 통해 알아보자. 123456789101112public class Container extends ArrayList&lt;Luggage&gt; {	private int maxSize;	private int currnetSize;		public void put(Luggage lug) throws NotEnoughSpaceException {		if(!canConatain(lug)) throw new NotEnoughSpaceException();		super. add(lug);		currentSize += lug. size();	}}. . . ArrayList를 상속받는 클래스 Container가 있다. Container 클래스는 put() 메서드를 통해 현재 Container 내부의 크기를 검증하고, 만일 크기가 초과되지 않는다면 ArrayList의 add() 메서드를 통해 ArrayList에 수화물을 추가한 후 Container의 크기를 증가시킨다. 그러나 위 코드는 아래와 같이 잘못 사용될 수 있다.  123456789101112Container c = new Container(5);if (c. canContain(size3Lug)) { 	c. put(size3Lug); //정상 사용, currnetSize: 3}if (c. canContain(size2Lug)) {	c. add(size2Lug) //비정상 사용, currnetSize 늘어나지 않음. }if (c. canContain(size1Lug)) {	c. put(size1Lug); // 사이즈 5짜리 컨테이너에 6개의 수화물이 들어갔다!}Container 클래스를 개발한 개발자가 다른 개발자들에게 수화물을 추가할때 ArrayList의 add() 메서드가 아닌 Container의 put() 메서드를 사용하라 일렀을지라도, 다른 개발자들은 IDE의 자동완성이 제시한 add() 메서드를 사용할 수 있다.  위와 같은 실수가 발생한 이유는 Container와 ArrayList 사이에 IS-A 관계가 성립하지 않기 때문이다.  즉 Container는 ArrayList가 아니다. Container는 수화물을 보관하는 책임을 지는 반면 ArrayList은 목록을 관리하는 책임을 지닌다. 완전히 다른 책임을 지니는 두 클래스를 상속하 문제가 발생하게 된다.  그렇다면 IS-A관계에 해당하지 않는 클래스의 코드를 재사용하기 위해선 무엇을 사용해야하는가? 3. 조립을 이용한 재사용: 객체 조립(Composition)은 여러 객체를 묶어 더 복잡한 기능을 제공하는 객체를 만드는 기술이다. 객체지향 언어에서 객체 조립은 필드에서 다른 객체를 참조하는 방식으로 구현된다. 12345678public class FlowController {	private Encryptor encryptor = new Encryptor();		public void process() {		. . . 		byte[] encrtptedData = encryptor. encrypt(data);	}}객체 참조의 예시 클래스 비증식: 앞서 클래스 증식 문제를 야기한 Storage 예제를 다시 살펴보자.  위와 동일한 기능을 구현하는 객체를 상속이 아닌 객체 조립의 형태로 재구성한다면 아래와 같아진다.  상속 대신 조립을 사용한 객체 Storage는 이제 기능을 확장해도 클래스가 증식하지 않는다. 확장된 기능 또한 조립하면 되기 때문이다.  그렇다면 Storage가 Compressor와 Encryptor을 상속하는 방식으로 구현할수도 있지 않을까? 그러나 그러한 방식은 Storage 클래스를 저장소 자체가 아닌 압축이나 암호화 목적으로 사용할 수 있게 되며, 경우에 따라 Storage 클래스의 내부 상태가 비정상적으로 변경될 수 있다.  또한 상속의 경우 런타임에서 상위 클래스를 교체할 수 없으나, 조립을 사용하면 런타임시 조립 대상 객체를 교체할 수 있게된다는 장점또한 존재한다. 위임: 위임(delegation)을 통해 내가 할 일을 다른 객체에게 넘길 수 있다. 이는 보통 조립을 사용하여 구현된다. 아래의 예시를 보자 12345678910public abstract class Figure {	private Bounds bounds = new Bounds();		// . . . 		private boolean contains(Point point) {		return bounds. contains(point. getx(), point. getY());	}}위 코드는 마우스 포인터의 위치가 특정 도형이 차지하는 영역에 포함되어 있는지 확인하는 기능을 구현한 코드이다. 도형과 관련된 클래스 Bounds 클래스가 이미 해당 기능을 제공하고 있기 때문에, 도형을 표현하는 클래스인 Figure 클래스는 Bounds 객체에게 포함 여부 확인을 위임하고 있는 걸 확인할 수 있다. 상속은 언제 사용하는가?: 지금까지 상속보다는 조립을 사용한 코드 재사용의 장점을 알아보았다. 그렇다면 상속은 언제 사용해야 할까? 상속을 사용할때에는 재사용의 관점이 아닌 기능의 확장이라는 관점에서 상속을 적용해야한다. 또한 명확한 IS-A 관계가 성립되어야 한다. 상속을 사용한 클래스 계층은 , 상위 클래스의 기본적인 기능을 그대로 유지하면서 그 기능을 확장해나간다는 특징을 가지고 있다. "
    }, {
    "id": 17,
    "url": "http://localhost:4000/toeic/",
    "title": "토익 920점 후기",
    "body": "2024/09/25 - 사실상 자랑에 가까운 게시글이다…. 정보를 위해서 이 글을 읽는 사람은 없길 바란다(정보성이라곤 전혀 없음)  결론적으로는 목표점수였던 800점을 넘어 920점을 받았다. 이전에 토익을 쳐본적은 없었고, 이번이 첫 시험이었다. 기존 영어 실력: 솔직히 원래 영어를 못하는 편은 아니다. 고등학교 때도 영어공부를 필사적으로 하지 않았지만 못하면 3등급, 잘하면 1등급, 일반적으론 2등급 정도가 나왔다. (절대평가였으니 ‘잘한다’까진 아니고 ‘못하진 않는다’정도로 평가하는게 좋을것 같다. ) 대학생 2학년 때는 인맥으로 고등학교 야간 교시 아르바이트를 했었다. 3명의 학생에게 영어를 가르쳤다. 그러나 이 학생들도… 영어를 정말 못하는 아이들이라서 내 실력으로 가르칠 수 있었던 거라 생각한다. 그러나 이것도 대학년 2학년까지의 이야기… 그 이후로는 영어와는 정말 거리를 두고 살았다. 코딩을 하면서도 정말 간단한 단어의 스펠링을 적을 수 없는 것을 보고 좀 심각하다 느꼈다. 다시 말해 일단 ‘기초 실력’은 있었다.  그러나 내가 내 영어 실력을 낮게 평가한 것에 비해 기출문제집은 의외로 잘 풀렸다. 기출문제집을 풀어봤을 때는 시간내에 RC, LC를 포함한 모든 문제를 풀수 있는 실력은 되었다. 굉장히 빈약한… 5분정도의 여유시간이 있었다. 토익이 점수가 딱딱 정해진 것이 아니라 기출문제집에서 몇점이 나왔다 계산은 할 수 없었지만… 기출 문제집을 풀어보며 실제 시험에서 아주 못해도 졸업에 필요한 점수는 넘을 거고, 적어도 800점대는 나올거고, 잘하면 900점대가 나올 수도있겠다 생각했다. 공부 기간: 제대로 공부한것은 4일 정도이다. 원래는 9월 7일자 시험을 칠 생각이 아니었다. 공부가 더 필요할 것이라 생각했기 때문에… 그러나 일단 시험이 어떤 느낌으로 진행되는지 알아야 할 것 같아 가장 빠른 시험을 등록했다. (내 피같은 5만원…) 그것이 약 일주일 뒤인 9월 7일의 시험이었다. 그리고 8월 30일부터 3일까지 여행을 갔다…ㅎㅎ 총 공부량으로 따지자면 ETS 토익 기출 문제집 RC를 3챕터, LC를 4챕터 풀었다. 문제집에서 나오는 모르는 단어만을 정리했고, 따로 외운 영어 단어는 없다. 기출문제집과 실제 시험의 난이도 비교: 친구에게는 기출문제집이 실제 시험보다 훨씬 어렵다고 전해들었다. LC와 같은 경우 기출문제집보다 훨씬 헷갈렸던거 같다. (아니면 긴장해서 그랬나…) 그러나 RC의 경우 비교적 수훨하게 풀렸던 것 같다. 풀이 시간과 점수는 기출문제집을 풀었을때와 비슷하게 나왔다. LC가 헷갈렸다고 느껴진 것에 비해 점수는 잘나와서 다행…. 오히려 수월하다 느꼈던 RC가 더 점수가 낮게 나왔다; 느낀점: 900점대가 나와서 기쁘긴한데, 기분이 조금 이상한 것도 사실이다. (물론 920이란 점수가 아주 높은 점수라곤 할 수 없다. 공대 기준 높은 점수이지 문과 기준으로는 900점은 기본으로 받아야 한다 하니까;;) 아무튼… 솔직히 지금까지 토익을 좀 두려워해왔던 것도 있다; 이보단 훨씬 어려울줄 알고 계속 미뤄왔던 건데 이렇게 허탈하게 해치울줄은 몰랐다. (물론 내 기대대로 엄청나게 어려운 시험이라서… 700점 이하로 받는것보다 900점을 받는게 낫긴하지만… 그렇긴 하지만…) 뭐든 일단 두려워하지 말고 도전을 하자. 운이 좋다면 내가 두려워했던 것에 비해 별거 아닌 상대일 것이고, 못해도 실전 경험을 얻게되는 것이니 손해볼건 없다. "
    }, {
    "id": 18,
    "url": "http://localhost:4000/design-pattern-2/",
    "title": "디자인패턴(2)- 다형성과 추상 타입",
    "body": "2024/09/24 - 이전 포스팅  객체지향0. 개요: 객체지향이 주는 가장 핵심적인 장점은 구현 변경의 유연함이다. 이러한 유연성을 위한 방법이 두가지 있는데, 하나는 캡슐화이고 다른 하나는 추상화이다. 캡슐화에 대한 내용은 이전 포스팅에서 다뤘으니, 이번엔 추상화에 대해 알아보자. 1. 다형성과 상속:  💡   다형성(Polymorphism)  한 객체가 여러가지(poly) 모습(morph) 즉 타입을 갖는 것 자바에서는 타입 상속을 통하여 다형성을 구현한다. 1234567891011public class Plane() {	public void fly() { }}	public interface Turbo { 	public boid boost();}	public class TurboPlane extends Plane implements Turbo { 	public void boost() { }}위 코드에서는 인터페이스 Turbo와 클래스 Plane을 상속받고 있는 TurboPlane을 확인할 수 있다. TurboPlane 은 Turbo와 Plane에서 정의된 모든 기능(fly(), boost())을 제공한다. 123456TurboPlane tp = new TurboPlane();Plane p = tp; //업캐스팅Turbo t = tp; //업캐스팅t. boost();또한 TurboPlane은 Plane 타입과 Turbo 타입이 될 수 있다. 위 코드는 TurboPlane을 업캐스팅을 통해 Plane과 Turbo로 업캐스팅한 예시 코드이다. 이때 변수 p와 t는 모두 동일한 객체인 tp를 가리키고있다. TurboPlane 객체가 두 가지 다른 형태(Plane와 Turbo)로 동작할 수 있다는 점에서 다형성이 발생함을 알 수 있다. 2. 인터페이스 상속과 구현 상속: Java에는 세가지 상속이 있다. 이들의 특징에 대해 알아보자. 클래스 상속: 12345678910111213public class Plain() {	public void fly() { 	// . . . 실제 구현	}}	public class Jet extends Plane { }. . . Jet j = new Jet();j. fly(); 구현 상속: 상위 클래스에 정의된 기능을 재사용할 수 있다. (상위 클래스에 구현된 메서드의 구현을 함께 상속) 단일 상속: 한 클래스의 하나의 부모 클래스만 상속받을 수 있다. (다중 상속 지원x) 재정의: 하위 클래스는 상위 클래스에 정의된 기능을 자신에 맞춰 수정할 수 있다. 인터페이스 상속: 123456789public interface Turbo { 	public void boost();}	public class TurboPlane implements Turbo { 	public void boost() {	// . . . 실제 구현	}} 시그니처 상속: 인터페이스는 메서드 시그니처만 제공할 뿐 실제 구현은 제공하지 않는다.  다중 상속: 하나의 클래스가 여러 개의 인터페이스를 상속받을 수 있다. 추상 클래스 상속: 12345678910111213141516171819public abstract class Plain() {	public abstract void boost();		public void fly() { 		// . . . 실제 구현	}	}	public class Jet extends Plane { 	public void boost() {		// . . . 실제 구현	}}. . . Jet j = new Jet();j. fly(); 단일 상속: 한 클래스의 하나의 부모 클래스만 상속받을 수 있다. (다중 상속 지원x) 추상 메서드와 구현된 메서드를 모두 지님     구현 상속: 상위 클래스에 구현된 메서드를 재사용할 수 있다.    시그니처 상속: 추상 메서드는 메서드 시그니처만 제공할 뿐 실제 구현은 제공하지 않는다.    메서드 오버라이딩: 구현 상속에서는 재정의를 통해 하위 타입이 상위 타입의 메서드 구현을 수정할 수 있다. 이를 메서드 오버라이딩이라고 한다. 1234567891011121314public class Plane() {	public void fly() { 		// . . . 실제 구현	}}	public class Jet extends Plane { 	public void (fly) {		//메서드 오버라이딩을 통한 재정의	}}Plane p = new Jet();p. fly(); // Jet에서 재정의된 메서드 실행위의 예시를 보자. 하위 타입인 Jet은 상위 타입인 Plane의 메서드를 오버라이딩을 통해 재정의했다. 이때 p. fly();을 통해 실행되는 메서드는 Plane의 메서드가 아닌 Jet에서 재정의된 메서드이다. 객체 p는 타입캐스팅되었기에 p가 실제로는 타입 Jet을 가리키고 있기 때문이다. 3. 추상 타입과 유연함: 이하로는 실제 내가 세차새차에서 경험한 추상화의 장점에 대해 설명해보겠다.  세차새차에서는 현재 예약의 종류를 두 종류로 나누고있다. 고객이 세차새차 플랫폼을 통해 예약을 등록하는 ‘온라인 예약’과 오프라인으로 예약이 들어올 경우 세차장 사장님이 직접 예약을 등록하는 ‘오프라인 예약’이다. 현재는 존재하지 않지만 이후 ‘카카오 예약’이나 ‘네이버 예약’과 같은 종류의 예약이 등록될 예정이다. 이때 이 여러 종류의 예약들은 각자 제공하는 기능에 차이점이 있으나 ‘예약 정보를 대시보드에 동일한 형태로 제공함’이라는 기능만은 모두 동일하게 가지고 있다.  나는 OfflineReservation만을 반영할 수 있는 대시보드가 OnlineReservation를 함께 반영시킬수 있도록 기능을 확장하는 이슈를 맡게됐다. 구현 이전의 코드는 아래와 같다. 12345678910111213141516171819202122public class DashboardManagerService {	// 생성자 주입	@Transactional(readOnly = true)	public DashboardManagerResponseDto getDashboardBySlugWithStatus(String slug) {		// . . . 오늘치 Offline예약을 가져오는 로직		List&lt;OfflineReservationOrder&gt; todayOrders = offlineReservationOrderService. getAll(todayOfflineReservationList);		return DashboardManagerResponseDto. builder()			//오늘치 Offline 예약의 총 개수			. reservationCount(todayOfflineReservationList. size())			//오늘 미완수된 Offline 예약의 총 개수			. remainingReservationCount(dashboardHelper. calculateRemainingReservationCountWithStatus(todayOfflineReservationList))			//오늘치 Offline 예약 수익			. todayRevenue(dashboardHelper. calculateTodayRevenueWithStatus(todayOfflineReservationList))			//오늘 가장 많이 주문된 Offline 예약 메뉴			. mostOrderedMenuName(dashboardHelper. findMostOrderedMenuNameWithStatus(todayOrders))			. offlineReservations(. . . )			. build();	}}12345678910111213141516171819202122232425262728293031public class DashboardHelper {	//오늘치 Offline 예약 수익	@Transactional(readOnly = true)	public Integer calculateTodayRevenueWithStatus(List&lt;OfflineReservation&gt; todayOfflineReservationList) {		return todayOfflineReservationList. stream()			. filter(reservation -&gt; OfflineReservationPaymentStatus. PAID. equals(reservation. getPaymentStatus())) // 결제 완료된 예약만 필터링			. mapToInt(OfflineReservation::getTotalPrice)			. sum();	} //오늘 가장 많이 주문된 Offline 예약 메뉴	@Transactional(readOnly = true)	public String findMostOrderedMenuNameWithStatus(List&lt;OfflineReservationOrder&gt; todayOfflineReservationOrderList) {		return todayOfflineReservationOrderList. stream()			. filter(order -&gt; order. getParentOrder() == null &amp;&amp; OfflineReservationStatus. CONFIRMED. equals(order. getOfflineReservation(). getReservationStatus())) // 옵션 제외, 확정된 예약만 필터링			. collect(Collectors. groupingBy(OfflineReservationOrder::getMenuName, Collectors. counting())) // 메뉴 이름 별 개수			//. . . 			. orElse(  );	} //오늘 미완수된 Offline 예약의 총 개수	@Transactional(readOnly = true)	public Integer calculateRemainingReservationCountWithStatus(List&lt;OfflineReservation&gt; todayOfflineReservationList) {		return (int)todayOfflineReservationList. stream()			. filter(reservation -&gt; OfflineReservationStatus. CONFIRMED. equals(reservation. getReservationStatus()) // 확정된 예약만					&amp;&amp; !OfflineReservationPaymentStatus. PAID. equals(reservation. getPaymentStatus()) // 결제 완료된 예약 제외					&amp;&amp; !reservation. isNoShow()) // 노쇼 제외			. count();	}}대시보드에 제공할 형태를 가공하는 역할인 DashboardHelper의 모든 메서드가 OfflineReservation 용으로 fit하게 작성돼있다. OnlineReservation은 DashboardHelper의 모든 메서드 calculateTodayRevenueWithStatus, findMostOrderedMenuNameWithStatus, calculateRemainingReservationCountWithStatus을 사용할 수 없으므로 OnlineReservation용의 기능을 개발하기 위해서는 이미 존재하는 메서드들과 동일한 구현을 가진 메서드를 새로 작성해야하는 상황이다.  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DashboardHelper {	//오늘치 Offline 예약 수익	@Transactional(readOnly = true)	public Integer calculateTodayRevenueWithStatus(List&lt;OfflineReservation&gt; todayOfflineReservationList) {	// . . . 	}	//오늘 가장 많이 주문된 Offline 예약 메뉴	@Transactional(readOnly = true)	public String findMostOrderedMenuNameWithStatus(List&lt;OfflineReservationOrder&gt; todayOfflineReservationOrderList) {	// . . . 	}	//오늘 미완수된 Offline 예약의 총 개수	@Transactional(readOnly = true)	public Integer calculateRemainingReservationCountWithStatus(List&lt;OfflineReservation&gt; todayOfflineReservationList) {	// . . . 	}	//오늘치 Online 예약 수익	@Transactional(readOnly = true)	public Integer calculateTodayRevenueWithStatus(List&lt;OnlineReservation&gt; todayOnlineReservationList) {		return todayOnlineReservationList. stream()			. filter(					//. . . OnlineReservation용의 구현					) 			. mapToInt(OnlineReservation::getTotalPrice)			. sum();	}	//오늘 가장 많이 주문된 Online 예약 메뉴	@Transactional(readOnly = true)	public String findMostOrderedMenuNameWithStatus(List&lt;OnlineReservationOrder&gt; todayOnlineReservationOrderList) {		return todayOnlineReservationOrderList. stream()			. filter(					//. . . OnlineReservation용의 구현					) 			. collect(Collectors. groupingBy(OnlineReservationOrder::getMenuName, Collectors. counting())) // 메뉴 이름 별 개수			//. . . 			. orElse(  );	}	//오늘 미완수된 Online 예약의 총 개수	@Transactional(readOnly = true)	public Integer calculateRemainingReservationCountWithStatus(List&lt;OnlineReservation&gt; todayOnlineReservationList) {		return (int)todayOnlineReservationList. stream()			. filter(					//. . . OnlineReservation용의 구현					) 			. count();	}}위와 같은 코드는 그 누구도 바라지 않는다. 추상 타입을 이용한 구현 교체의 유연함: 나는 위와 같은 코드의 문제를 다형성을 이용해 해결했다. 12345678910public interface ReservationOrder {	Integer getTotalPriceOfPaidOrder();	Boolean isMenuAndStatusConfirmed();	Boolean isStatusConfirmedAndPaidWithoutNoShow();	String getMenuName();}1234567public OnlineReservation implements ReservationOrder {	// . . . }public OfflineReservation implements ReservationOrder {	// . . . }추상 타입 ReservationOrder의 상속에 의해 OnlineReservation과 OfflineReservation은 다형성에 의해 자기 자신의 타입뿐만 아니라 ReservationOrder의 타입으로도 동작하게 된다. 이러한 다형성의 특징을 사용하여 위의 코드를 아래와 같이 다시 구현할 수 있다.  1234567891011121314151617181920212223242526public class DashboardManagerService {	// 생성자 주입	@Transactional(readOnly = true)	public DashboardManagerResponseDto getDashboardBySlugWithStatus(String slug) {		// . . . 오늘치 Offline 예약과 Online 예약 리스트를 가져오는 로직		List&lt;OfflineReservationOrder&gt; todayOfflineOrders = offlineReservationOrderService. getAll(todayOfflineReservations);		List&lt;OnlineReservationOrder&gt; todayOnlineOrders = onlineReservationOrderService. getAll(todayOnlineReservations);		List&lt;ReservationOrder&gt; todayReservationOrders = new ArrayList&lt;&gt;();		todayReservationOrders. addAll(todayOfflineOrders);		todayReservationOrders. addAll(todayOnlineOrders);		return DashboardManagerResponseDto. builder()			//오늘치 Offline 예약의 총 개수			. reservationCount(todayReservations. size())			//오늘 미완수된 예약의 총 개수			. remainingReservationCount(dashboardHelper. calculateRemainingReservationCountWithStatus(todayReservationOrders))			//오늘치 예약 수익			. todayRevenue(dashboardHelper. calculateTodayRevenueWithStatus(todayReservationOrders))			//오늘 가장 많이 주문된 예약 메뉴			. mostOrderedMenuName(dashboardHelper. findMostOrderedMenuNameWithStatus(todayReservationOrders))			. offlineReservations(. . . )			. onlineReservations(. . . )			. build();	}12345678910111213141516171819202122232425public class DashboardHelper {		@Transactional(readOnly = true)	public Integer calculateTodayRevenueWithStatus(List&lt;ReservationOrder&gt; reservationOrders) {		return reservationOrders. stream()			. mapToInt(ReservationOrder::getTotalPriceOfPaidOrder)			. sum();	}	@Transactional(readOnly = true)	public String findMostOrderedMenuNameWithStatus(List&lt;ReservationOrder&gt; reservationOrders) {		return reservationOrders. stream()			. filter(ReservationOrder::isMenuAndStatusConfirmed)			. collect(Collectors. groupingBy(ReservationOrder::getMenuName, Collectors. counting())) // 메뉴 이름 별 개수			. // . . . 			. orElse(  );	}	@Transactional(readOnly = true)	public Integer calculateRemainingReservationCountWithStatus(List&lt;ReservationOrder&gt; reservationOrders) {		return (int) reservationOrders. stream()			. filter(ReservationOrder::isStatusConfirmedAndPaidWithoutNoShow)			. count();	}}다형성을 통해 이제 ReservationOrder 타입을 상속하는 모든 예약은 DashboardHelper의 모든 메서드 calculateTodayRevenueWithStatus, findMostOrderedMenuNameWithStatus, calculateRemainingReservationCountWithStatus 를 수정 없이 사용할수 있다. 이는 다형성을 통해 얻을 수 있는 유연성의 예시이다.  ReservationOrder의 종류가 변경되어도 DashboardHelper 클래스는 변경되지 않는다. 이때 상위 타입 ReservationOrder의 기능을 실제로 구현하는 하위 클래스(ex. OnlineReservation, OfflineReservation)를 실제 구현을 제공한다는 의미에서  ‘콘크리트 클래스’ 라고 부른다. 규칙: 인터페이스에 대고 프로그래밍하기:  💡   인터페이스에 대고 프로그래밍하기 (program to interface)  콘크리트 클래스가 아닌, 기능을 정의한 인터페이스를 사용해서 프로그래밍하라는 규칙 위는 객체 지향의 유명한 규칙 중 하나이다. 여기서 말하는 인터페이스란 Java와 같은 프로그래밍 언어에서 제공하는 인터페이스가 아닌, 오퍼레이션을 정의한 인터페이스를 의미한다. program to interface은 추상화를 통한 유연성을 얻기 위한 규칙이다. 이 원칙의 핵심은 코드에서 구체적인 구현 클래스 대신 인터페이스나 추상 클래스를 사용하여 객체와 상호작용하는 것이다. 그러나 주의할 점은, 추상타입의 증가는 구조의 불필요한 복잡함을 야기한다는 점이다. 따라서 우리는 변화 가능성이 높은 경우에만 인터페이스를 사용 해야만 한다. "
    }, {
    "id": 19,
    "url": "http://localhost:4000/docker-migration/",
    "title": "Github Docker Migration (feat. CICD docker-compose command not found)",
    "body": "2024/09/04 - 0. 개요: 갑자기 CICD가 실패한다! 이전까지 잘 작동했고, 수정한 사항이 없었기 때문에 갑작스럽게 느껴진 에러였다. BDD가 거처를 디스코드로 옮김으로서 슬랙이 폐쇄되고, 그 과정에서 슬랙과 연동된 알림에 문제가 생겨 발생한 에러인가 처음에 생각했으나. 슬랙 알림이 문제라기엔 발생한 에러는 docker-compose쪽 문제…. 🤔 대체 원인이 무엇인지 알아보러 가자. 1. 문제: 위와 같은 문제가 발생함을 확인했다. BDD 슬랙이 폐쇄되어, 슬랙에 알림을 전송하는 코드에서 오류가 발생하고 있음을 알 수 있었다. 단순히 슬랙에 알림을 전송하는 코드를 주석 처리하면 해결될 문제라고 생각했으나,,, 123456789   # - name: Notify Slack   #  if: always()   #  uses: 8398a7/action-slack@v3   #  env:   #   SLACK_WEBHOOK_URL: $   #  with:   #   status: $   #   author_name: DOO_RE Devlopment Backend CICD   #   fields: repo, commit, message, author, action, took주석 처리된 코드  docker-compose: command not found에러는 여전하다. 🤔이는 docker-compose 명령을 찾지 못한다는 의미로, 원래 정상적으로 작동해왔던 코드이기에 이상함을 느꼈다. 2. 고민: 가장 먼저 고려할 수 있었던 것은 docker-compose 설치 코드를 추가하는 것이었다. 그러나 (자세히 아는 부분은 아니지만) 우리는 배포 과정에서 docker hub를 쓰는 것도, 따로 self-hosted runner를 사용하는 것도 아니었기 때문에 Github Ubuntu를 CICD환경으로 사용해왔다. 그런데 갑자기 Docker Compose 설치가 되어있지 않다고 에러가 뜨는 것은 이상하다…🫤 3. 해결:  GitHub deprecated v1, and you need to change the command from, e. g. , docker-compose build to docker compose build (remove the dash) Docker v1 사용 문제였다! Github에서 더 이상 v1 Docker를 사용하지 않기로 업데이트 된 모양이다. 그래서 Github Ubuntu를 사용한 CICD 환경에서 V1 Docker 명령어를 인식하지 못해 에러가 발생했던 거 같다. 12   - name: Start Containers    run: docker-compose -p doo-re up -d수정 전(V1 명령어 사용) 12   - name: Start Containers    run: docker compose -p doo-re up -d수정 후(V2 명령어 사용) V2 명령어로 CICD 스크립트를 수정하는 것으로 해결할 수 있었다. Docker V1 → V2 migration과 관련된 내용은 아래 링크에서 더 자세하게 확인할 수 있다.  Error: docker-compose command not found · community · Discussion #116610 Migrate to Compose V2두레에서 더 이상 백엔드 작업은 진행하지 않기로 했다😥 (서버 이전까지만 진행하기로…)두레를 통해 백엔드 개발을 처음 시작했고, 많은 애정을 쏟고, 열심히 일했던 프로젝트이지만 솔직히 말해서 현재 두레의 코드는 영 만족스럽지 않다. 그래서 코드를 개선하고 싶었지만… 나의 의지와는 관계없이 더 이상 두레를 통한 새로운 도전도, 두레의 코드 개선도 불가능할거 같다는 생각이 들었고, 이것이 큰 스트레스였다😅새로운 도전을 할 수 있는 다른 프로젝트를 시작해보려한다. 그래도 인프라 이슈가 생길 때마다 포스팅은 업데이트 될 예정이다. "
    }, {
    "id": 20,
    "url": "http://localhost:4000/design-pattern-1/",
    "title": "디자인패턴(1)- 객체 지향",
    "body": "2024/08/19 - 0. 개요: 본 포스팅은 ‘개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴’을 읽고 정리한 포스팅이다. 디자인 패턴을 공부하게 된 계기는 단순하다. ‘어떻게 코드를 짜야 좋은 코드가 되는가’ 고민하는 것을 넘어 이를 같이 일하는 팀원에게 설득하려면, 단순 나의 뇌피셜이 아닌 신뢰할 수 있는 자료나 기술이 뒷받침되야 할거 같다 느꼈기 때문이다. 😅 1. 절차지향과 객체지향:  💡   절차지향  프로시저(procedure)을 통해 프로그램을 구성하는 기법 절차지향은 Procedure Oriented의 번역이다. 여기서 Procedure가 의미하는 바를 살펴보면 아래와 같다. 사전적 Procedure: 사전상 Procedure의 의미는 위와 같다. IT의 프로시저: 1234567891011DELIMITER $$CREATE PROCEDURE GetEmployeesByDepartment(IN dept_name VARCHAR(50))BEGIN  SELECT employee_id, first_name, last_name  FROM employees  WHERE department = dept_name;END $$DELIMITER ;동시에 개발 용어로서의 프로시저는 데이터베이스에 대한 일련의 작업을 정리한 절차를 관계형 데이터베이스 관리 시스템이 저장한 것을 의미한다. 위와 같은 식은 컴퓨터 공학을 전공했거나 백엔드 공부를 해본 사람이라면 익숙할지도 모른다. 위와 같은 식이 바로 프로시저이다.  절차지향 방식은 이런 프로시저를 사용하여 데이터를 조작하는 코드를 작성하는 것이다. 그래서 개인적으로 ‘절차’보다는 ‘데이터 중심적인 코드 작성 방법’이라 생각하는 편이 더 이해가 빨랐다.  평균값 출력 프로그램 위는 수학,영어,국어 점수의 평균값을 계산한 후 평균값을 화면에 출력하는 프로그램의 구조이다. 이렇게 절차 지향 프로그램은 데이터 중심으로 짜여지고, 자연스럽게 프로시저끼리 공유하는 데이터가 생긴다. 절차지향 방식의 문제: 그러나 이런 ‘데이터 중심적인’ 방식은 데이터 의존도에 의해 문제가 발생한다.  데이터 타입이나 의미가 변경되면 함께 수정해야하는 프로시저가 증가한다.  같은 데이터를 프로시저들이 다른 의미로 사용하는 경우가 발생한다. 예를 들어 위의 평균값 출력 프로그램에 ‘시험종료’ 데이터를 추가해보자. 시험 종료 데이터는 Boolean 값으로, true일때 평균 계산 프로시저와 화면 출력 프로시저가 작동한다. 그러나 ‘시험 종료’ 데이터를 ‘시험 시작 전’, ‘수학 시험 종료’, ‘영어 시험 종료’, ‘국어 시험 종료’, ‘시험 종료’ 타입을 지닌 Enum값으로 변경한다고 하자. ‘시험 종료’ 데이터의 수정은 ‘시험 종료’ 데이터를 공유하는 ‘평균 계산 프로시저’와 ‘화면 출력 프로시저’의 수정을 야기한다. 2. 객체 지향:  💡   객체 지향  객체를 통해 프로그램을 구성하는 기법 객체 지향은 데이터와 데이터와 관련된 프로시저를 객체(Object)라는 단위로 묶는 것으로 시작한다.  객체는 자신만의 기능을 제공하며, 각 객체들은 서로 연결되어 다른 객체가 제공하는 ‘프로시저’를 사용할 수 있다. 이때 한 객체의 프로시저는 자신이 속한 객체의 데이터만 접근 가능하다.  초기 설계가 까다롭다 데이터가 변경되더라도 해당 객체 내부에서만 변화가 집중되고 다른 객체에는 영향을 주지 않는다. (캡슐화)3. 객체: ‘객체’를 정의할때 사용하는 용어에 대해 알아보자. 객체의 사용은 데이터가 아닌 ‘기능’에 집중된 구현을 가능하게 해준다. 따라서 객체는 객체가 제공하는 기능(책임)으로 정의된다. 이때 객체가 제공하는 기능을 오퍼레이션(Operation)이라 한다. 또한 이런 오퍼레이션을 사용하기 위해서는 오퍼레이션의 사용 방법을 알아야만 한다. 이를 ‘시그니처(Signature)’라 하며, 시그니처는 ‘식별 이름, 파라미터 및 파라미터 타입, 리턴 값’의 3가지로 구성된다. 객체가 제공하는 오퍼레이션의 집합을 ‘인터페이스(Interface)’라 한다. (이때 인터페이스는 Java에서 제공하는 Interface와는 다른 개념이다. ) 인터페이스를 구분할 때는 타입(type)이라는 명칭으로 구분한다. 인터페이스는 기능에 대한 명세서 역할을 하며 한 객체가 지닌 책임을 정의한다. 마지막으로 클래스(class)는 실제 객체가 기능을 어떻게 구현하는지에 대한 정보이다. 이때 class는 Java에서 사용하는 Class와 유사하다. ‘소리 크기 제어 객체’ 예시를 통해 위 용어를 알아보자. 이편이 이해가 빠를 것이다. ‘소리 크기 제어 객체’는 ‘소리 증가’, ‘소리 감소’, ‘음소거’의 3가지 기능을 지니고 있다.  객체의 책임: 상황에 따라 객체의 책임 구성은 달라질 수 있다. 그러나 확실한 규칙이 있다면 그것은 ‘객체의 책임, 즉 객체가 제공하는 기능은 작을수록 좋다’이다.  위 이미지는 동일한 기능을 절차지향적으로 구현한 것과(좌), 모든 기능을 한 객체에 모두 밀어넣은 것이다(우). 사실상 두 구현에는 큰 차이가 없다. 객체지향적인 구현을 위해 객체를 사용했음에도 절차지향적인 구조를 지니게 되는 것이다. 이는 절차지향의 가장 큰 문제인 기능 변경의 어려움이 나타날 수 있음을 의미한다.  자, 여기서 옛날 이야기를 하나 해보겠다. 내가 ‘두레’ 프로젝트를 진행하며 생긴 일이다… 위 이미지는 내가 진행하고 있는 두레의 코드 일부이다. 위 이미지를 잘 보면 validateExistMember 코드가 회원 검증이 필요한 모든 도메인의 Service코드에 private으로 작성되어있음을 확인 할 수 있다. 당연히 위와 같이 작성해도 코드는 정상적으로 돌아간다. 그러나 문제는 다음부터 발생한다. 두레에는 validateExistMember을 통한 회원 검증뿐만이 아니라, 기타 다른 검증요소 또한 private으로 작성되어 있었다. 예를 들어 팀에서 팀원의 Role을 가져오고, 만일 Role이 없다면 팀원이 아닌 것으로 판단하는 팀원 검증 코드와 같은… 123456789private Map&lt;Member, TeamRoleType&gt; getRoleOfMember(final Long teamId, final List&lt;Member&gt; members) {	return members. stream()					. collect(Collectors. toMap(		     member -&gt; member,	      member -&gt; teamRoleRepository. findTeamRoleByTeamIdAndMemberId(teamId, member. getId())	       . orElseThrow(() -&gt; new MemberException(NOT_FOUND_MEMBER))        . getTeamRoleType()      ));}그러나 여기서 문제가 발생한다. 검증코드를 작성하던 개발자가 실수로 teamRoleRepository. findTeamRoleByTeamIdAndMemberId(teamId, member. getId())로 작성해야 할 코드를 teamRoleRepository. findTeamRoleByTeamId(teamId);로 작성해버렸다. 거기에 다른 팀원들 또한 이를 확인하지 못하고 approve하여 코드가 그대로 메인 브랜치에 머지되어 버렸다! 실수를 알아차린 것은 그로부터 한참 뒤였다. 그러면 이제 무엇을 해야하는가? 사실 위 문제를 해결하는 건 어렵지 않다. 팀원 검증 로직의findTeamRoleByTeamId을 findTeamRoleByTeamIdAndMemberId로 수정해주면 되는 일이기 때문이다. 그러나 private으로 선언된 팀원 검증 코드는 두레의 모든 도메인에 뿌려져있었고…. 이를 모두 찾아 하나 하나 수정하고 문제 없이 수정되었는지 확인 하기 위해서는 꽤 많은 시간이 필요했다.  위 문제의 원인은 책임 분리가 적절하게 이루어지지 않았기 때문이다. 두레에서는 ‘팀 관리’, ‘스터디 관리’, ‘회원 관리’와 같은 기능들에 ‘검증’의 책임이 적절하게 분리되지 않았다. 만일 개발자들이 ‘검증’의 책임을 검증 Service로 분리하고, ‘팀 관리’, ‘스터디 관리’, ‘회원 관리’와 같은 기능은 검증 Service에서 해당 기능을 가져와 사용하는 식으로 개발하였으면 검증 Service의 코드 단 한줄만을 수정하는 것으로 모든 문제가 해결되었을 것이다. 이렇게 객체의 책임과 관련된 원칙으로 단일 책임 원칙 (Single Responsibility Principle: SRP)이 존재한다. 이는 한 객체는 단 한개의 책임만을 지녀야 한다는 원칙이다. 객체의 의존: 객체의 의존은 필연적으로 발생한다. (위 이미지를 예시로 들면, 한곳에 몰아넣어져 서로 교류하던 기능들을 서로 다른 객체로 분리한 것이니 의존이 존재하지 않을 수가 없다. ) 위의 예시를 그대로 가져오자면, 흐름 제어 객체는 파일읽기 객체, 파일 쓰기 객체, 암호화 객체에 대한 의존성을 지닌다.  💡   의존(Dependency)  한 객체가 다른 객체를 생성하거나, 파라미터로 전달받거나, 다른 객체의 메서드를 호출하는 것.   한 객체의 변경사항이 다른 객체의 변경을 줄 가능성이 높아지는 것.  의존은 전이된다. 위 이미지는 Controller가 ServiceA에 의존하고, ServiceA는 ServiceB에 의존하고 있는 상황을 나타낸다. 이때 ServiceB의 변경은 ServiceA의 변경을 야기시킬 가능성이 크다. 또한 ServiceA의 변경은 Controller의 변경을 야기시킬수 있다. 이를 의존의 전이라고 한다. 이런 의존의 특징에 의해 나타날수 있는 문제가 바로 순환 의존이다.  자기 자신의 변경이 다시 자시 자신의 변경을 유발할 수 있다는 것이다. Springboot에서의 순환 참조 문제: Spring을 사용하여 개발을 하다보면 Service에서 다른 Service의 메서드를 필요로 하여, Service간 의존을 하게되는 상황을 자주 마주하게 될 것이다. 이때도 순환참조의 문제가 발생할 수 있다. 123456@Service@RequiredArgsConstructorpublic class UserService {  private final OrderService orderService;    . . . }1234567891011@Service@RequiredArgsConstructorpublic class OrderService {	private final UserService userService;	  public List&lt;Order&gt; findAllByUserServiceId(Long id) {    User user = userService. findById(id);    return orderRepository. findAllByUser(user);  }  . . . }예시로 위와 같은 코드가 있다. 위와 같은 구조는 BeanCurrentlyInCreationException에러를 발생시킨다. 빈을 초기화 시킬 때 UserService의 빈을 생성하기 위해서는 OrderService의 빈이, OrderService의 빈을 생성하기 위해서는 UserService의 빈이 필요한데 두 빈 중 그 어느 것도 생성될 수 먼저 생성될 수 없기에 발생하는 문제이다. 그러나 경험상 순환참조를 의식하지 않고 설계를 해도 순환참조가 발생하는 일은 없었다. 설계만 잘 돼있다면 순환참조에 대해 걱정할 필요는 없을 듯…이런 순환 의존이 발생하지 않도로 하는 원칙 중 하나가 의존 역전 원칙(DIP: Dependency inversion principle)이다. 4. 캡슐화:  💡   캡슐화  객체의 기능 구현을 감춰 내부 기능 구현이 변경되더라도 해당 기능을 사용하는 코드에 대한 영향을 줄이는 것.  123if (member. isMale() &amp;&amp; member. getExpriyDate(). getDate() &lt; currentDate) {	//만료 되었을 때의 처리}123if (member. isExpried()) {	//만료 되었을 때의 처리}캡슐화의 가장 쉬운 예시로는 위와 같은 예시가 있다. 구체적인 로직을 isExpried()로 캡슐화 시킴으로써 우리는 그 내부 코드를 알 필요가 없게되었다. 객체의 책임에 대해 설명했을 때 예시로 든 검증 코드또한 캡슐화의 예시가 될 수 있겠다. 캡슐화 되지 않은 코드는 변경이 필요해질 때, 해당 코드가 사용되는 곳을 모두 찾아 수정해주어야 하며, 해당 코드를 사용하는 곳이 많을수록 수정에서 실수가 발생할 가능성이 높아진다. 아니, 해당 코드들이 사용되는 곳을 찾는 것부터가 문제이다. 이는 코드가 데이터 중심으로 짜여졌기 때문이다. 데이터를 직접적으로 사용하기에 데이터의 변화에 영향을 받는 코드들이 연쇄적으로 발생하는 것이다. 그러나 캡슐화를 사용하면 캡슐화된 코드를 수정하는 것만으로 기능 수정이 가능하며, 반환값이 수정되지 않는 이상 연쇄적으로 영향을 받는 코드 또한 발생하지 않는다. 아래는 캡슐화를 돕기위한 두가지 법칙이다. Tell, Don’t Ask: Tell, Don’t Ask 규칙이란 데이터를 물어보지 않고 기능의 실행만을 요청하는 것이다. 123if(member. getExpiryDate(). getDate() &lt; currentDate {	//만료 되었을 때의 처리}123if(member. isExpired()) {	//만료 되었을 때의 처리}데미테르의 법칙: 데미테르의 법칙은 Tell, Don’t Ask규칙을 지킬수 있도록 도와주는 규칙이다. 데미테르의 법칙은 아래 세가지 규칙으로 이루어진다.  메서드에서 생성한 객체의 메서드만 호출한다.  파라미터로 받은 객체의 메서드만 호출한다.  필드로 참조하는 객체의 메서드만 호출한다. 이를테면 아래와 같은 예시가 있다. 1234Wallet wallet = custuomer. getWallet();if (wallet. getTotalMoney() &gt;= payment) {	wallet. substractMoney(payment);}위 코드는 Custuomer 객체의 getWallet() 메서드를 통해 생성한 Wallet 객체에서 또다시 getTotalMoney() 메서드를 호출한다. 데미테르의 법칙을 따르기 위해선 Custuomer 객체에 대한 단 한번의 호출만으로 TotalMoney을 받아올 수 있어야 한다. 1int paidAmount = customer. getPayment(payment);5. 객체지향 설계과정: 위에서 살펴본 내용을 종합적으로 정리하자면 객체지향적인 설계를 위해선 다음과 같은 과정을 필요로 한다.  필요한 기능을 찾고 세분화한다.  세분화 한 기능을 알맞은 객체에 할당한다.      기능구현에 필요한 데이터를 객체에 할당한다.    기능은 최대한 캡슐화해서 구현한다.     객체간 메세지를 주고받는 방법을 결정한다.  위를 계속 반복한다. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/submodule/",
    "title": "민감정보 처리 방법과 서브모듈 수정 방법",
    "body": "2024/07/13 - 0. 개요: 프로젝트를 진행하며 서브모듈의 정보를 수정할 일이 꽤 자주 발생했다. 당시에는 서브모듈 수정 방법이 익숙하지 않았기 때문에 서브모듈을 수정하려다 커밋이 꼬여버리고 말았고, 인터넷 서치를 통해 꼬여버린 서브모듈 커밋을 해결하는 방법을 찾아봤지만 그와 관련된 게시글은 찾지 못했다. 결국 스스로의 지능을 사용해 해결했기 때문에 또 다시 헤매는 일이 없도록 기록해두려 한다. 1. 서브모듈 사용 이유: 외부에 공개해선 안되는 민감 정보들을 처리하는 방법은 여러가지가 있다. 프로젝트 초기, 이런 민감 정보들을 처리하기 위한 제시된 방안들은 아래와 같다.  dev. yml 파일을 gitignore 처리한 후 변경사항이 생길 때마다 덮어쓰기한다.  Github Secret에 민감 정보 데이터를 저장한다.  dev. yml 파일을 jasypt을 사용해 암호화 한 후 public하게 공개한다.  서브모듈로 관리한다. 결과적으로는 4번 서브모듈을 사용하는 것으로 결론이 났다. 나머지 방안이 반려된 이유는 아래와 같다.   1 민감 정보를 gitignore 처리한다. 이전 프로젝트에서 사용한 적이 있는 방식었다. 경험상 yml 파일을 git으로 관리하지 않기 때문에 변경이 발생하는 경우 따로 모든 팀원에게 공유해야했고, 이런식으로 파일이 동기화 되지 않아 에러가 발생하는 일이 빈번했다. 번거로운 방식이라 생각했기에 채택되지 못했다.   2 Github Secret에 민감 정보 데이터를 저장한다. Secret으로 관리하는 경우 한번 저장한 데이터를 다시 확인하지 못하기 때문에 어차피 다른 곳에 따로 백업해두어야 한다. 1번 방법과 다르게 변경 사항이 발생해도 오류가 나진 않지만 팀원들이 백업한 yml 정보를 수정하려면 또 따로 보내줘야 한다는 점이 1번과 다를 바 없었다. (단, cicd 스크립트 같은 경우 Secret에 저장된 데이터를 사용하고 있다. 어차피 관리하는 인원이 나 혼자라서…)  3 jasypt을 사용한 암호화 이 방식은 다른 프로젝트인 ‘세차새차’에서 사용하고 있는 방식이다. key값을 알고있지 않으면 decode할 수 없으니 private로 관리할 필요가 없다는 장점이 있다. 그러나 yml 파일에서 문제가 발생할 경우 원본 값을 알아보기 위해서는 디코딩하는 과정을 거쳐야 한다는 번거로움이 있었다. 또한 yml 파일을 바로 이해할 수 없다는 점도 답답했다.  이러한 이유 때문에 민감정보 처리 방식으로 서브모듈이 채택되었다. 다른 방식과 다르게 서브모듈은 yml파일이 수정될때마다 따로 공유해줄 필요가 없고, 외부에 공개되지 않으며, 암호화 되지 않아 개발자가 바로 보고 이해할 수 있다는 장점이 있다. 다만 정보를 업데이트 하는 방법이 다소 번거롭다는 단점이 있는데, 이 부분은 그 방법만 제대로 숙지하면 그닥 어려운 내용이 아니다. 아래로는 서브모듈의 정보를 수정하는 방법과 커밋이 꼬였을 때의 해결 방법을 작성할 예정이다. 서브모듈 연결 방법은 인터넷에 널렸으니 따로 찾아보자… 2. 서브모듈 정보 업데이트: 처음부터 완벽하게 서브모듈을 작성하면 좋겠지만! 프로젝트를 진행하며 민감정보를 수정할 상황은 무조건 생긴다. redis나 rabbitMq와 같은 기술을 새로 도입할 수도 있으며, 설정 등에 문제가 생겨 기존값을 수정해야할 상황이 발생하게된다. doore 같은 경우는 cors 설정, oauth 설정 등의 변경 등을 위해 서브모듈을 수정해야 하는 경우가 많았다. (구글 소셜 로그인 오류 해결 참고…^^;) 서브모듈 레포 수정: 위는 doore의 개발서버에서 사용하는 서브모듈 yml 파일이다. 구글 소셜 로그인 오류 해결을 진행하며 서브모듈의 redirect-uri을 올바른 uri로 수정해야 하는 상황이 생겼다. 가장 추천하는 방법은 서브모듈 레파지토리에서 직접 수정하는 방식이다. 왜냐면 로컬에서 직접 서브모듈을 수정하게 되면, 수정 후 푸시하는 과정에서 서브모듈의 커밋 연결이 잘못되는 경우가 많았기 때문에… (물론 이것도 제대로 연결하면 되는 일이지만, 레포에서 직접 수정하고 동기화 하는 편이 훨씬 쉽고 편하다. ) 혹시나 이런 문제가 발생한 경우에는 3. 서브모듈 연결 수정을 참고하자.  위와 같이 레포에서의 직접 수정이 불가능하다는 메세지가 뜰 수가 있는데, 이 경우 현재 브랜치가 main 브랜치가 아닌 특정 commit hash 에 위치해있는 경우일 수 있다. main 브랜치로 이동 후 수정해주자.  서브모듈 레포에서 수정 후 커밋했다. 00c0의 새로운 커밋이 생성된 것을 확인할 수 있다. 서브모듈 최신 커밋 반영: 그러나 수퍼레포에 연결된 commit hash은 여전히 과거 커밋인 1436을 향하고 있다. 수퍼레포에서도 서브모듈 레포의 변경사항을 반영해주기 위해서 최신 commit hash로 연결해야 한다.  여전히 과거의 커밋인 1436을 향하고 있음을 확인할 수 있다.  git submodule update --remote 명령을 통해 최신 서브모듈로 업데이트가 가능하다. 메세지를 확인해보면 00c0 커밋의 변경사항을 가져온 것을 확인할 수 있다.  전에 없던 변경사항이 발생함을 확인할 수 있다. 이제 평범하게 add,commit,push 해주자.  서브모듈로 연결된 commit hash가 수정되었다. 3. 서브 모듈 켜밋이 꼬여버린 경우: 그러나 git submodule update --remote으로도 최신 서브모듈의 커밋을 가져오지 못하는 경우가 발생할 수 있다. 예를 들어 위에서 언급했듯 레포가 아닌 코드상에서 서브모듈을 수정했다가 서브모듈과 수퍼모듈의 커밋이 꼬여버린 경우라던가… 그게 아니라도 커밋이 꼬이면 서브모듈 업데이트로는 해결이 어렵다. 이때는 직접 서브모듈의 commit hash를 바꿔주는 걸로 해결할 수 있다.  서브모듈 폴더로 이동: doore의 경우 서브모듈은 resources/config폴더로 연결되어 있다. 서브모듈이 연결돼있는 폴더로 이동하자. 브랜치 확인: git branch를 통해 현재 브랜치가 무엇인지 확인하자.  한참 과거의 커밋에 연결되어 커밋이 꼬여버린 것을 확인할 수 있었다. 가장 최신 커밋은 0fa4이다. 브랜치 변경: git checkout &lt;branch명&gt;을 통해 최신 커밋으로 이동하자. 이것으로 꼬여버린 커밋이 해결되었다. 이후 다시 기존 폴더로 이동한 후 add. commit, push하면 서브모듈의 변경사항이 반영된다. "
    }, {
    "id": 22,
    "url": "http://localhost:4000/google-login/",
    "title": "구글 소셜 로그인 에러 해결(Cors, Redirect uri)",
    "body": "2024/07/11 - 0. 개요: 두레의 소셜 로그인에서 CORS 에러가 발생한다는 프론트의 보고가 들어왔다.  구글 소셜 로그인은 현재 팀을 나간 팀원이 몇 달 전에 작업한 내용이었다. 해당 기능이 개발되던 당시에는 클라이언트 UI 작업이 되지 않아 제대로된 테스트가 이루어지지 못했고, 직접 클라이언트를 통해 로그인을 시도하자 오류가 발생한 것이다. (인터넷 URL 창에 직접 uri를 입력하여 정상 작동하는지 테스트했다 들음) 백엔드는 이미 권한 처리가 완료돼있었기에 로그인을 하지 못하면 프론트에서 작업하기가 어려운 상황이었다. 해당 포스팅에는 구글 소셜 로그인에서 발생한 Cors, redirection url의 두가지 문제를 해결한 내용을 기록해두었다. (그 사이의 많은 삽질은 생략했다…) 1. Cors 오류: 가짜 Cors 해결(false cors) (Cors 오류에 대한 설명은 위 포스팅을 참고하자. ) application. yml 수정: 1234cors: allow:  origins: http://localhost:3000  methods: GET, POST, PUT, DELETE, PATCH, OPTION12345678910111213141516171819@Configurationpublic class CorsConfig implements WebMvcConfigurer {  @Value(value =  ${cors. allow. origins} )  private String[] allowedOrigins;  @Value(value =  ${cors. allow. methods} )  private String[] allowedMethods;  @Override  public void addCorsMappings(CorsRegistry registry) {    registry. addMapping( /** )        . allowedOrigins(allowedOrigins)        . allowedMethods(allowedMethods)        . allowedHeaders( Origin ,  Content-Type ,  Accept ,  Authorization )        . allowCredentials(true)        . maxAge(3600);  }}최우선적으로 Cors 설정 관련 문제를 들여다보자. allowedOrigins에 프론트 로컬 경로만 설정돼있고 실제 개발 서버가 연결돼있지 않은 것을 확인할 수 있었다.  1234cors: allow:  origins: http://localhost:3000, https://www. doore. kro. kr  methods: GET, POST, PUT, DELETE, PATCH, OPTION개발서버를 추가해주자. 서브모듈 수정: 그러나 application. yml의 allowOrigin을 수정해도 여전히 동일한 에러가 발생했다. 이쯤해서 Doore의 민감정보 처리 방법에 대해 간단하게 알아보자… Submodules: 간과했던 사항은 로컬과 개발서버, 운영서버는 서로 다른 설정 파일을 읽는다는 점이다.  환경이 나누어져 있는 이상 데이터베이스(또는 스키마)와 같이 각 환경별로 다르게 사용해야 할 설정이 있기 마련이며, 개발 서버와 운영서버에는 api-key또는 데이터베이스 비밀번호와 같이 외부인에게는 공개해선 안되는 민감 정보가 존재한다. 당연하게도 이러한 설정을 통일하기 보다는 각 환경별로 분리하는 쪽이 운영에 훨씬 도움이 된다. 따라서 두레에서는 환경에 따른 각 설정 정보를 다음과 같이 분리했다.  application. yml → 로컬 설정 application-dev. yml → 개발 환경 설정 application-prod. yml → 운영 환경 설정(설정파일 네이밍에 관해서는 아래 Profile 파트에서 설명하겠다. ) 현재 두레 레포지토리는 public 상태로, application. yml은 외부에 공개돼있다. 그러나 개발 환경 설정과 운영 환경 설정은 민감한 정보를 담은 파일로 Private하게 관리해야 한다. 따라서 Doore에서는 Submodule을 사용하여 민감 정보를 private 레파지토리에 보관하고 있다. Spring Profile: 그렇다면 어떻게 운영 환경에서는 application-prod. yml의 설정을 가져다 사용하고, 개발 환경에서는 application-dev. yml의 설정을 가져다 쓸 수 있도록 할 수 있단 말인가? 이것은 Profile에 달려있다.  💡 	Profile  특정 환경에 맞게 애플리케이션 설정을 다르게 적용할 수 있도록 해주는 기능  https://docs. spring. io/spring-boot/docs/1. 2. 0. M1/reference/html/boot-features-profiles. html#boot-features-profiles 스프링 부트에서는 spring. profiles. active 설정을 통해 활성화 할 프로파일을 설정할 수 있다. 이 설정은 하나의 yml 파일에서 로컬,개발,운영 환경별 설정을 나눌 때 사용할 수도 있고, 어플리케이션 실행시 Java 시스템 프로퍼티를 통해 설정할 수도 있다.  두레에서는 Docker를 사용하여 애플리케이션을 실행하고 있다. DockerFile을 확인해보면 어플리케이션 실행시 -Dspring. profiles. active 시스템 프로퍼티를 사용하여 프로파일을 dev로 설정하고 있음을 확인할 수 있다.  https://docs. spring. io/spring-boot/docs/1. 2. 0. M1/reference/html/boot-features-external-config. html#boot-features-external-config-profile-specific-properties SpringBoot 설정파일 네이밍 규칙에 의하여 어떤 프로파일의 설정 파일의 이름은 application-{profile}. properties가 된다. 따라서 profile이 dev로 설정된 개발서버에서 사용하는 설정파일은 application-dev. yml이 될 것이다. 해결: 확인해보니 서브모듈의 Allow origin은 여전히 로컬서버를 향하고 있는 상태였다. 따라서 배포 서버 주소를 추가해주는 것으로 Cors 에러를 해결할 수 있었다. 서브모듈 수정 방법 2. redirect_uri_mismatch 오류: Cors 에러를 수정하자 이번엔 500에러가 발생했다… 검출되지 못한 500에러가 지금 나를 덮친다……  EC2에 접속해 서버 로그를 확인해보자. redirect_uri_mismatch 오류가 뜨는 걸 확인할 수 있었다. 코드를 살펴보며 두레 구글 소셜 로그인 코드에서 redirect_uri를 어디에 사용하고 있는지 확인했다.   클라이언트에서 구글로 승인(인가코드 발급) 요청을 보낼 때     사용하고 있는 rediect_uri: https:/www. doore. kro. kr/oauth2/code/google    백엔드에서 구글로 토큰 요청을 보낼 때     사용하고 있는 redirect_uri: https://www. doore. kro. kr   위의 두 군데에서 redirect-uri가 사용되고 있음을 확인했다.  https://developers. google. com/identity/protocols/oauth2/web-server?hl=ko#httprest_1 구글 oauth2 문서에서 설명하길, credentials page의 승인된 리디렉션 URI와 일치하지 않은 redirection uri가 사용된 경우 redirect_uri_mismatch 오류가 발생할 수 있다고 한다. Redirect uri: credentials page의 승인된 리디렉션 URI를 확인해보았다.  이미 여러가지 리디렉션 URI가 등록되어 있었다. 그러나 https:/www. doore. kro. kr/oauth2/code/google를 제외한 https://www. doore. kro. kr는 등록되어있지 않았음을 확인하고 새로 등록해주었다. (이후에 안쓰는 리디렉션 URI들은 정리하는 걸로…) google credentials page에 새로 등록된 리디렉션 URI는 실제로 적용되기까지 5분에서 n시간이 소요된다. 당연하게도 실제 적용됐다고 알림도 안온다. 그냥 해봤는데 안되면 아직 적용이 안됐거니 하고 기다려야하는 잔인한 시스템… (여기서 굉장히 많은 시간을 낭비했다) 아무튼 결과적으로 리디렉션 URI에 값을 추가하는 걸로는 문제가 해결되지 않았다. 해결: 구글 개발 문서 상에는 등록되지 않는 리디렉션 URI를 사용하여 발생하는 문제라 되어있긴 하나, 이쯤되니 리디렉션 URI 등록 문제가 아니어보였다. 다행히도(다행이라기엔 너무 많은 삽질을 거쳤지만) 이전에 개인 공부로 카카오 소셜 로그인을 구현해본적이 있다. 구글 소셜 로그인을 개발하신 팀원분은 URL창에 get 요청을 전송하는 식으로 테스트를 하셨지만 나는 클라이언트로 직접 소셜 로그인이 성공하는 것까지 확인했기 때문에 두레의 구글 소셜 로그인 코드와 내가 작성한 카카오 소셜 로그인 코드를 비교해가며 문제를 찾는 것이 좋겠다 판단했다. (플랫폼이 다르긴 해도 소셜 로그인 원리는 거의 다르지 않을 것이기 때문에) https://lcqff. github. io/dotted/2024/05/01/kakao-login. html 내가 카카오 소셜 로그인을 구현하며 작성한 글을 다시 읽어보며 발견한 사실이 있다. 인가 코드 요청과 토큰 발급시 동일한 redirection_uri를 사용한다는 점이다.  위에서 설명했듯이 현재 두레의 구글 소셜 로그인에서 사용하는 redirect_uri는 두가지이다.  클라이언트에서 구글로 승인(인가코드 발급) 요청을 보낼 때     사용하고 있는 rediect_uri: https:/www. doore. kro. kr/oauth2/code/google    백엔드에서 구글로 토큰 요청을 보낼 때     사용하고 있는 redirect_uri: https://www. doore. kro. kr   백엔드에서 사용하고 있는 redirection uri를 프론트에서 사용하고 있는 redirectoin uri와 동일한 것으로 수정해주자…….  ㅠㅠ 최종 포스팅에서는 결과만 요약해서 설명했지만 이 사이에 너무 의미없는 뻘짓이라 포스팅에 차마 담지 못한 삽질이 많다…. (현재 분량의 3배정도 된다) 그만큼 해결이 늦어져서 프론트분들에게 죄송할 따름이다ㅠㅠ  배운 점:    소셜 로그인은 프론트 개발 후에 작업하자 직접 클라이언트로 테스트해보자  그래도 덕분이 이거 해결하면서 이후에 인프라 하며 경험할 삽질은 다 겪은거같다… +서브모듈과 프로파일에 대한 지식을 얻어 좋았다….   지금은 소셜 로그인 코드가 그냥 쌩으로 작성되어있는데 Oauth2 라이브러리를 사용하는 것으로 리팩터링하자… "
    }, {
    "id": 23,
    "url": "http://localhost:4000/rabbitmq2/",
    "title": "세차새차 비즈콜 서비스 개발 (2) -RabbitMQ TTL, DLX, Retry 적용",
    "body": "2024/06/22 - 0. 개요: 과거 메세지를 함께 Consume해오는 오류: 지난번 RabbitMQ PR을 올린 후 위와 같은 문제가 제의되었다. 위 문제 자체야 간단한 설정 문제였다. 그러나 이 문제가 아니라도 Queue에 메세지가 쌓이는 것과 관련하여 문제가 생길 수 있는 부분이 몇가지 보였다. 따라서 RabbitMQ에 TTL, DLX, retry 설정을 추가 하기로 했다. 1. acknowledge-mode 설정: 우선적으로 개요에서 설명한 문제를 해결하자.  위 문제는 acknowledge-mode 의 설정과 관련된 문제였다.  listener. simple. acknowledge-mode    none : 기본값. 들어오는 모든 메세지에 대해 ack를 전송한다.   auto : 리스너가 정상값을 반환하면 ack를 전송하고, 그렇지 않으면 nack를 전송한다.   manual : 리스너의 반환값 여부와 관계없이 직접 ack, nack, reject를 전송한다.  위 이슈에서는 acknowledge-mode 가 manual로 설정되어있었고, ack나 nack를 전송하는 코드가 따로 작성되어있지 않았기 때문에 모든 메세지가 큐에 ready 상태로 남아있었다. 그래서 이전에 전송되었던 메세지가 사라지지 않고 함께 전송된 것이다.  가능한 queue 메세지 Statue는 이래 두가지이다.  Ready for delivery (Ready 상태) Delivered but not yet acknowledged by consumer (전송은 됐으나 아직 Consumer의 Ark를 받지 못함) 정리하자면  아직 consume되지 못한 메세지: Ready 상태로 큐에 존재한다.   consume되고 Ack를 받은 메세지: 큐에서 제거된다.   consume되고 Ack를 받지 못한 메세지: unack 상태로 큐에 존재한다.   consume되고 Nack(negative-ack)를 받은 메세지: 옵션에 따라 큐에서 제거되거나 다시 requeue된다.  위 문제는 acknowledge-mode 를 none으로 바꾸는 것으로 해결했다. 2. TTL 설정: Time-To-Live and Expiration  📝   💡 TTL(Time-To-Live)  메시지를 큐에 보관할 수 있는 기간 TTL 설정을 추가하기로 했다. TTL이 설정된 메세지는 큐에 Ready 상태로 TTL 시간 이상 머물게 되면 자동으로 삭제된다. TTL은 메세지에 TTL을 설정하는 Per-Message TTL과 큐에 TTL을 설정하는 Per-Queue TTL이 존재하는데 나는 Per-Message TTL을 사용했다. 큐에 TTL을 설정하는 것보다 메세지에 TTL을 설정하는게 더 직관적이고, 유연하게 사용 가능할 것이라 생각했기 때문이다.  현재 작성된 코드는 @RabbitListener를 통해 listen하고 있는 큐에 메세지가 들어오는 경우 바로 Consume하도록 작성되 있어 사실 서버가 정상적으로 돌아가는 경우 큐에 메세지가 Ready 상태로 남아있는 경우가 없을 거라 생각된다. 그럼에도 TTL을 설정하는 이유는 다음과 같은 상황을 가정한다:  특정 인스턴스가 죽어도, RabbitMQ는 살아있기 때문에 RabbitMQ는 계속 Queue로 메세지를 전달하게 된다. 만일 어떤 Queue에 메세지가 1000개 쌓여있는 상태에서 인스턴스가 되살아 난다면 큐에 쌓여있는 메세지들이 한번에 Consume되며 문제가 발생할 수 있다.  현재는 consumer와 rabbitMQ가 묶여있지만, 이후 서비스를 확장하여 컨슈머와 rabbitmq가 분리됐을 때 TTL이 필요해지게 되기에 미리 적용하는 것이다. 실제 적용: 1234567891011121314151617181920//기존 코드	public void sendMessage(CdrMessageDto messageDto) {		try {			**rabbitTemplate. convertAndSend(exchangeName,   , messageDto);**		} catch (Exception exception) {			throw new ApplicationException(ApplicationError. RABBITMQ_CONNECTION_ERROR);		}	} // 변경된 TTL 설정 코드	public void sendMessage(CdrMessageDto messageDto) {		try {			**rabbitTemplate. convertAndSend(exchangeName,   , messageDto, message -&gt; {				message. getMessageProperties(). setExpiration(ttl); //환경변수로 30초 설정				return message; 			});**		} catch (Exception exception) {			throw new ApplicationException(ApplicationError. RABBITMQ_CONNECTION_ERROR);		}	} (테스트를 위해 @RabbitListener 연결을 끊어 메세지가 큐에 Ready 상태로 남아있게 했다. ) 실제로 expiration을 30초로 설정한 메세지가 Ready 상태로 queue에 30초 이상 머물자 expired 되어 사라진 것을 확인할 수 있었다. 3. DLX 설정: TTL을 사용해 일정 시간 Ack 되지 않고 큐에서 머문 메세지는 큐에서 삭제되도록 하였다. 그러나 이렇게 메세지를 삭제해버리는 것이 마음에 걸렸다. 뭔가… 보관을 해야 안심이 될거같은 느낌이…… 따라서 DLX(Dead Letter Exchager)와 DLQ(Dead Letter Queue)를 생성하기로 했다. Dead Lettering: 대기열의 메시지는 데드 레터링될 수 있다. 즉, 다음 네 가지 이벤트 중 하나가 발생할 때 메시지가 exchange에 republished 된다.    requeue 매개변수가 false로 설정된 basic. reject 또는 basic. nack를 사용하여 소비자가 메시지를 negatively acknowledged 했다.   Per-message TTL로 인해 메시지가 만료됐다.   큐의 크기 제한을 초과하여 메시지가 삭제됐다.   메시지가 delivery-limit보다 더 많이 쿼럼 대기열로 반환됐다.  위 4가지 경우에 속하는 메세지들은 DLX에 publish되어 DLQ에 저장되게 된다. 실제 적용: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@RequiredArgsConstructor@Configurationpublic class RabbitMqConfiguration {	@Value( ${rabbitmq. queue. name} )	private String queueName;	@Value( ${rabbitmq. queue. dead} )	private String deadLetterQueue;	@Value( ${rabbitmq. exchange. name} )	private String exchangeName;	@Value( ${rabbitmq. exchange. dead} )	private String deadLetterExchange;	@Bean	public Queue queue() {		return new Queue(queueName) ; // 큐에 DLX를 연결해준다. 	}	@Bean	public Queue deadLetterQueue() {		return new Queue(deadLetterQueue);	} //DLQ	@Bean	public FanoutExchange fanoutExchange() {		return new FanoutExchange(exchangeName);	}	@Bean	public FanoutExchange deadLetterExchange() {		return new FanoutExchange(deadLetterExchange);	} //DLX	@Bean	public Binding binding(Queue queue, FanoutExchange fanoutExchange) {		return BindingBuilder. bind(queue). to(fanoutExchange);	}	@Bean	public Binding deadLetterbinding(Queue deadLetterQueue, FanoutExchange deadLetterExchange) {		return BindingBuilder. bind(deadLetterQueue). to(deadLetterExchange);	}	@Bean	public MessageConverter jackson2JsonMessageConverter() {		return new Jackson2JsonMessageConverter();	}}Expired로 인한 DLQ 이동: TTL이 30초로 설정된 메세지이다. TTL이 끝날동안 Consume되지 않자 expired됐다.  dead queue를 확인하자 expired된 메세지들이 모두 저장된 것을 확인할 수 있었다.  get message를 통해 dead queue에 쌓인 메세지를 꺼내 확인해보았다.  expiration이 30초로 설정된 메세지가 expired 되어 dead queue로 들어왔음을 확인할 수 있었다. rejected로 인한 DLQ 이동: 이번엔 consume 되었으나 Error가 발생하여 dead queue로 옮겨진 경우를 테스트 해보았다. 사진에서는 큐에 아무 메세지도 쌓이지 않았던 것처럼 보이는데 queue에 머문 시간이 너무 짧아서 보이지 않는 것 같다. 이번에도 동일하게 dead queue에서 get message를 통해 메세지를 확인해보면 rejected된 메세지란 걸 확인할 수 있다. 4. Retry 설정: 마음에 또 걸리는 부분이 생겼다. 거의 대부분의 상황에서 consumer는 전달받은 메세지를 정상적으로 처리될 것이다. 그러니 첫번째 시도만에 오류가 발생한다고 바로 메세지를 DLX로 보내기 보다는 최소 2~3번 정도는 재시도하길 원했다. 해당 설정은 간단하다. retry 설정을 true로 처리하면 된다. 1234567rabbitmq:	listener:		simple:		 retry:			 enabled: true			 initial-interval: 2s			 max-attempts: 2retry: 소비자가 메시지를 처리하는 도중 예외가 발생했을 때 메시지를 자동으로 재시도한다.  initial-interval: retry 사이에 주어지는 텀 max-attempts: 최대 재시도 횟수 (기본값 3) 위 설정을 적용하고 일부러 예외를 터뜨렸을 때, 동일한 예외가 2번 터지는 것으로 2번씩 재시도되고 있음을 확인할 수 있었다.   위와 같이 작업하긴 했으나 결과적으로 DLX, DLQ는 사용하지 않기로 했다. 비즈콜 메세지는 영원히 없어지든 말든 별로 상관없는 (안중요한) 메세지기 때문에…  그래도 이번 기회에 DLX를 작업하고 공부할 수 있어서 괜히 작업했다는 생각은 안한다 ^-^ rabbitMQ 공부할때 DLX를 안하면 아쉬웠을 거 같다. "
    }, {
    "id": 24,
    "url": "http://localhost:4000/Ip%EB%8C%80%EC%97%AD%EC%A0%9C%ED%95%9C/",
    "title": "특정 API의 IP 대역 제한(AOP, 커스텀 어노테이션, XFF)",
    "body": "2024/06/15 -  0. 개요: 저번 RabbitMQ 게시글의 비즈콜 기능과 관련된 이슈이다. 손님이 비즈콜을 통해 매장에 전화를 하면 비즈콜은 서버에 CDR 정보를 전달해주며 CDR API를 실행시킨다. 세차새차에서는 이 CDR API를 통해 매장의 테블랫에 고객의 정보가 포함된 팝업창이 자동으로 생성되도록 처리하고 있다. 그러나 비즈콜에선 해당 CDR API에 대한 별도의 인증 절차를 제공해주지 않아 서버에서 직접 비즈콜 관련 API에 대한 접근을 제한하기로 했다. 요구사항은 아래와 같다.  비즈콜 IP 대역에 포함되는 IP를 가진 클라이언트만 BixCallDcrController 하위의 모든 엔트포인트에 접근할 수 있도록 한다.  서버에 들어오는 모든 요청이 아니라 특정 API에서만 인증절차를 거치도록 한다.  비즈콜 관련 API에만 사용되는것이 아니라 범용적으로 사용 가능하도록 어노테이션 형태로 개발한다. 1. 고려한 방법들: 커스텀 어노테이션을 사용하는 건 이미 결정된 사항이고, 어떤 방식을 사용해 인증 절차를 거칠지에 대해 고민해봐야 했다. 고려한 방식으로는 아래 세가지가 있다.  필터링 사용 인터셉터 사용 AOP 사용IP 필터링에 대해 구글링을 해보았을때 가장 많이 보인 방식이 필터링이었던거 같다. 필터링: 12345678910111213@WebFilter(urlPatterns =  /targetUri/* ) //비즈콜 api 경로public class IPFilter implements Filter {		. . . 		@Override	protected void doFilter(HttpServletRequest request, 	HttpServletResponse response, FilterChain filterChain) 		throws ServletException, IOException {			//허용되지 않는 IP인지 검증		}	. . . }그러나 필터링은 전역적인 요청에 대해 사용되는 인증으로, 요구사항처럼 특정 어노테이션을 사용하고 있는 엔드포인트에만 검증을 하도록 하기 불편하다. 보기에도 예쁘지 않다. url 패턴을 통해 필터링을 거는 것이 아니라 handlerMethod가 특정 커스텀 어노테이션을 가지고 있는지 확인하는 방식으로 어노테이션을 사용할 순 있겠으나 이런 방식을 사용하면 서버에 들어오는 모든 요청이 이러한 검증을 거치게 된다.  문제점    어노테이션과 함께 사용하기 까다롭다.   요구사항이 일부 기능에 대한 인증절차 추가인 것에 비해 필터링은 Spring 범위 이상으로 전역적이다.  인터셉터: 123456789101112@Configurationpublic class WebConfig implements WebMvcConfigurer {  @Autowired  private IPFilter ipFilter;  @Override  public void addInterceptors(InterceptorRegistry registry) {    registry. addInterceptor(ipFilter)	    //. addPathPatterns( /targetUri/* );   }}1234567891011121314151617181920212223@Componentpublic class IPFilter implements HandlerInterceptor {	@Override	public void preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)		throws Exception {		String clientIP = request. getRemoteAddr();		String requestURI = request. getRequestURI();		String controllerClassName = requestURI. split( / )[1];				Class&lt;?&gt; controllerClass = Class. forName( com. example. controllers.   + controllerClassName);		IpBandLimiter annotation = controllerClass. getAnnotation(IpBandLimiter. class);		// 클래스의 어노테이션 확인		// HandlerMethod handlerMethod = (HandlerMethod) handler;		// IpBandLimiter annotation = handlerMethod. getMethodAnnotation(IpBandLimiter. class); 		// 메서드의 어노테이션 확인				if (annotation != null) {			String[] allowedIPs = annotation. allowedIps();			// IP 검증		}	}필터링 다음으로는 인터셉터를 생각했다. 다른 프로젝트에서는 특정 uri 하위의 엔드포인트에 접속하는 경우 사용자의 출석 정보를 업데이트 하기 위해 인터셉터를 사용했었다.  문제점    리플렉션을 사용하면 클래스나 메서드에 특정 어노테이션이 붙어있는지 확인하기는 어렵지 않다.   호출한 메서드에 특정 어노테이션이 포함돼있는지 확인하는 것도 어렵지 않다.   그러나 어떤 엔드포인트가 어느 클래스에 포함돼있는지 확인하기는 어렵다.  물론 해당 인터셉터가 필요한 모든 메서드에 일일이 어노테이션을 붙인다면 위 문제를 해결할 수는 있으나 나는 클래스에 붙은 어노테이션이 클래스 하위의 모든 메서드에 적용되길 원했다. 필터 vs 인터셉터: 필터  Spring 컨텍스트 외부에 있는 web 컨텍스트에서 동작 Spring보다 큰 범위의 요청(공통적인 보안, 로깅, 요청 인코딩 설정 등)에 대해 처리인터셉터  Spring 컨텍스트에서 동작 Spring과 관련된 요청(컨트롤러 호출 전후의 로직 처리 등)에 대해 처리AOP: 최종적으로는 AOP를 사용하는 것으로 결정했다. 무엇보다 주어진 요구사항에 따라 개발하기에 적절했기 때문이다. 요구사항은 BizCallController 하위의 모든 엔드포인트를 타겟으로 하기에 나는 각 메서드마다 어노테이션을 붙이기 보다는 컨트롤러에 붙은 어노테이션이 하위 메서드에 모두 적용되길 바랬다. 인터셉터를 사용하면 메서드 자체에 붙어있는 커스텀 어노테이션의 존재 여부는 확인할 수 있으나 해당 엔드포인트가 어떤 클래스의 엔드포인트인지 알 수 없어 클래스에만 어노테이션을 붙이는 식으로 사용은 불가능했다. 그러나 AOP의 어드바이스를 사용하면 위 문제를 깔끔하게 해결할 수 있었다.  📝   AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)  관심사로부터 횡단(공통) 관심사를 분리하여 관심사를 모듈화하는 소프트웨어 개발 패러다임 AOP는 아래와 같은 개념을 사용한다.  관심사(Concern): 프로그램의 기능적 또는 비기능적(로깅, 보안, 트랜잭션 관리 등) 요구사항 횡단 관심사(Cross-Cutting Concern): 여러 모듈에서 공통으로 사용되는 관심사(로깅, 인증 등)   애스펙트(Aspect): 횡단 관심사를 모듈화한 것. 포인트컷(Pointcut)과 어드바이스(Advice)로 구성됨      조인 포인트(Join Point): 프로그램 실행 중의 특정 시점 (메서드 호출, 예외 발생 등)   포인트컷(Pointcut): 특정 규칙이나 표현식을 사용하여 조인 포인트를 결정         @Pointcut( execution(. . . ) )          어드바이스(Advice): 포인트컷에 의해 선택된 조인 포인트에서 실행되는 코드         Before, After, Around 등          PointCut Designator (PCD): 횡단 관심사가 적용될 지점을 지정하기 위한 표현식         within, target, annotation, @within, @target, @annotation 등          2. 개발: 커스텀 어노테이션 인터페이스: 사용자가 직접 정의한 Annotation을 Custom Annotation이라 한다. 반대로 @Overrie, @Deprecated, @SuppressWarnings 등 SDK에 내장되어 있는 기본 Annotation은 Built-in Annotation이라 부른다.  12345@Target({ElementType. TYPE, ElementType. METHOD})@Retention(RetentionPolicy. RUNTIME)public @interface IpBandLimiter {	String[] allowedIps();} ElementType. TYPE: 클래스, 인터페이스, 열거형(enum), 애노테이션 타입에 적용할 수 있다.  ElementType. METHOD: 메소드에 적용할 수 있다.  RetentionPolicy. RUNTIME: 어노테이션의 수명이 런타임까지 유지된다.  allowedIps 속성을 통해 String 타입의 IP를 문자열 배열로 입력받는다. AOP: ‘접근 가능한 IP 인증’이라는 횡단 관심사를 모듈화하여 하나의 Aspect로 만드려고 한다. 이때 어드바이스는 Before, PCD는 annotation으로 하여 특정 어노테이션이 실행되기 전에 에스펙트가 실행될 수 있도록 구상했다. 12345678910111213141516171819202122@Slf4j@Aspect@Componentpublic class IpLimiter {	@Before( @annotation(ipBandLimiter) )	public void ipBandLimiter(IpBandLimiter ipBandLimiter) throws RuntimeException {		HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder. currentRequestAttributes()). getRequest();		String clientIp = requset. getRemoteAddr(); //클라이언트 IP 추출		String[] allowedIPs = ipBandLimiter. allowedIps(); //어노테이션에 정의된 접근 가능 IP 목록				if (!isAllowedIp(clientIp, allowedIPs)) {			log. warn( Not allowed IP (client ip =   + clientIp +  ) );			throw new ApplicationException(NOT_ALLOWED_IP_ACCESS); //허용되지 않은 IP라면 예외를 발생시킨다. 		}		log. info( Allowed IP (client ip =   + clientIp +  ) );	}	private boolean isAllowedIp(String clientIP, String[] allowedIPs) {		return Arrays. stream(allowedIPs). anyMatch(clientIP::startsWith);	}}IpLimiter Aspect 12345@RestController@RequestMapping( /v2/external/bizcall )@RequiredArgsConstructor@IpBandLimiter(allowedIps = { . . . })public class BizCallCdrController { . . . }실제 IpBandLimiter 어노테이션 적용 문제 발생: 그러나 IpBandLimiter 어노테이션이 붙은 클래스의 메서드를 실행시켜도 IpLimiter가 실행되지 않았다… 후후 AspectJ 문서를 읽어보니 아래와 같은 설명을 발견할 수 있었다.   @annotation: Limits matching to join points where the subject of the join point (the method being run in Spring AOP) has the given annotation.  보아하니 @annotation은 메서드 수준의 어노테이션에서만 적용되는 것 같았다. 위 코드에서 나는 @ipBandLimiter를 메서드가 아닌 클래스에 적용했으니 클래스 수준의 어노테이션을 읽지 못하고 메서드에 어노테이션이 존재하지 않는 것으로 판단한 것이다. 실제로 어노테이션을 메서드 수준으로 옮겼더니 잘 작동되었다… 그러나 나는 클래스에 선언된 어노테이션이 하위 메서드에도 적용되길 원한다! AspectJ 문서에는 아래와 같은 PCD 또한 설명하고 있다.  @within: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP).  @within은 어노테이션이 주어진 어떤 타입(클래스) 하위의 메서드에 대해 조인 포인트를 제한한다. 이를 사용하면 클래스 하위의 메서드에도 해당 클래스에 적용된 에스펙트가 실행될 것이라 생각했다. 12345	@Before( @within(ipBandLimiter) )	public void ipBandLimiter(IpBandLimiter ipBandLimiter) {		. . . 	}PCD 수정 1 코드를 위와 같이 수정했더니 BixCallDcrController 하위의 메서드를 실행해도 ipBandLimiter()가 실행되었다. 그러나 위 코드는 이제 메서드 수준의 어노테이션을 읽지 못할 것이다(클래스에는 어노테이션이 선언되지 않았지만, 메서드에는 선언된 경우 실행되지 않을 것) 따라서 메서드와 클래스 수준 어디에 어노테이션이 적용되어도 에스펙트가 실행될 수 있도록 코드를 아래와 같이 수정했다. 12	@Before( @within(ipBandLimiter) || @annotation(ipBandLimiter) )	public void ipBandLimiter(IpBandLimiter ipBandLimiter) {. . . }PCD 수정 2 클라이언트 Ip 추출: 이제 어노테이션을 통한 IP 제한 자체는 가능해졌으나 문제가 있다. 아래의 세차새차 인프라 일부를 확인해보자. 클라이언트 요청은 ALB를 타고 세차새차 서버로 들어오게 된다. 이렇게 되면 클라이언트 IP를 추출하는데 문제가 생긴다… X-Forwarded-For:  📝   X-Forwarded-For(XFF)  HTTP 프록시나 로드 밸런서를 통해 웹 서버에 접속하는 클라이언트의 원 IP 주소를 식별하는 사실상의 표준 헤더 일반적으로 클라이언트의 IP값은 request. getRemoteAddr()를 통해 가져올 수 있겠지만 중간에 프록시나 로드 밸런서를 거치는 경우는 다르다. 클라이언트와 서버 중간에서 트래픽이 프록시나 로드 밸런서를 거치는 경우 서버 접근 로그에는 클라이언트의 IP가 아니라 직전에 거쳐온 트래픽이나 로드 밸런서의 주소가 남기 때문이다. 따라서 클라이언트의 원래 IP를 확인하기 위해서는 X-Forwarded-For 헤더를 확인해야한다.  1X-Forwarded-For: &lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;클라이언트의 요청이 로드 벨런서 A를 지난 후 X-Forwarded-For의 가장 첫번째 값은 Client Ip가 된다. 이후 다른 프록시나 로드 밸런서 B를 지나게 된다면 로드 벨런서 B의 ip값이 XFF 헤더 뒤에 추가될 것이다. 코드: 1234567891011121314	@Before( @within(ipBandLimiter) || @annotation(ipBandLimiter) )	public void ipBandLimiter(IpBandLimiter ipBandLimiter) throws RuntimeException {		HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder. currentRequestAttributes()). getRequest();		String clientIp = extractClientIp(request);		. . . 	}	private String extractClientIp(HttpServletRequest request) {		String xffIps = request. getHeader( X-Forwarded-For );		if (xffIps != null) {			return xffIps. split( , )[0];		}		throw new ApplicationException(NOT_ALLOWED_IP_ACCESS);	}XFF 헤더의 가장 첫번째 값(clientIp) 가져오도록 코드를 작성했다. 만일 XFF헤더가 존재하지 않는다면 로드 벨런서를 거쳐온 요청이 아니므로, 정상적인 요청으로 판단하지 않아 예외를 발생시킨다. 테스트 코드: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootTest@Transactionalpublic class IpLimiterTest {	@Autowired	private BizCallCdrController bizCallCDrController;	@Autowired	private StoreRepository storeRepository;	@Autowired	private MemberRepository memberRepository;	@Autowired	private StoreTestHelper storeTestHelper;	@Test	@DisplayName( 허용되지 않은 ip는 타겟에 접근할 수 없다.  )	public void 허용되지_않은_ip는_타겟에_접근할_수_없다() throws Exception {		//given		MockHttpServletRequest request = new MockHttpServletRequest();		String notAllowedIp =  197. 2. 72. 178 ;		request. addHeader( X-Forwarded-For , notAllowedIp);		RequestContextHolder. setRequestAttributes(new ServletRequestAttributes(request));		Store store = storeTestHelper. makeStaticRunningStore();		memberRepository. save(store. getOwner());		storeRepository. save(store);		// when &amp; then		assertThrows(ApplicationException. class,			() -&gt; bizCallCDrController. cdrCallInboundInit( 01 ,  20200202020202 ,  000-0000-0000 , store. getTel(),				 111-1111-1111 ,  memo ,  memo2 ));	}	@Test	@DisplayName( 허용된 ip는 타겟에 접근할 수 있다.  )	public void 허용된_ip는_타겟에_접근할_수_있다() throws Exception {		//given		MockHttpServletRequest request = new MockHttpServletRequest();		String allowedIp =  210. 109. 108. 133 ;		request. addHeader( X-Forwarded-For , allowedIp);		RequestContextHolder. setRequestAttributes(new ServletRequestAttributes(request));		Store store = storeTestHelper. makeStaticRunningStore();		memberRepository. save(store. getOwner());		storeRepository. save(store);		//when &amp; then		assertDoesNotThrow(			() -&gt; bizCallCDrController. cdrCallInboundInit( 01 ,  20200202020202 ,  000-0000-0000 , store. getTel(),				 111-1111-1111 ,  memo ,  memo2 ));	}}간단한 테스트 코드를 작성했다. 3. 추가 고려 사항: XFF 헤더 조작: 프론트+백엔드 작업을 하시는 작업자분에게 위와 같은 리뷰가 달렸다. 이럴수가. . 코드를 작성할때는 생각해본적 없던 문제였다. 실무 개발자들은 다양한 가능성을 떠올릴수 있구나 싶었다. 리뷰가 달린 후 클라이언트의 XFF 헤더 조작 가능성에 대해 알아봤다. Append: AWS 문서에서 ALB 설정에 관한 문서를 찾을 수 있었다.  https://docs. aws. amazon. com/ko_kr/elasticloadbalancing/latest/application/application-load-balancers. html 로드 벨런서의 xff_header_processing. mode는 기본적으로 Append로 설정되어 있다. 만일 클라이언트가 요청을 조작하여 요청에 조작된 IP를 가지는 XFF헤더를 추가해 전송한다면 로드 벨런서는 조작된 IP를 유지한 채 XFF 헤더 마지막에 client Ip를 덧붙이게 될 것이다. Preserve는 요청에 담긴 XFF헤더에 값을 추가하지 않고 그대로 유지하는 설정이고 Remove는 아예 요청에서 XFF헤더를 제거해버리는 설정이다. XFF헤더의 값을 아예 교체하는 설정은 존재하지 않는 듯 하다. 이렇게 되면 문제가 발생할 수 있다. 사용자가 XFF헤더에 값을 추가해서 전송하면 서버는 진짜 Client Ip가 XFF 헤더의 어느 위치에 존재하는지 알 수 없다는 점이다. set_real_ip_from: 위 문제는 nginx 설정을 통해 해결할 수 있다.  set_real_ip_from    Defines trusted addresses that are known to send correct replacement addresses  올바른 주소를 보내는 것으로 알려진 신뢰 가능한 주소를 정의한다.   real_ip_recursive    If recursive search is enabled, the original client address that matches one of the trusted addresses is replaced by the last non-trusted address sent in the request header field.   만약 설정이 켜져있다면, 신뢰가능한 주소와 일치하는 원본 클라이언트 주소는 요청 헤더에 전송된 가장 마지막의 비신뢰 주소로 교체된다.  솔직히 문서만 봐서는 이해가 어려웠다. 해당 블로그 글이 많은 도움이 되었다.  문제상황을 가정하여 위 설정에 대해 설명을 해보려 한다. 클라이언트가 세차새차 서버에 아래와 같은 조작된 요청을 보내는 상황을 가정한다. 1X-Forwarded-For: &lt;비즈콜 IP&gt;그렇다면 로드 벨런서를 거쳐 nginx에 도달한 요청은 Append 설정에 의해 아래와 같이 바뀔 것이다. 1X-Forwarded-For: &lt;비즈콜 IP&gt; &lt;실제 클라이언트 IP&gt; &lt;사용한 로드 벨런서 IP&gt;nginx 설정이 되어있지 않는 경우 서버는 XFF 헤더의 가장 첫번째 값인 &lt;비즈콜 IP&gt;를 클라이언트 IP로 인식하고, 해당 요청이 비즈콜에서 온 것이라 판단하며 서버에 접근시킬 것이다.  위와 동일한 상황에서, 이번에는 아래와 같이 nginx가 설정되어있다 가정하자. 123set_real_ip_from &lt;사용하는 로드 벨런서 IP&gt;set_real_ip_from &lt;사용하는 프록시 IP&gt;real_ip_recursive on;nginx 설정 로드 벨런서를 거쳐 nginx에 도달한 클라이언트 요청은 이전 상황과 동일하다. 1X-Forwarded-For: &lt;비즈콜 IP&gt; &lt;실제 클라이언트 IP&gt; &lt;사용한 로드 벨런서 IP&gt;nginx에 따로 설정이 되어있지 않을 때는 가장 앞에 있는 &lt;비즈콜 IP&gt;를 클라이언트 IP로 인식했지만 이번에는 다르다. &lt;실제 클라이언트 IP&gt;는 set_real_ip_from에 정의된 신뢰 가능한 주소가 아니다. 따라서 real_ip_recursive 에 의해 신뢰 가능한 주소로 정의된 &lt;사용한 로드 벨런서 IP&gt; 앞에 있는 &lt;실제 클라이언트 IP&gt;를 실제 클라이언트 IP로 인식한다.  그러나 위 설정을 아직 적용시키진 않았다 ^^; 비즈콜 IP 위조 자체가 치명적인 보안 문제를 발생시키기 보다는 사장님이 좀 짜증나는 정도가 전부이기 때문에 여기에 시간을 쓰기 보다는 더 급한 서비스 개발을 먼저 하기로 했다. Slient fail?: 추가적으로 고려해볼 사항이 하나 더 있다. 지금은 허용되지 않은 IP에서 접근할 시 NOT_ALLOWED_IP_ACCESS 예외를 반환하는데, 이렇게 해커에게 직접적으로 예외 발생 여부를 보여주는 건 좋지 않다고 한다. 따라서 해커의 요청을 거부할 시에는 실제로는 요청을 거부하되 클라이언트 상에서는 요청이 허용된 것처럼 넘겨주어야 한다는데 이것에 대한 정확한 명칭을 모르겠다 (검색해보았을때 가장 유사해보이는데 slient fail이었다. )  배운 점: AOP는 아직 알아야 할 부분이 많은 것 같다. 토비의 스프링에서 AOP에 대한 부분을 상당히 두껍게 다루던데(…) 그걸 읽어보며 공부하고 한번 정리하는 것도 괜찮을 것 같다. "
    }, {
    "id": 25,
    "url": "http://localhost:4000/ect1/",
    "title": "블로그 정체 중",
    "body": "2024/06/10 -  쓰다만 글과 정리만 하면 되는 글들이 가득 쌓여있다… 엄청 바쁜것도 아닌거 같은데왜 글을 정리하고 블로그에 업로드할 시간이 나지 않는 거지!이제부터 열심히 정리하려고 한다……. . 업로드된 블로그 글들도 좀 정리하고 싶은데😂 (쓸데없는 글들이 너무 많아서) "
    }, {
    "id": 26,
    "url": "http://localhost:4000/rabbitmq1/",
    "title": "세차새차 비즈콜 서비스 개발 (1) -RabbitMQ 적용",
    "body": "2024/06/10 - 개요: 세차새차 서비스의 비즈콜 서비스 개발을 담당하게 됐다. 비즈콜은 크게 WebSocket과 RabbitMq로 기능이 나뉘어지는데, 이번 포스팅에서는 그 중 RabbitMq에 대해 설명하려한다. 비즈콜: 세차새차는 비즈콜을 도입하여 전보다 더 간편한 예약을 시스템을 제공하려 한다. 비즈콜을 사용함으로써, 세차장은 관리인의 개인 번호가 노출됨을 막을 수 있으며 고객의 전화와 동시에 세차장의 패드에 예약 정보 입력 팝업을 띄워 세차장 예약 관리에 편의성을 더해줄 수 있다.  비즈콜 도입의 이점  개인 번호 비공개 예약 전화와 동시에 팝업을 띄어 예약 정보 입력에 편의성을 더함.  💡   CDR(Call Detail Record)  유무선 전화 통화에 대한 로그 데이터 비즈콜에서 제공하는 CDR 파라미터에는 아래와 같은 데이터가 있다.       seq   CDR을 구분짓는 번호       sdt   Start Date: 호 시작 시각, YYYYMMDDHH24MISS       edt   End Date: 호 종료 시각, YYYYMMDDHH24MISS       fromn   From Number: 발신번호       ton   To Number: 착신번호       등등. .         위 기능의 서버 부분을 조금 더 자세히 살펴보자.  💡   ALB(Application Load Balancer)  여러 대의 서버 사이에 트래픽을 분산시키는 기술 고객이 비즈콜에 전화를 하면 고객 전화 정보를 담은 CDR 데이터가 서버에 저장된다. 이때, Application load balancer를 통해 고객 정보는 여러대의 인스턴스 중 가장 트래픽이 적은 인스턴스에 저장되게 된다. 즉, 우리는 고객의 정보가 어떤 인스턴스에 저장되는지 알 수 없다. RabbitMQ의 필요성: 인스턴스와 클라이언트(매장의 패드)은 서로 webSocket을 통해 연결돼있다. 고객이 비즈콜을 통해 전화를 하면 그에 따른 CDR 정보가 인스턴스에 저장되고, 이 CDR 정보가 해당 인스턴스와 연결돼있는 매장과 동일하다면 webSocket 연결을 통해 실시간으로 클라이언트에 팝업을 띄울 수 있다. 그러나 문제는 비즈콜을 통한 고객 정보가 어떤 인스턴스에 저장될지 알 수 없다는 점이다. 고객이 매장 A에 전화했다는 CDR 정보가 인스턴스 1에 담기더라도 인스턴스 1이 매장A와 webSocket 연결돼있지 않다면 매장 A로 팝업 요청을 보낼 수 없다. 따라서 우리는 새로 저장된 고객의 CDR 정보를 모든 인스턴스에 공유해줄 필요가 있다. RabbitMQ:  💡   Amazon MQ: 오픈 소스 메시징 브로커를 호스팅하고 관리하는 관리형 메세징 서비스. AWS에서 제공   RabbitMQ: 송신자와 수신자 간에 메시지를 전달하는 중간 매개체로 작동하는 메세지 브로커 소프트웨어. AMQP을 지원한다.  서버에 CDR 데이터가 새로 저장됐을 때, 이를 RabbitMQ를 통해 전체 인스턴스로 메세징하기로 한다. AMQP:  💡   AMQP(Advanced Message Queuing Protocol)  분산 시스템에서 메시지 전달, 큐 관리, 라우팅 등을 위한 기능을 정의하는 메시징 시스템의 표준 통신 프로토콜  메세징은 메세지를 보내는 주체인 Producer가 메세지를 받는 대상인 Consumer까지 메세지를 전달하는 과정이다. 이 과정에서 Producer가 전달한 메세지는 Exchanger가 가진 타입에 따라 특정 Queue에 저장되게 된다. Queue는 하나의 Consumer만을 가질 수도 있고 여러개의 Consumer를 가질 수도 있으며, Consumer가 Consume하는 것으로 할당된 Queue에 저장된 메세지를 빼내 쓸 수 있다.        Direct   라우팅 키가 정확히 일치하는 Queue에 메시지 전송       Topic   라우팅 키 패턴이 일치하는 Queue에 메시지 전송       Headers   [key:value]로 이루어진 header값을 기준으로 일치하는 Queue에 메시지 전송       Fanout   해당 Exchange에 등록된 모든 Queue에 메시지 전송   Exchanger는 위와 같은 4가지 타입을 가질 수 있다. 목표로 하는 Consumer가 어느 queue와 연결돼있는지 알 수 없으므로 세차새차 서비스는 모든 큐에 메세지를 저장해야한다. 따라서 하나의 Exchanger를 Fanout 타입으로 설정한 후 모든 Queue를 해당 Exchanger에 바인딩 시켰다. 개발: RabbitMQ 연결: RabbitMQ는 다운받아서 로컬에서도 작동시킬 수 있지만 CloudAMQP라는 사이트에서 회원가입만 진행하고, 웹상에서 활용도 가능하다고 한다. 세차새차는 AWS를 사용하고 있기 때문에 AWS에서 제공하는 AmazonMQ를 통해 RabbitMQ를 사용하기로 했다.  RabbitMq Management 화면 123456789101112131415spring: rabbitmq:  host: {broker ID}. mq. ap-northeast-2. amazonaws. com  port: 5671  username: {username}  password: {password}  virtual-host: /  ssl:   enabled: truerabbitmq: queue:  name: bizcall-cdr-inbound-call-dev exchange:  name: bizcall-exchange-dev application. yml Port 설정  Listener port 5671 - Used for connections made via the secure AMQP URL. For example, given a broker with broker ID b-c8352341-ec91-4a78-ad9c-a43f23d325bb, deployed in the us-west-2 region, the following is the broker’s full amqp URL: b-c8352341-ec91-4a78-ad9c-a43f23d325bb. mq. us-west-2. amazonaws. com:5671 보안 AMQP 연결을 위해 5671번 포트를 사용하자.  123456789101112131415161718192021222324252627282930@RequiredArgsConstructor@Configurationpublic class RabbitMqConfiguration {	@Value( ${rabbitmq. queue. name} )	private String queueName;	@Value( ${rabbitmq. exchange. name} )	private String exchangeName;	@Bean	public Queue queue() {		return new Queue(queueName +  -  + UUID. randomUUID(), false, true, true);	}	@Bean	public FanoutExchange fanoutExchange() {		return new FanoutExchange(exchangeName);	}	@Bean	public Binding binding(Queue queue, FanoutExchange exchange) {		return BindingBuilder. bind(queue). to(exchange);	}	@Bean	public MessageConverter jackson2JsonMessageConverter() {		return new Jackson2JsonMessageConverter();	}} configuration 코드 Configuration 코드를 통해 Queue와 Exchanger을 생성하고 바인딩 해주었다. 코드로 설정을 하고 실행시키는 것만으로도 자동으로 queue와 exchanger가 생성되고 바인딩 된다.  Queue     인스턴스별로 랜덤하게 큐 이름을 지어주기 위해서 UUID 값을 지정해주었다. 그렇지 않으면 fanout이 되지 않는다고 리뷰가 달렸으나 직접 확인해보진 않았다(ㅎㅎ. . )    Binding     Exchanger를 Fanout 속성으로 사용하기 때문에 바인딩 코드에서 with를 통한 라우팅 키 설정은 제외했다.      https://www. rabbitmq. com/tutorials/tutorial-four-spring-amqp#bindings     jackson2JsonMessageConverter     RabbitMqTemplate에서 사용하는 MessageConverter를 jackson2JsonMessageConverter로 교환해주었다.    기본적으로는 SimpleMessageConverter을 사용하도록 설정돼있나 SimpleMessageConverter는 String input을 받기 때문에 전송할 메세지를 String으로 변환해주어야 하는 번거로움이 있다.   그러나 jackson2JsonMessageConverter는 Object 타입의 input을 받기 때문에 따로 변환할 필요가 없고, output값을 Json message로 뽑아주기 때문에 사용에 더 용이하다.    에러 발생:  inequivalent arg ‘type’ for exchange ‘bizcall-exchange’ in vhost ‘/’: received ‘fanout’ but current is ‘direct’, class-id=40, method-id=10) 설정 코드를 작성하고 큐와 exchanger 생성을 위해 프로젝트를 실행시키니 위와 같은 에러가 발생했다.  이제보니 기존에 존재하던 ‘bizcall-exchange’ 가 direct로 생성돼있었다. 삭제해주자.  삭제후 프로젝트를 다시 실행하니 fanout으로 잘 생성 되었다.  큐도 exchange에 정상적으로 binding된 것을 확인할 수 있다. 코드 작성: 12345678910111213141516171819202122232425262728293031323334@Slf4j@RequiredArgsConstructor@Servicepublic class CallRabbitMqService {	private final RabbitTemplate rabbitTemplate;	private final CallWebSocketService callWebSocketService;	private final StoreRepository storeRepository;	@Value( ${rabbitmq. exchange. name} )	private String exchangeName;	public void sendMessage(RabbitMqMessageDto messageDto) {		try {			log. info( RabbitMqMessage SEND: {} to exchanger {} , messageDto. toString(), exchangeName);			rabbitTemplate. convertAndSend(exchangeName,   , messageDto);		} catch (Exception exception) {			log. error(exception. toString());			throw new ApplicationException(ApplicationError. RABBITMQ_CONNECTION_ERROR);		}	}	@RabbitListener(queues =  #{queue. name} )	public void receiveMessage(RabbitMqMessageDto messageDto) {		log. info( RabbitMqMessage RECEIVED: {} , messageDto. toString());		try {			//웹소켓 설정 코드 작성			callWebSocketService. sendMessage(topicPath, messageDto);		} catch (Exception exception) {			log. error( RabbitMqMessage Handling Error );		}	}} 실행시 로그 정보 정상적으로 큐에 메세지가 전달 &amp; 컨슘됐음을 확인할 수 있다. postman으로 직접 api를 호출해본 결과 정상적으로 queue에 전달되었음을 확인했다. (위 스크린샷을 찍었을 때는 listener. simple. acknowledge-mode가 manual 로 설정되어 있어 에러 발생 여부와 무관하게 Unacked로 처리되었다. ) 글이 길어져서 TTL, dlx 설정은 다음 게시글로 이어서 작성해야겠다~  배운 점: 만들고 싶은 개인 프로젝트에 유사 메세지 시스템이 포함될거 같은데(언제 만들어 이거ㅠ) RabbitMQ을 통해 선행학습의 기회를 얻었을지도…. "
    }, {
    "id": 27,
    "url": "http://localhost:4000/docker1-front/",
    "title": "인프라 스터디 (1) Docker로 프론트 배포하기",
    "body": "2024/05/12 - 개요: 두레 인프라 인수인계를 받기 위해 인프라 스터디에 참가했다🫡 첫번째 과제는 Keeper 홈페이지의 프론트 코드를 docker를 사용하여 배포하는 것이었다. 과제 해결을 위해 공부한 내용을 정리했다. Docker?:     https://smartstore. naver. com/dsticker/products/5945531926  Environment Disparity: 개발 환경의 차이로 발생하는 문제를 Environment Disparity라 한다. (윈도우에서는 동작하는 코드가 리눅스에도 동작하지 않음) Docker를 통해 다른 머신에 동일한 환경을 구축하는 것으로 우리는 이러한 Environment Disparity를 해결할 수 있다. 저한테는 가상머신이 있는데요? (VM vs Docker): 사람에 따라 가상머신이 더 친숙한 사람도 있을 거다. 나도 학교 수업에서 Docker 대신 Vmware이나 VirtualBox를 사용해 그램 노트북으로 리눅스를 돌린 기억이 있다. 가상머신만 켰다 하면 노트북이 엄청나게 느려졌어서 그닥 좋은 기억은 아니다.  Vmware, Virtual Box를 포함한 Virtual Machine과 Docker의 가상화 방식에는 큰 차이가 하나 있는데, 바로 Guest OS의 유무이다. 가상머신은 호스트 OS 위에 가상화 소프트웨어를 이용해 여러개의 OS를 구동하는 방식으로 이루어진다. 이러한 게스트 OS들은 하이퍼바이저에 의해 호스트 OS로부터 완벽하게 독립된다.  전가상화: 하이퍼바이저가 가상화된 하드웨어를 게스트 OS에게 제공하는 방식으로 독립시킨다.  반가상화: 하이퍼바이저를 통해서만 호스트 OS에 접근할 수 있도록 하는 방식으로 독립시킨다. 그러나 도커 컨테이너를 사용한 가상화에서는 Host OS가 존재하지 않는다. VM처럼 물리적으로 공간을 격리하는 것이 아니라 프로세스를 격리하기 때문이다. 이로써 각 호스트 OS별 제공해야했던 자원이 줄어들어 더 많은 애플리케이션을 실행할 수 있으며, 호스트 OS를 실행시킬 필요가 없기 때문에 애플리케이션 실행 시간이 빠르다.  단 docker engine은 리눅스에서만 구동되기 때문에 mac이나 window와 같은 운영체제에서 사용시 vm으로 리눅스를 띄우고 그 위에 docker를 실행시켜야한다. docker desktop 사용시 vm을 생성하는 복잡한 과정을 해결해주기 때문에 편하다. 이미지(image): VM과 도커 컨테이너는 모두 이미지(image)로부터 생성된다. 이미지는 가상화된 환경의 청사진이며, 각 애플리케이션을 실행하는 데 필요한 독립적인 환경과 시스템 리소스를 지정한다.  단, VM 이미지는 전체 운영 체제, 라이브러리, 응용 프로그램 및 설정을 포함하는 단일 파일로 구성돼있는 반면 도커 이미지는 계층(layer)을 가진다. 도커 이미지의 각 계층은 불변(Read only)이며 불변 레이어를 추가하는 것으로 필요 환경에 맞출 수 있다. (예를 들어, ubuntu 이미지 위에 레이어를 하나 추가하는 것으로 nginx 이미지가 된다. ) 이러한 이미지의 불변성을 통해 개발자는 안정적이고 균일한 조건에서 소프트웨어를 테스트하고 실험할 수 있게 된다. 이러한 도커 이미지를 생성하기 위해 Dockerfile을 사용한다. 컨테이너(Container):  컨테이너는 이미지를 통해 생성되는 이미지의 인스턴스로, 이미지를 실행할 때 생성되는 가상 환경이다. 이미지는 실행될 수 없으나 이미지 위에 Container layer를 추가하는 것으로 호스트와 다른 컨테이너로부터 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 가상환경이 생성된다. 프론트 배포하기: 인프라 스터디의 첫주차 과제는 Keeper 홈페이지의 프론트를 배포하는 것이었다. Dockfile 작성 &amp; 빌드: 12345678910111213141516171819202122#가져올 이미지 정의(from dockerhub)#베이스 이미지 지정FROM node:12#작업 디렉토리 변경(경로 설정)WORKDIR /app#파일 또는 디렉토리 추가COPY package*. json . /# 호스트 운영체제의 현재 디렉토리 상에 있는 ~파일들을 복사해서 이미지의 현재 디렉토리에 복사해줌#명령어 실행RUN npm install# 현재 디렉토리에 있는 package. json 파일들 읽어서 설치EXPOSE 3000#컨테이너에서 사용할 포트 정보#컨테이너 생성시 실행할 명령어CMD node app. js#docker build -t nodejs-server . 이미지를 빌드하기 위해 프로젝트의 루트 위치에 Dockerfile을 작성했다. docker build -t nodejs-server . 명령을 통해 nodejs-server라는 이름으로 Dockerfile을 빌드하여 이미지를 생성할 수 있다.  ERROR: failed to solve: process “/bin/sh -c npm install” did not complete successfully: exit code: 1 dockerfile 빌드 과정에서 위와 같은 오류가 발생했다. 위 오류는 로컬의 package-lock. json을 제거하고 다시 이미지를 빌드하니 해결되었다.  이미지가 생성된 걸 확인할 수 있다. Docker-compse 작성: 하나의 컨테이너가 여러 응용 프로그램을 포함할 수도 있으나 일반적으로 한 컨테이너는 하나의 프로세스만을 가진다. 컨테이너를 만드는 비용이 크지 않기 때문에 컨테이너를 여러개 만들어 관리하는 것이 더 효율적이고 설계 변경에도 용이하다. 키퍼 홈페이지도 한 서버에 프론트, 백, 데이터베이스, 레디스까지 해서 총 4개의 컨테이너가 떠있는 상태다. 여러 컨테이너를 실행시키기 위해 직접 CLI에 각 컨테이너마다 run 명령어를 작성할 수도 있겠지만 아무래도 번거롭고, 동작을 확인하기도 어렵다. 도커 컴포즈는 단일 서버에서 여러개의 컨테이너를 하나의 서비스로 정의해 컨테이너의 묶음으로 관리할 수 있는 작업 환경을 제공한다. 참고로 window나 mac은 docker 데스크탑 애플리케이션을 다운받으면 자동으로 적용된다. 1 docker run -d -p 3000:3000 --name react-app nodejs-server위와 같은 기존의 도커 명령을 아래와 같은 docker-compose 파일로 작성할 수 있다.  123456789101112131415161718version:  2 services: web:  build: . # 현재 경로에 이미지 빌드  ports:    -  3000:3000  #포트 포워딩  image: nodejs-server  volumes:    - . /src:/app/src:ro   #호스트 머신의 현재 작업 디렉토리 내 src 폴더를 컨테이너 내부의 /app/src 경로에 읽기 전용으로 마운트   #호스트 데이터를 컨테이너에게 공유  networks:   - testnetnetworks: testnet:  external: true 그러나 위 코드는 제대로 작동하지 않았다😅 원인은 차후 설명한다. volume: 도커는 각 컨테이너마다 독자적인 저장소을 가지며, 해당 데이터는 다른 컨테이너에 공유되지 않는다. 그러나 사용자는 항상 같은 서버에 접속하는 보장이 없으며 만일 사용자가 다른 서버에 접속하게 된다면 이전에 저장한 데이터를 조회하지 못하게 된다. 따라서 사용자 상태 유지를 위해 모든 컨테이너는 하나의 저장공간을 공유해야한다. 이를 위해 Docker에서는 컨테이너가 데이터를 유지하고 공유할 수 있도록하는 저장공간인 Volume을 제공해준다. (사용자 입력 데이터와 관련됬다기 보단 호스트 데이터를 컨테이너에 공유하는데 사용되는 거 같다. ) 볼륨은 기본적으로 호스트 디렉토리의 /var/lib/docker/volumes 경로에 저장된다. 그러나 docker는 리눅스 기반의 프로그램이고, mac에서 사용하는 경우 vm 위에 docker가 띄워지기 때문에 mac에는 해당 경로가 존재하지 않는다. 따라서 우리는 호스트의 저장 공간을 컨테이너의 저장공간에 마운트 할 필요가 있다.  💡   마운트  파일 시스템의 특정 위치를 다른 위치에 연결하는 프로세스  Docker에서는 호스트와 컨테이너 간에 데이터를 공유하기 위해 호스트의 파일 시스템 경로를 컨테이너의 특정 경로에 연결하는 것을 의미한다.  마운트는 docker-compose 파일에서 아래와 같은 형태로 이루어진다. 이를 통해 호스트와 컨테이너 간에 데이터를 주고받거나 공유할 수 있다.  12  volumes:   - /호스트/저장/경로:/컨테이너/내부/경로Network: 컨테이너는 서로 독립된 환경에서 동작하기 때문에 서로 통신할 수 없다. 따라서 각 컨테이너간 통신하기 위해서는 컨테이너들을 하나의 네트워크로 연결해주는 작업이 필요하다. 123networks: testnet:  external: true 자, 이제 docker-compose 파일을 작성 완료했다면 docker-compose up 명령어를 통해 컨테이너를 실행해보자. 오류발생: 컨테이너가 실행되었으나 그와 동시에 바로 종료되었다. log를 확인해보니 react를 import해오는 부분에서 Cannot use import statement outside a module 오류가 발생한다.  오류를 찾아보니 Typescript와 관련된 문제였다. Keeper 홈페이지는 Typescript를 통해 개발되었기 때문에 Typescript 언어를 Javascript로 컴파일해주는 과정이 필요했다. 123456789101112RUN npm install# 현재 디렉토리에 있는 package. json 파일들 읽어서 설치RUN npm install -g typescript# typescript 모듈 설치.  COPY . / . /# 현재 폴더에 있는 모든 파일들을 복사하여 이미지 디렉토리에 복사합니다. # 이 과정에서 자신이 작성한 코드등 리소스들이 복사됩니다.  RUN tsc# typescript로 작성된 node이므로 javascript 파일로 컴파일 해줍니다.  이는 위 명령을 추가하여 해결할 수 있었다.  [7/7] RUN tsc -p . :0. 805 /usr/local/lib/node_modules/typescript/lib/tsc. js:930. 805  for (let i = startIndex ?? 0; i &lt; array. length; i++) {0. 805              ^0. 8050. 805 SyntaxError: Unexpected token ‘?’ tsc 과정에서 위의 오류가 발생했는데, 이는 내가 베이스 이미지로 가져온 node 이미지의 버전 문제였다. ?? 문법을 이해할수 있는 18버전 노드로 이미지를 교체했다. 최종 docker-compose. yml: 12345678910111213141516171819202122232425FROM node:18WORKDIR /app#작업 디렉토리 변경(경로 설정)COPY package*. json . /# 호스트 운영체제의 현재 디렉토리 상에 있는 ~파일들을 복사해서 이미지의 현재 디렉토리에 복사해줌RUN npm install# 현재 디렉토리에 있는 package. json 파일들 읽어서 설치RUN npm install -g typescript# typescript 모듈 설치.  COPY . / . /# 현재 폴더에 있는 모든 파일들을 복사하여 이미지 디렉토리에 복사합니다. # 이 과정에서 자신이 작성한 코드등 리소스들이 복사됩니다.  RUN tsc# typescript로 작성된 node이므로 javascript 파일로 컴파일 해줍니다.  EXPOSE 3000#컨테이너에서 사용할 포트 정보CMD [ npm ,  run ,  start ] 성공~ 인프라를 공부하니 확실히 전보다 훨씬 폭넓은 수준의 지식을 획득할 수 있는 거 같아 좋았다😀 참고 프론트엔드 개발자를 위한 Docker로 React 개발 및 배포하기 "
    }, {
    "id": 28,
    "url": "http://localhost:4000/kakao-login/",
    "title": "카카오 로그인 api로 알아보는(1) -소셜 로그인",
    "body": "2024/05/01 - 개요: 만들어보고 싶었던 어플리케이션을 제작하며 우선적으로 소셜 로그인 기능을 만들어보기로 했다. 개인적으로 동작이 궁금했고 공부해보고싶었던 분야이기도 하고, 권한은 전체적인 애플리케이션 기능에 사용될테니 차라리 미리 만들어두는게 좋겠다 생각했기 때문이다. 실제 코드 작성에 앞서 로그인은 어떤 방식으로 이루어지며, 그중 소셜 로그인은 또 어떻게 다른지 알아보도록 하자~ HTTP 프로토콜: 왜 사용자 정보를 저장해야할까?: Statuful 통신의 한계:  💡 	stateful(상태 유지)	서버가 클라이언트의 상태를 보존하는 것 예를 들어 쿠키나 세션을 통해 서버에 클라이언트 인증 정보를 저장하여 클라이언트가 다른 페이지로 이동하더라도 로그인 상태가 유지되는 것을 stateful하다고 한다.  서버에 클라이언트의 상태가 저장되는 만큼 statuful 통신은 서버의 부하가 크다.      서버가 1만명의 클라이언트 정보를 저장할 수 있다면, 1만 명 이상이 연결될 경우 1만 번째 이후의 클라이언트들은 이미 연결된 클라이언트가 빠져나가고 나서야 처리될 수 있다.     클라이언트의 정보를 저장하고 있던 기존 서버에 장애가 생겨 다른 서버에 연결되는 경우 클라이언트의 정보를 다시 저장하는 문제가 있다. Stateless 통신:  💡 	Stateless(무상태) 서버에 클라이언트의 상태가 보존되지 않는다.  stateless 통신에서 서버는 요청이 들어오면 응답을 보내는 역할만 수행하고, 상태관리를 위한 책임은 모두 클라이언트에게 있다. 클라이언트는 상태 관리를 위해 서버와의 통신에서 상태 정보 데이터를 담아 전달한다.  서버에서 클라이언트의 상태를 저장하지 않으므로 기존 서버에 장애가 생겨 서버가 바뀌더라도 응답에 문제가 없다.  대량의 트래픽이 발생하더라도 각각의 요청이 독립적으로 처리되므로 서버 확장을 통한 병렬적 처리로 수월하게 해결할 수 있다.   여러 서버에서 트래픽이 독립적으로 처리된다. HTTP 프로토콜: HTTP 프로토콜은 Stateless한 특징을 지닌다. 따라서 로그인을 유지하기 위해선 모든 요청에 클라이언트의 정보를 담아 보내는 과정이 필요하다. 결국 로그인 상태의 유무는 요청에 사용자를 인증할 수 있는 정보가 담겨져 있는가로 나누어진다. 즉슨, 사용자 정보의 상태 유지를 통해 로그인을 유지할 수 있다. 그러나 이러한 상태 유지를 위해 매번 파라미터에 사용자 정보를 넘겨주는 작업은 번거롭다. HTTP 프로토콜에서 상태를 유지하기 위해 제공하는 메커니즘들을 알아보자. 로그인 방법: 로그인이란 것은 유지가 되어야 의미가 있다 (당연히, 로그인 페이지를 벗어났을 때 로그인이 풀리면 의미가 없으니까) 로그인을 한다는 것은 사용자 정보가 상태 유지된다는 의미다. http 통신에서 이러한 상태유지를 위해 사용하는 메커니즘들을 간단히 알아보자. 실제로 사용할 JWT와 OAuth에 대해 자세히 알아볼 것이므로 쿠키와 세션은 개념만 짚고 넘어가겠다. 쿠키:  키와 값으로 구성된 클라이언트 상태 정보 데이터 파일로 클라이언트 로컬에 저장된다.  사용자가 요청하지 않아도 브라우저가 알아서 요청의 Request Header에 쿠키를 삽입한다.  그러나 쿠키값은 변조가 가능하며, 민감 정보가 노출된다는 단점이 있다.      ex) 민감 정보가 쿠키에 저장될 경우 로컬 pc와 클라이언트→서버 네트워크에 노출된다.    ex) memberId=1이라는 쿠키로 로그인을 유지하는 경우, 쿠키값을 변조하는 것으로 타인의 계정에 로그인할 수 있다.    세션: 쿠키의 노출 이슈를 보안하기 위해 나온 대안이다.   민감 정보가 노출되지 않도록 서버에 저장하는 방법이다.  쿠키에 사용자 정보가 아닌 세션 ID를 저장한다.  서버에서 sessionId를 통해 사용자 정보를 찾을 수 있다.  쿠키값(SessionId)가 노출되더라도 중요한 정보가 들어있지 않다. OAuth:  💡 	Oauth(Open Authorization)	인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단 사용자가 어떤 애플리케이션에 정보를 직접 제공하는 대신에 카카오톡이나 구글과 같은 다른 웹사이트에 있는 자신의 정보를 접근할 수 있도록 하는 것이다.   자원 서버(Resource Server or Service Server) : Client가 제어하고자 하는 자원 보유하고 있는 서버 (클라이언트가 실제로 이용하고자 하는 서버) 인증 서버(Authorization Server) : 클라이언트가 자원 서버의 서비스를 이용할 수 있게 인증하고 토큰을 발생해주는 서버 ex. 구글, 페이스북 등OAuth은 로그인 방법이라기 보다는 말 그대로 사용자 정보를 제공해주는 수단이다. 클라이언트는 Access Token을 통해 인증서버로부터 사용자 정보를 요청할 수 있다. 일반적로 JWT와 함께 사용된다. 이론만 봐서는 session과 함께 사용할수도 있을 것 같지만 따로 저장소를 둘 필요가 없는 JWT가 더 선호되나보다🤔 (JWT에 대해서는 다음 게시글에서 자세히 살펴본다. ) OAuth: 카카오 로그인: OAuth는 인가 코드 발급 → Access Token 발급 → 사용자 정보 제공의 3단계로 이루어진다. 실제 카카오 로그인 기능 구현을 해보며 각 단계별 내용을 알아보자. 카카오 로그인 문서(Rest api) 0. 설정: 카카오 로그인을 사용하기 위해선 코드 작성에 앞서 카카오 developer에 앱을 생성하고, 설정하는 과정이 필요하다. (이 부분을 잘못해서 문제가 자주 발생함…) 그러나 카카오 로그인 문서의 설정하기 페이지에 앞서 필요한 설정들이 상세히 설명돼있다. 따라서 해당 글에서 설명하진 않을 것… 이 블로그 게시글도 많은 도움이 됐다.  이 내용은 단순히 참고용으로 작성해두는데, 나의 경우에는 닉네임과 프로필 사진 정보를 필수동의가 아니라 ‘선택 동의’로 설정할 경우 로그인시 동의화면 페이지가 뜨지 않고 사용자 정보에서 profile이 null로 넘어왔다. 필수동의로 설정을 변경하자 동의화면 페이지도 정상적으로 뜨고 profile 내용도 잘 채워져 전달되었다.  추가적으로, 편의를 위해 Spring Security의 OAuth2를 사용했다. 12345678910111213141516171819spring: security:  oauth2:   client:    registration:     kakao:      client-id: my-client-id      client-secret: my-client-secret      redirect-uri: my-redirect-uri      client-name: Kakao      scope:       - profile_nickname       - profile_image    provider:     kakao:      authorization-uri: https://kauth. kakao. com/oauth/authorize      token-uri: https://kauth. kakao. com/oauth/token      user-info-uri: https://kapi. kakao. com/v2/user/me      user-name-attribute: idSpring Security OAuth2에서 provider로 kakao를 제공하지 않기 때문에 provider직접 작성해야한다. 1. 인가 코드 발급: 사용자 동의(인가)를 구하는 과정이다. 인가 코드 발급에 성공하면 발급받은 코드를 통해 토큰을 발급 받을 수 있다. 기본정보: URI       메서드   URL   인증 방식         GET   https://kauth. kakao. com/oauth/authorize   -   쿼리 파라미터       이름   타입   설명   필수         client_id   String   앱 REST API 키[내 애플리케이션] &gt; [앱 키]에서 확인 가능   O       redirect_uri   String   인가 코드를 전달받을 서비스 서버의 URI[내 애플리케이션] &gt; [카카오 로그인] &gt; [Redirect URI]에서 등록   O       response_type   String   code로 고정   O    client_id: 앱을 생성할때 발급받은 REST_API_KEY redirect_uri: 인가 코드 발급이 성공한 후 해당 uri를 자동 호출한다. 이 외 필수가 아닌 파라미터는 kakao developer 문서를 참고한다. 코드: 12345678910111213141516171819202122Future&lt;void&gt; _signInWithKakao() async {  try {   final clientState = Uuid(). v4();   final url = Uri. https('kauth. kakao. com', '/oauth/authorize',    {     'response_type': 'code',     'client_id': 'rest api key 작성',     'redirect_uri': 'http://localhost:8080/login/oauth2/code/kakao',     'state': clientState,    });   final result = await FlutterWebAuth. authenticate(     url: url. toString(), callbackUrlScheme:  webauthcallback    );   final body = Uri. parse(result). queryParameters;   print(body);  } catch (error) {   print('카카오톡 로그인 실패 $error');  } }flutter 프론트 프레임워크로 flutter를 사용하고 있다. 로그인 버튼을 클릭했을 경우 _signInWithKakao()함수가 실행되도록 프론트 코드를 작성했다. (프론트에서 직접 외부 api를 호출하지 않고 백엔드에서 호출하도록 할까 싶었지만 그러면 api 호출 횟수가 1회 늘어나는 꼴이 되는지라… 그냥 프론트에서 처리하기로 했다. ) client_id 같은 경우는 외부에 노출되어선 안되는 정보기 때문에 env파일 같은 곳에 저장해두기로 하자.  http://localhost:8080/login/oauth2/code/kakao은 토큰 발급용 내부 api uri로, 인가코드 발급이 종료되면 바로 내부 api로 리다이렉트 되도록 했다.  인가 코드 받기 요청의 응답은 HTTP 302 리다이렉트되어, redirect_uri에 GET 요청으로 전달됩니다. 2. 토큰 발급: 기본 정보: URI       메서드   URL   인증 방식         POST   https://kauth. kakao. com/oauth/token   -   쿼리 파라미터       이름   타입   설명   필수         grant_type   String   authorization_code로 고정   O       client_id   String   앱 REST API 키[내 애플리케이션] &gt; [앱 키]에서 확인 가능   O       redirect_uri   String   인가 코드가 리다이렉트된 URI   O       code   String   인가 코드 받기 요청으로 얻은 인가 코드   O       client_secret   String   토큰 발급 시, 보안을 강화하기 위해 추가 확인하는 코드[내 애플리케이션] &gt; [보안]에서 설정 가능ON 상태인 경우 필수 설정해야 함   X   인가 코드 받기 요청의 응답은 redirect_uri에 code 파라미터로 전달된다. redirect된 api에서 토큰 발급 api를 호출하는 것으로 토큰을 발급받을 수 있다. 응답       이름   타입   설명   필수         token_type   String   토큰 타입, bearer로 고정   O       access_token   String   갱신된 사용자 액세스 토큰 값   O       id_token   String   ID 토큰 값   X       expires_in   Integer   액세스 토큰 만료 시간(초)   O       refresh_token   String   갱신된 사용자 리프레시 토큰 값, 기존 리프레시 토큰의 유효기간이 1개월 미만인 경우에만 갱신   X       refresh_token_expires_in   Integer   리프레시 토큰 만료 시간(초)   X      토큰을 받아오는 과정 코드: 1234@GetMapping( /oauth2/code/kakao )public ResponseEntity&lt;LoginResponse&gt; getKakaoToken(@RequestParam( code ) String code) {		return ResponseEntity. status(HttpStatus. OK). body(loginService. getKakaoToken(code));}controller Code도 DTO를 통해 받아올까 생각했는데 어차피 외부 api의 응답값이고, 스펙이 바뀔일은 없을 것 같아서 그냥 파라미터로 받아왔다. 1234public LoginResponse getKakaoToken(String code) {    KakaoTokenResponse tokenResponse = tokenExchanger. getToken(code);    //. . . }service KakaoTokenResponse DTO에는 accessToken과 expiresIn 필드가 존재한다.  expiresIn은 사용하진 않았는데 일단 넣어둠… 12345678910111213141516171819202122232425262728@Component@RequiredArgsConstructorpublic class TokenExchanger {  private final WebClient webClient;  private static final String GRANT_TYPE =  authorization_code ;   @Value( spring. security. oauth2. client. provider. kakao. token-uri )  private String KAKAO_REQUEST_URI;    @Value( ${spring. security. oauth2. client. registration. kakao. client-id} )  private String KAKAO_CLIENT_ID;  @Value( ${spring. security. oauth2. client. registration. kakao. redirect-uri} )  private String KAKAO_REDIRECT_URI;  public KakaoTokenResponse getToken(String code) {    String request_uri =        KAKAO_REQUEST_URI +  ?grant_type=  + GRANT_TYPE +  &amp;client_id=  + KAKAO_CLIENT_ID +  &amp;redirect_uri=             + KAKAO_REDIRECT_URI +  &amp;code=  + code;    Flux&lt;KakaoTokenResponse&gt; response = webClient. post()        . uri(request_uri)        . contentType(MediaType. APPLICATION_FORM_URLENCODED)        . retrieve()        . bodyToFlux(KakaoTokenResponse. class);    return response. blockFirst();  }}utils 토큰 발급 외부 api를 호출하는 코드이다. *주의: Secret값을 사용하고 있지 않은지 확인하자. 사용하고 있다면 uri에 Secret값을 추가해야한다.  외부 api 호출을 위해 webClient를 사용했다. webClient 대신 RestTemplate을 사용할 수도 있는데 webClient가 더 좋아보여서 webClient로… RestTemplate과 WebClient는 나중에 자세히 비교해서 글을 써보려 한다. ‘org. springframework. web. reactive. function. client. WebClient’ that could not be found. 참고로 webClient사용시 위와 같은 오류가 발생할 수 있는데, WebClient에 Bean이 할당되지 못해 발생하는 문제로 아래 설정을 통해 해결할 수있다. 1234567@Configurationpublic class WebConfig {  @Bean  WebClient webClient(WebClient. Builder builder) {    return builder. build();  }} 위 코드를 통해 제공받은 access token은 사용자에게 제공한 token의 일치 여부만 판별할 수 있을 뿐 token 내에 사용자 정보가 담겨있진 않다. 따라서 token을 통해 사용자를 식별하기 위해서는 사용자 정보 가져오기 api를 호출해 사용자 정보를 획득하거나, 사용자 정보를 가져온 다음 session과 같이 저장소에 저장된 사용자 정보를 확인하기 위한 key로 사용하는 수밖애 없다. 반면 JWT는 token 그 자체가 JSON 형식의 정보를 담고 있으며 디코딩을 통해 사용자 정보를 취득 가능하다. JWT에 대해서는 다음 게시글에서 자세히 알아보겠다. 3. 사용자 정보 가져오기: 기본 정보: uri       메서드   URL   인증 방식         GET/POST   https://kapi. kakao. com/v2/user/me   액세스 토큰서비스 앱 어드민 키   요청 헤더       이름   설명   필수         Authorization   Authorization: Bearer ${ACCESS_TOKEN} 인증 방식, 액세스 토큰으로 인증 요청   O       Content-type   Content-type: application/x-www-form-urlencoded;charset=utf-8요청 데이터 타입   O   응답 123456789101112131415161718HTTP/1. 1 200 OK{   id :123456789,   connected_at :  2022-04-11T01:45:28Z ,   kakao_account : {      profile_nickname_needs_agreement	 : false,     profile_image_needs_agreement	 : false,     profile : {       nickname :  홍길동 ,       thumbnail_image_url :  http://yyy. kakao. com/. . . /img_110x110. jpg ,       profile_image_url :  http://yyy. kakao. com/dn/. . . /img_640x640. jpg ,       is_default_image :false,       is_default_nickname : false    },   //. . .   },		//. . . }내가 사용하지 않을 응답값은 생략해두었다. 자세한 응답값은 문서를 참고하자. 코드: 1234567  public LoginResponse getKakaoToken(String code) {    KakaoTokenResponse tokenResponse = tokenExchanger. getToken(code);    KakaoUserInfo userInfo = userInfoFetcher. getKaKaoUserInfo(tokenResponse. accessToken());				//사용자 조회    //jwt 토큰 생성    return new LoginResponse(user. getId(), temp Token );  }service 카카오 서버에 저장된 유저 정보를 가져오는 코드를 추가했다. 이후 이 정보를 기반으로 JWT 토큰을 생성할 것이다. 123456789101112131415161718@Component@RequiredArgsConstructorpublic class UserInfoFetcher {  private final WebClient webClient;  @Value( spring. security. oauth2. client. provider. kakao. user-info-uri )  private String KAKAO_REQUEST_URI;  public KakaoUserInfo getKaKaoUserInfo(String token) {    Flux&lt;KakaoUserInfo&gt; response = webClient. post()        . uri(KAKAO_REQUEST_URI)        . contentType(MediaType. APPLICATION_FORM_URLENCODED)        . header( Authorization ,  Bearer   + token)        . retrieve()        . bodyToFlux(KakaoUserInfo. class);    return response. blockFirst();  }}utils 1234567891011121314151617181920212223242526272829303132333435363738public record KakaoUserInfo(  Long id,  @JsonProperty( kakao_account )  KakaoAccount kakaoAccount) {  public record KakaoAccount(      @JsonProperty( profile_nickname_needs_agreement )      Boolean profileNicknameNeedsAgreement,      @JsonProperty( profile_image_needs_agreement )      Boolean profileImageNeedsAgreement,      Profile profile,      String email,      @JsonProperty( email_needs_agreement )      Boolean emailNeedsAgreement,      @JsonProperty( is_email_valid )      Boolean isEmailValid,      @JsonProperty( is_email_verified )      Boolean isEmailVerified  ){    public record Profile(        String nickname,        @JsonProperty( profile_image_url )        String profileImageUrl,        @JsonProperty( is_default_image )        Boolean isDefaultImage,        @JsonProperty( is_default_nickname )        Boolean isDefaultNickname    ) {}  }}dto 위에서 서술했 듯 ‘동의항목’을 선택으로 설정해두었더니 로그인시 동의항목 화면이 뜨지 않고 바로 Profile이 null로 전달되는 문제가 있었다;필수로 변경하였더니 정상적으로 값이 입력되었다. 🤔 카카오 정보 받아오기 성공 이제 받아온 정보를 가지고 JWT를 생성하는 단계만 남았다. JWT에 대한 정보와 그 과정은 다음 게시글에서…. . 😄 고민거리들: Cors 에러 음? 분명 외부 api를 불러오는 과정에서 Cors 오류가 발생했었는데 갑자기 확장 프로그램을 꺼도 정상 작동한다🤔 Cors가 아니라 코드 문제였을까…. ? 그건 그렇고 외부 api를 호출하면 당연히 Cors가 발생해야할 것 같은데 발생하지 않는 것도 신기하다.  소셜 로그인 확장 현 애플리케이션은 Kakao뿐만 아니라 Google 소셜 로그인 또한 가능하도록 계획돼있다. DTO는 각 소셜 로그인이 제공하는 응답 형태가 다르니 어쩔수 없다 쳐도, 다른 소셜 로그인이 추가될때마다 동일한 기능을 하는 메소드를 각 소셜 로그인 별로 추가하는 건 너무 별로다. 구글 로그인을 추가하면서 한 번 방법을 찾아봐야겠다…  배운 점: 소셜 로그인 기능 하나를 구현하면서 정말 시행착오가 많았다… 특히 코드가 아니라 소셜 로그인 설정에서 생긴 문제가 많았다. (flutter는 할많하않) 그래도 로그인 원리와 그 과정을 알게되니 정말 좋다🥹 "
    }, {
    "id": 29,
    "url": "http://localhost:4000/blog_update5/",
    "title": "24.04.08 블로그 업데이트5",
    "body": "2024/04/08 - 추가 기능: 1. ImageRow width 제한  한 행에 이미지를 정렬하는 ImageRow를 대충 css로 만들어서 쓰고 있었는데 이미지가 3개 이상 정렬되면 body에서 튀어나가는 게 굉장히 거슬렸다.  css가 아닌 js를 사용해 ImageRow 클래스 내에 있는 이미지의 width 총합이 body의 width와 동일하도록하는 로직을 추가했다.  _includes/views/article. html내에 코드를 작성했다. "
    }, {
    "id": 30,
    "url": "http://localhost:4000/test-context/",
    "title": "테스트 컨텍스트(Test Context) 줄이기",
    "body": "2024/04/05 - 개요: 몇달 전 DooRe를 개발하던 중 위와 같은 Discussion이 올라왔다. 위 디스커션과 함께 참고할 게시글을 업로드해주셨는데 내가 백엔드를 공부한지 몇 달 안된터라 완벽한 원리를 이해하진 못했고, 대충 ~가 문제인데 ~를 통해 해결할수 있구나라는 얄팍한 수준으로 이해했었다. 😂 위 Discussion을 간단히 설명하자면 아래와 같이 코드를 수정하자는 말이다.  1234567@WebMvcTest(LoginController. class)public class LoginApiDocsTest extends RestDocsTest {  @MockBean  protected LoginService loginService;    . . . }123456789@Import(RestDocsConfiguration. class)@ExtendWith(RestDocumentationExtension. class)public abstract class RestDocsTest extends ApiTestHelper {  @MockBean  protected LoginService loginService;  . . . 그 외 모킹 대상들. . . 		}LoginApiDocsTest와 같은 RestDocs 테스트 클래스 모두가 상속하는 RestDocsTest 클래스 안에 RestDocs 테스트 클래스에서 필요한 Mocking 객체를 정의하는 것으로 테스트 컨텍스트를 통일시키고, 테스트 컨텍스트를 줄이는 것으로 테스트 시간을 줄이자는 내용이었다. 문제: 우리는 위 디스커션을 받아들여 Mocking 객체를 모두 RestDocsTest 클래스에서 정의하는 식으로 테스트 코드를 작성해왔고, 그동안 별다른 문제점이 지적되지 않았다. 그렇게 몇달 후, 최근 어플리케이션 성능 향상에 대해 공부하며 테스트 컨텍스트 개수가 차이를 직접 비교해보고 싶었다. 마침 두레 프로젝트가 좋은 예제가 되어주었기에 테스트를 실행하여 확인해본 결과….   StudyApiDocsTest에서 생성된 컨텍스트   ParticipantApiDocsTest에서 생성된 컨텍스트  어라…? 각 RestDocs 테스트 클래스에서 테스트 컨텍스트가 생성되고 있었다… 직접 logging. level. org. springframework. test. context. cache: debug 설정을 통해 생성된 컨텍스트 개수를 살펴보자 아래와 같았다. 1[DefaultContextCache@5e9ea380 size = 12, maxSize = 32, parentContextCount = 0, hitCount = 1911, missCount = 12, failureCount = 0]*RestDocs 테스트를 제외한 테스트에서 테스트 컨텍스트가 4개 생성되고, RestDocs 테스트 클래스들이 총 8개니 모든 RestDocs 테스트 클래스에서 테스트 컨텍스트가 생성되고 있던 것이다🙂 애플리케이션 컨텍스트와 테스트 컨텍스트: 문제 해결에 앞서 개념을 살펴보자.   빈 팩토리(Bean Factory)     Spring Bean 컨테이너에 접근하기 위한 최상위 인터페이스   스프링 빈 객체의 생성, 관리, 의존성 주입    애플리케이션 컨텍스트(Application Context)     애플리케이션 Configuration을 제공하는 핵심 인터페이스   Bean Factory를 상속받는다.    스프링 빈 객체의 생성, 초기화, 의존성 주입, 라이프사이클 관리(Bean Factory 기능 상속)   XML, JavaConfig, 어노테이션(@Configuration) 등을 통해 애플리케이션의 환경 설정 정보를 제공, 관리    테스트 컨텍스트 프레임워크(Test Context Framwork)     테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크(ex. JUnit, TestNG)   실제 서버와 거의 동일한 구성으로 동작하는 애플리케이션 컨텍스트를 만들어준다.     테스트 컨텍스트(Test Context)     테스트를 실행할 때 필요한 애플리케이션 컨텍스트를 관리, 제공   애플리케이션 컨텍스트는 스프링 애플리케이션의 전반적인 구성과 런타임 환경을 제어하며, 테스트 컨텍스트는 한마디로 테스트에 사용되는 애플리이션 컨텍스트를 관리해주는 객체이다. 테스트 컨텍스트 캐싱: JUnit은 테스트 메소드를 실행할 때마다 새로운 객체의 테스트 클래스를 생성해 모든 테스트가 독립적으로 실행되도록 만든다. 그러나 테스트가 독립적이기 위해서는 매번 새로운 애플리케이션 컨텍스트가 필요하며, 매번 새로운 빈을 생성하고 의존성을 주입하면 테스트 시간이 지연될 수밖에 없다.  테스트 컨텍스트 캐싱을 통해 위와 같은 문제를 해결할 수 있다. 동일한 테스트 구성을 가지는 테스트끼리 애플리케이션 컨텍스트를 공유하면 새로운 애플리케이션 컨텍스트를 생성하지 않게된다.  위 이미지에선 N개의 테스트가 한 개의 애플리케이션 컨텍스트를 공유하며, 총 2개의 컨텍스트가 생성되게 된다. 원인: 제일 처음에 제시된 디스커션에서 말하는 내용 또한 각 테스트 클래스의 구성을 통일시켜, 테스트 컨텍스트 캐싱을 통해 새로운 애플리케이션 컨텍스트를 생성하지 않도록 만들자는 의미였다. 스프링은 동일 구성이라면 컨텍스트를 재사용하되, 애플리케이션 컨텍스트 내부에 변경이 발생한다면 새로운 애플리케이션 컨텍스트를 생성하도록 한다.  @MockBean @SpyBean @TestPropertySource @ConditionalOnX @WebMvcTest(~. class) @Import 등등…이때 @WebMvcTest(~. class)는 해당 컨트롤러와 관련된 빈들만을 로드하도록 컨텍스트를 제한시키고, @MockBean @SpyBean는 특정 빈을 Mock이 적용된 빈으로 등록하는 것으로 컨텍스트 구성을 변경시킨다.  1234567@WebMvcTest(LoginController. class)public class LoginApiDocsTest extends RestDocsTest {  @MockBean  protected LoginService loginService;    . . . }123456789@Import(RestDocsConfiguration. class)@ExtendWith(RestDocumentationExtension. class)public abstract class RestDocsTest extends ApiTestHelper {  @MockBean  protected LoginService loginService;  . . . 그 외 모킹 대상들. . . 		}문제 원인은 간단했다. @MockBean과 @WebMvcTest 둘 다 새로운 애플리케이션 컨텍스트를 생성하는데 우리는 RestDocsTest에 필요한 모든 모킹 객체를 정의하기만 하고 @WebMvcTest를 추가하지 않은 것이다.  따라서 수정된 코드는 아래와 같다. 123public class LoginApiDocsTest extends RestDocsTest { . . . }123456789101112@Import(RestDocsConfiguration. class)@ExtendWith(RestDocumentationExtension. class)@WebMvcTest({  LoginController. class,  . . . 그 외 빈들을 로드할 컨트롤러. . . })public abstract class RestDocsTest extends ApiTestHelper {  @MockBean  protected LoginService loginService;		. . . 그 외 모킹 대상들. . . }결과: 12345*수정 전 컨텍스트[DefaultContextCache@5e9ea380 size = 12, maxSize = 32, parentContextCount = 0, hitCount = 1911, missCount = 12, failureCount = 0]수정 후 컨텍스트[DefaultContextCache@a1b7549 size = 5, maxSize = 32, parentContextCount = 0, hitCount = 1925, missCount = 5, failureCount = 0]*RestDocs 테스트 클래스가 한개의 애플리케이션 컨텍스트만을 공유하는 것으로 RestDocs 테스트 외에서 생성되는 애플리케이션 컨텍스트 4개 + RestDocs 테스트 클래스들이 공유하는 애플리케이션 컨텍스트 1개 = 총 5개의 컨텍스트로 줄어들었다. 7개의 애플리케이션 컨텍스트가 줄어들은셈…. 👍 또한 테스트 실행시간 또한 11sec 415ms에서 8sec 617ms로 상당히 감소했다😄 만족  배운 점: 어떤 성능문제를 해결한 후에는 성능 차이를 비교, 확인하자…😂 참고:  https://mangkyu. tistory. com/151 https://mangkyu. tistory. com/202 https://mangkyu. tistory. com/244"
    }, {
    "id": 31,
    "url": "http://localhost:4000/false-cors/",
    "title": "가짜 Cors 해결(false cors)",
    "body": "2024/03/30 - 문제: 위와 같은 버그 해결 요청이 들어왔다. 모두 Cors 에러가 발생하며 Allow-Cors를 사용할 시 정상동작하기에 Cors 문제라고 판단되었다. 에러 재현: 로그인 페이지 리다이렉션 요청 씹힘  로그아웃 상태로 홈페이지 접근시 CORS 오류가 발생하며 로그인 화면이 뜨지 않음 메일 인증 요청시 CORS 오류 발생하며 인증 메일이 전송되지 않음        토스트 정상 동작        토스트 Cors 오류 댓글 작성 없이 파일 다운로드 시 떠야하는 토스트 메세지 씹힘 문제를 해결하기 위해 우선 Cors가 무엇인지에 대해 알아보자. Cors?:  Access to XMLHttpRequest at ‘https://api. keeper. or. kr/posts/notices?categoryId=102’ from origin ‘https://keeper. or. kr’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 웹 브라우저는 기본적으로 동일 출처 정책(Same-Origin Policy)을 따르기 때문에 동일한 출처에서 온 스크립트 혹은 요청이 아니면 리소스애 대한 접근을 차단한다. → Cors 오류  💡    Origin  특정 리소스에 접근하는 웹 페이지의 출처로, 프로토콜(protocol), 호스트(host), 포트(port)로 정의된다.     💡    CORS(Cross-Origin Resource Sharing) 란?  웹 브라우저에서 발생하는 보안 정책 중 하나로, 웹 브라우저가 다른 도메인(Origin)의 리소스에 접근할 수 있도록 하는 설정   일반적으로 HTTP header에 추가적인 정보(Access-Control-Allow-Origin)를 추가하여 서버가 브라우저에게 자기 자신뿐만 아니라 다른 origin 에서 요청한 정보도 허용할 수 있도록 알려준다. cors 설정을 통해 필요한 경우에만 다른 출처의 리소스에 접근할 수 있으며, 보안을 강화한다. CORS Preflight: preflight: 브라우저는 요청이 접근 가능한 Origin에서 왔다는 걸 판단하기 위해 CORS Preflight 요청을 보낸다. 해당 Cors preflight값 요청 결과에 따라 브라우저는 본 요청을 서버로 보낼지 혹은 차단할지(Cors error) 결정한다.  preflight 요청: 본 요청이 Simple Request가 아닌 경우 발생 실제 요청: JavaScript 상에서 XMLHttpRequest나 Fetch API 등을 사용한 요청OPTIONS: 이때 Cors preflight 요청으로 OPTIONS가 사용된다. options 요청&amp;응답 예시: 12345678910OPTIONS /resources/post-here/ HTTP/1. 1Host: bar. exampleAccept: text/html,application/xhtml+xml,application/xml;q=0. 9,*/*;q=0. 8Accept-Language: en-us,en;q=0. 5Accept-Encoding: gzip,deflateConnection: keep-aliveOrigin: https://foo. exampleAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-Type12345678910HTTP/1. 1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2. 0. 61 (Unix)**Access-Control-Allow-Origin: https://foo. example**Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginKeep-Alive: timeout=2, max=100Connection: Keep-AlivecURL 테스트: Cors 에러는 브라우저를 통해 발생하는 에러로, 로컬 서버로는 동일한 에러를 재현하기 어렵다. 그러나 방법 중 하나로, 로컬에서 cURL 테스트를 통해 Cors 에러를 확인할 수 있다. 1234567891011121314151617181920212223242526272829 **curl -v -X OPTIONS https://api. keeper. or. kr/sign-up/email-auth -H  Origin: https://keeper. or. kr  -H  Access-Control-Request-Method: POST ; //. . . . . .  &gt; OPTIONS /sign-up/email-auth HTTP/1. 1** &gt; Host: api. keeper. or. kr &gt; User-Agent: curl/8. 1. 2 &gt; Accept: */* **&gt; Origin: https://keeper. or. kr** &gt; Access-Control-Request-Method: POST //응답 **&lt; HTTP/1. 1 200** &lt; Server: nginx &lt; Date: Tue, 26 Mar 2024 07:50:11 GMT &lt; Content-Length: 0 &lt; Connection: keep-alive &lt; Vary: Origin &lt; Vary: Access-Control-Request-Method &lt; Vary: Access-Control-Request-Headers &lt; Access-Control-Allow-Methods: POST &lt; Access-Control-Allow-Credentials: true &lt; X-Content-Type-Options: nosniff &lt; X-XSS-Protection: 0 &lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate &lt; Pragma: no-cache &lt; Expires: 0 &lt; X-Frame-Options: DENY **&lt; Access-Control-Allow-Origin: https://keeper. or. kr** &lt; * Connection #0 to host api. keeper. or. kr left intact 200이 리턴되었다면 Cors에러가 발생하지 않았다는 뜻이다.  Cors는 웹 브라우저에서 시행되는 정책이긴 하나 실제로 Cors에 위반했는지를 판단하는 건 브라우저가 아닌 서버이다. 브라우저는 서버로 Cors 여부를 확인하는 요청인 Cors preflight을 보내고, 요청에 대한 서버의 응답값을 확인한 후 본 요청을 보내거나 차단한다. 따라서 브라우저 없이도 Cors preflight를 서버에 전송할수만 있다면 Cors 여부를 판단할 수 있다. 이때 Cors preflight를 모방하기 위해선 헤더에 반드시 Origin을 작성해야한다. 😯 OPTIONS 명령 없이도 Cors가 발생했는데요?: 위에서 Cors 여부를 판단하기 위해선 본 요청 이전에 예비 요청인 Cors preflight가 필요하다 설명했다. 그러나 사진과 같이 Options 명령 없이도 Cors에러가 발생할 때가 있다. (빨간줄 모두 Get 명령임) Cors preflight가 발생하지 않음에도 Cors 에러를 발생시킬수 있는 경우는 아래 4가지 정도가 있다.  Simple request인 경우 Credentialed Request인 경우 Preflight가 캐싱된 경우 가짜 Cors의 경우Cors preflight가 발생하지 않는 요청: 1. Simle Request: 본 요청이 Simple Request인 경우 preflight(Option 명령)은 발생하지 않는다. 브라우저는 Preflight 응답이 아닌 본 요청의 응답 헤더 Access-Control-Allow-Origin 값을 통해 Cors 정책 위반 여부를 확인한다. Simple Request가 되기 위해서는 아래의 모든 조건을 만족해야한다.    다음 Method 중 하나여야 한다.     GET  HEAD  POST    Connection, User-Agent, or the other headers defined in the Fetch spec as a forbidden header name),와 같이 자동 설정되는 헤더를 제외하고 수동 설정할 수 있는 헤더는 다음으로 제한된다:       Accept    Accept-Language    Content-Language    Content-Type(아래 내용 참고)    Range (only with a simple range header value; e. g. , bytes=256- or bytes=127-255)       Content-Type header의 값은 다음으로 제한된다.        application/x-www-form-urlencoded    multipart/form-data    text/plain      위와 같은 조건을 보면 알겠다 싶이 거의 대부분의 요청은 Simple Request가 아니다.  12345678910111213141516171819GET /resources/public-data/ HTTP/1. 1Host: bar. otherUser-Agent: Mozilla/5. 0 (Macintosh; Intel Mac OS X 10. 14; rv:71. 0) Gecko/20100101 Firefox/71. 0Accept: text/html,application/xhtml+xml,application/xml;q=0. 9,*/*;q=0. 8Accept-Language: en-us,en;q=0. 5Accept-Encoding: gzip,deflateConnection: keep-aliveOrigin: https://foo. exampleHTTP/1. 1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache/2**Access-Control-Allow-Origin: https://foo. example**Keep-Alive: timeout=2, max=100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application/xml[…XML Data…]2. Credentialed Request: 보안상 이유로 출처가 다른 경우 사용자 인증 정보를 담은 요청을 Cors를 통해 브라우저상에서 제한하고 있다. 사용자 인증 정보를 다른 출처의 서버로 전송하기 위해선 Credentialed Request를 사용해야한다.  서버와 클라이언트(백엔드 프론트) 양측의 Credentialed Request 설정이 필요하다.  123456789101112131415161718192021222324252627GET /resources/credentialed-content/ HTTP/1. 1Host: bar. otherUser-Agent: Mozilla/5. 0 (Macintosh; Intel Mac OS X 10. 14; rv:71. 0) Gecko/20100101 Firefox/71. 0Accept: text/html,application/xhtml+xml,application/xml;q=0. 9,*/*;q=0. 8Accept-Language: en-us,en;q=0. 5Accept-Encoding: gzip,deflateConnection: keep-aliveReferer: https://foo. example/examples/credential. htmlOrigin: https://foo. example**Cookie: pageAccess=2 //사용자 인증 정보를 담은 요청**HTTP/1. 1 200 OKDate: Mon, 01 Dec 2008 01:34:52 GMTServer: Apache/2Access-Control-Allow-Origin: https://foo. example**Access-Control-Allow-Credentials: true**Cache-Control: no-cachePragma: no-cacheSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMTVary: Accept-Encoding, OriginContent-Encoding: gzipContent-Length: 106Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain[text/plain payload]3. Preflight 캐싱: 모든 요청에 대해 예비 요청이 함께 발생시키는 것은 서버에 부담을 주고 실제 요청까지 걸리는 시간을 잡아먹는다. 따라서 Preflight의 캐싱을 통해 서비스의 성능 향상을 향상시킬 수 있다. preflight 응답에 다음 헤더를 추가하는 것으로 preflight를 캐싱할 수 있다. 1Access-Control-Max-Age: 360012345678 public void addCorsMappings(CorsRegistry registry) {  registry. addMapping( /** )    . allowedOrigins( https://keeper. or. kr ,  https://localhost:3000 )    . allowedMethods( GET ,  POST ,  PUT ,  PATCH ,  DELETE ,  OPTIONS )    . allowedHeaders( headers )    . **maxAge(3000);** }캐싱된 시간동안은 새로운 Options 요청이 발생하지 않으며, 캐싱된 Options 응답값을 사용한다. 4. 가짜 Cors: Options 명령이 발생하지 않는 3가지 경우에 대해 습득했다. 해당 내용을 기반으로 발견한 오류에 대해 다시 살펴보자.  Options 명령이 발생하지 않았고, Cors error가 발생했다. 이때 3가지 경우를 살펴볼 수 있다.  Simple request인가?     GET, HEAD, POST 메서드 중 하나인가?: true       적절한 요청 헤더를 가지고 있는가? : False              Credentialed Request인가?   응답 헤더에 Access-Control-Allow-Credentials가 true로 설정되어있기는 하나, 요청 헤더에 달리 사용자 인증 정보가 담겨있지 않다. 무엇보다 일단 프론트 쪽에서 Credentialed Request 설정이 되어있지 않아 Credentialed Request 요청이 아니다.   12345678 const useGetPostListQuery = ({ categoryId, searchType, search, page, size }: BoardSearch) =&gt; {  const fetcher = () =&gt;   axios. get('/posts', { params: { categoryId, searchType, search, page, size } }). then(({ data }) =&gt; data);    return useQuery&lt;BoardPosts&gt;(['posts', categoryId, searchType, search, page, size], fetcher, {   keepPreviousData: true,  }); };      Preflight가 캐싱 돼 있는가?   12345678  public void addCorsMappings(CorsRegistry registry) {   registry. addMapping( /** )     . allowedOrigins( https://keeper. or. kr ,  https://localhost:3000 )     . allowedMethods( GET ,  POST ,  PUT ,  PATCH ,  DELETE ,  OPTIONS )     . allowedHeaders( headers )     . **maxAge(3000);**  }      다음과 같이 preflight 캐싱 정보가 포함되어 있긴 하나 최초 요청에서도(혹은 설정된 Access-Control-Max-Age 이후에도) Preflight를 확인하지 못했다.  결과적으로 해당 에러는 위의 모든 경우와 일치하지 않았다. 그럼 뭐란 걸까? 세상에는 가짜 Cors 라는 것이 있다: 일단 Options 명령이 발생하지 않았으니 cUrl 테스트를 통해 Preflight 요청을 보내보자. 1234567891011121314151617181920212223242526272829 **curl -v -X OPTIONS https://api. keeper. or. kr/sign-up/email-auth -H  Origin: https://keeper. or. kr  -H  Access-Control-Request-Method: POST ; //. . . . . .  &gt; OPTIONS /sign-up/email-auth HTTP/1. 1** &gt; Host: api. keeper. or. kr &gt; User-Agent: curl/8. 1. 2 &gt; Accept: */* **&gt; Origin: https://keeper. or. kr** &gt; Access-Control-Request-Method: POST //응답 **&lt; HTTP/1. 1 200** &lt; Server: nginx &lt; Date: Tue, 26 Mar 2024 07:50:11 GMT &lt; Content-Length: 0 &lt; Connection: keep-alive &lt; Vary: Origin &lt; Vary: Access-Control-Request-Method &lt; Vary: Access-Control-Request-Headers &lt; Access-Control-Allow-Methods: POST &lt; Access-Control-Allow-Credentials: true &lt; X-Content-Type-Options: nosniff &lt; X-XSS-Protection: 0 &lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate &lt; Pragma: no-cache &lt; Expires: 0 &lt; X-Frame-Options: DENY **&lt; Access-Control-Allow-Origin: https://keeper. or. kr** &lt; * Connection #0 to host api. keeper. or. kr left intact🤔 성공적으로 200 ok를 반환했다. 이 뜻은 무엇이냐 하면, 브라우저는 Cors 에러가 발생했다고 인지했으나 실제로는 Cors가 발생하지 않은 것이다. (아님 내가 뭘 잘못하고 있거나) 어떻게 이런 일이 가능한 걸까? 인터넷을 뒤져보니 위와 같은 경우에 대한 글을 몇가지 찾을 수 있었다: What is CORS? Misleading CORS Errors – Dev Notes CORS: Why do I get successful preflight OPTIONS, but still get CORS error with post? CORS, Preflight, 인증 처리 관련 삽질 false cors, misleading cors 등 서로 다른 용어를 사용하는 거 보니 통일된 용어가 없어서 서치가 힘들었던 모양… Cors가 처리되기 전에 중간 레이어에서 오류가 발생하는 경우, Cors 처리 전에 미들웨어가 종료되는 경우 등등 원인은 다양했으나 결국 모두 어떤 에러 전에 헤더에 Cors가 추가되지 않았기 때문에 브라우저가 이를 Cors로 판단해 발생하는 문제다. keeper의 코드 상 Cors 코드는 정상적으로 작성되어 있기에 처음에는 필터 체인의 순서 문제라 생각했다. 그러나 이후 필터 체인에서도 인증 처리 이전에 Cors가 처리됨을 확인했다. 문제 원인은 3가지로 예상했다.  인프라 설정 문제 프론트에서 origin 헤더 담아 보내주기 프론트에서의 credential request 설정그러나 Cors는 대부분 프론트에서 뭘 만진다고 해결되는 문제가 아니기 때문에 2번은 아닐거라 예상했고, 3번 또한 해당 요청이 credential request가 맞는데 내가 잘못 판단한 경우를 고려한 해결방법이었다. 인프라 설정을 직접 확인하고 싶었으나 해당 프로젝트는 우리 동아리에서 다른 동아리 홈페이지를 관리하는 프로젝트였기 때문에 보안 문제상 인프라 접근이 제한되어 확인이 어려웠다…🥲 문제 해결: 위와 같은 결과 보고를 하고 얼마 뒤, Cors 오류가 해결되었다는 이야기를 전해들었다. NginX 설정이 원인이었다! 12345678910111213141516location / {  proxy_pass http://spring;  proxy_http_version 1. 1;  proxy_set_header Host $host;  proxy_set_header X-Real-IP $remote_addr;  proxy_hide_header Access-Control-Allow-Origin;  add_header 'Access-Control-Allow-Origin' 'https://keeper. or. kr' **always**;  add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization' **always**;  add_header 'Access-Control-Allow-Methods' 'GET, POST, DELETE, PATCH, OPTIONS' **always**;  # add_header 'Access-Control-Allow-Origin' 'https://api. keeper. or. kr';  # add_header 'Access-Control-Allow-Origin' '*';  # add_header 'Access-Control-Allow-Origin' 'https://localhost:3000';  limit_req zone=keeper_req burst=5 nodelay;  limit_conn keeper_conn 10;  limit_req_log_level error;}기존 NginX 코드에서 always가 없었던 부분이 문제였다. always가 없으면 400, 500번대 에러가 발생할시 Header에 Cors 설정값이 추가되지 않는다. always를 추가함으로써 응답 코드와 상관없이 항상 header에 cors 설정이 들어가게 된다. Security 필터에서 발생한 401에러로 인해 Cors 설정이 되지 않아 Cors 에러가 발생한 듯하다.   후기: 정말로 이제는 인프라 공부를 하자…. 그래도 이번 기회로 Cors에 대해 빡세게 공부한 거 같다😄 "
    }, {
    "id": 32,
    "url": "http://localhost:4000/pagenation-size/",
    "title": "페이지네이션 크기(Size) 제한",
    "body": "2024/03/18 -  문제: 12345678910 @GetMapping( /members/{memberId} ) public ResponseEntity&lt;Page&lt;MemberPostResponse&gt;&gt; getMemberPosts(   @PathVariable long memberId,   @RequestParam(defaultValue =  0 ) @PositiveOrZero int page,   @RequestParam(defaultValue =  10 ) @PositiveOrZero int size ) {  Page&lt;MemberPostResponse&gt; responses = postService. getMemberPosts(memberId,    PageRequest. of(page, size, Sort. by(DESC,  registerTime )));  return ResponseEntity. ok(responses); }위와 같이 page가 매핑 코드에서 size값의 크기를 제한해달라는 요청이 들어왔다. 위 코드에서 page는 page 번호, size는 한 페이지에서 불러올 데이터의 개수이다. 만일 size의 크기를 제한하지 않는다면, 클라이언트에서 size에 매우 큰 값을 넣어 요청할 경우 응답 시간이 지연되고 서버 부담이 커지기 때문에 요청 가능한 최대 size를 설정하는 것이 좋다. 해결: max-page-size를 통해 요청가능한 page 최대 size를 yml 파일 내에 설정할 수 있다.       Name   Description   default value         spring. data. web. pageable. max-page-size   Maximum page size to be accepted.    2000   12345 data:  web:   pageable:    max-page-size: 100     default-page-size: 10기본적인 Page 크기를 10, 최대 Page 크기를 100으로 설정했다. 1234567891011121314151617181920212223242526272829303132 @Test @DisplayName( 페이지네이션 최대 사이즈를 넘은 요청은 최대 사이즈로 요청된다.  ) public void 페이지네이션_최대_사이즈를_넘은_요청은_최대_사이즈로_요청된다() throws Exception {  //given  final int MAX_PAGE_SIZE = 100;  List&lt;Post&gt; posts = IntStream. rangeClosed(1, 101)    . mapToObj(i -&gt; Post. builder()      . title( title )      . content( ABCD )      . member(memberTestHelper. generate())      . category(category)      . visitCount(10)      . ipAddress(WebUtil. getUserIP())      . allowComment(true)      . isNotice(false)      . isSecret(false)      . isTemp(false)      . password( asdf )      . thumbnail(thumbnailTestHelper. generateThumbnail())      . build())    . toList();  postRepository. saveAll(posts);  Pageable pageable = PageRequest. of(0, 101);    //when  Page&lt;PostResponse&gt; foundPosts = postService. getPosts(category. getId(),  title+content ,  bc , pageable);    //then  assertThat(foundPosts). hasSize(MAX_PAGE_SIZE); }설정이 잘 적용되었는지 확인하기 위해 service단에 테스트 코드를 작성했다. 정상적으로 작동한다면 테스트 코드에서 size로 101을 입력하여도 결과 size는 100으로 반환되어야 한다. 에러 발생: java. lang. AssertionError: Expected size: 100 but was: 101 in 적용이 안된다… 단순히 yml에 설정을 추가하는 것이니 안될 거라곤 전혀 예상하지 못했다. 설정 자체가 틀렸거나 수정된 yml 파일이 적용이 안된 경우를 고려하여 직접 WebMvcConfiguration에 로직을 추가해보기도 했으나(아래 코드) 이 또한 적용되지 않았다. 1234567@Overridepublic void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) { PageableHandlerMethodArgumentResolver pageableHandlerMethodArgumentResolver = new PageableHandlerMethodArgumentResolver(); pageableHandlerMethodArgumentResolver. setMaxPageSize(100); resolvers. add(pageableHandlerMethodArgumentResolver); resolvers. add(loginMemberArgumentResolver);}아래로는 문제의 원인을 해결하기 위해 어떤 뻘짓을 했는지 서술할 것이다. 구조: yml 파일의 max-page-size 설정을 타고 내려가보면 위와 같은 클래스들을 밟을 수 있다. 123	public void setMaxPageSize(int maxPageSize) {		this. maxPageSize = maxPageSize;	}SpringDataWebProperties에서 yml 설정으로 저장된 maxPageSize가 적용되고, PageableHandlerMethodArgumentResolverCustomizer는 getMaxPageSize 메서드를 통해 저장된 maxPageSize를 가져온다. 1234567891011121314@Bean@ConditionalOnMissingBeanpublic PageableHandlerMethodArgumentResolverCustomizer pageableCustomizer() {	return (resolver) -&gt; {		Pageable pageable = this. properties. getPageable();		resolver. setPageParameterName(pageable. getPageParameter());		resolver. setSizeParameterName(pageable. getSizeParameter());		resolver. setOneIndexedParameters(pageable. isOneIndexedParameters());		resolver. setPrefix(pageable. getPrefix());		resolver. setQualifierDelimiter(pageable. getQualifierDelimiter());		resolver. setFallbackPageable(PageRequest. of(0, pageable. getDefaultPageSize()));		**resolver. setMaxPageSize(pageable. getMaxPageSize());**	};}PageableHandlerMethodArgumentResolverCustomizer는 PageableHandlerMethodArgumentResolver의 설정을 커스텀하는 인터페이스로, resolver. setMaxPageSize(pageable. getMaxPageSize());을 통해 PageableHandlerMethodArgumentResolverSupport의 setMaxPageSize 메서드가 실행된다. 123public void setMaxPageSize(int maxPageSize) {	this. maxPageSize = maxPageSize;}디버깅: 우선 정상적으로 설정값이 변경되었나 확인하기 위해 PageableHandlerMethodArgumentResolverSupport의 setMaxPageSize 메서드에 브레이크를 걸었다.  2000(디폴트 값)으로 설정돼있던 maxPageSize가 정상적으로 100으로 변경된 것을 확인할 수 있었다. 따라서 PageableHandlerMethodArgumentResolverSupport를 상속받고 있는PageableHandlerMethodArgumentResolver 에서 초기화가 발생해 설정값이 덮어씌워진 것으로 예상했다.  따라서 PageableHandlerMethodArgumentResolver의 pageSize를 설정하는 메서드에 브레이크를 걸었으나 브레이크가 걸리지 않고 그대로 테스트가 종료되었다.  Pageable의 설정은 변경되었으나 어떠한 이유로 PageableHandlerMethodArgumentResolver의 메서드가 실행되지 않아 설정 값으로 Pageable이 설정되지 않은 것으로 판단했다. 원인:  Extracts paging information from web requests and thus allows injecting Pageable instances into controller methods. 😄… PageableHandlerMethodArgumentResolver는 페이징 정보를 추출하여 Pageable 인스턴스를 컨트롤러 메서드의 파라미터에 주입하는 클래스였다. 무슨 뜻이냐 하면 설정 자체는 정상적으로 적용되었으나 Service 계층에서 실행된 test 코드는 Controller 코드를 거치지 않기 때문에 Pageable 값이 설정되지 않는다는 뜻이다. 나는 바보… 최종 해결: 참고로 PageableHandlerMethodArgumentResolver는 Controller의 Pageable 매개변수를 주입하는 코드이므로, Controller 매개변수에 size page가 아닌 Pageable을 사용해야한다. 12345678910 @GetMapping public ResponseEntity&lt;Page&lt;PostResponse&gt;&gt; getPosts(   @RequestParam long categoryId,   @RequestParam(required = false) String searchType,   @RequestParam(required = false) String search,   @RequestParam(defaultValue =  0 ) @PositiveOrZero int page,   @RequestParam(defaultValue =  10 ) @PositiveOrZero int size ) {  return ResponseEntity. ok(postService. getPosts(categoryId, searchType, search, PageRequest. of(page, size))); }따라서 이전 코드는 위와 같았으나 123456789 @GetMapping public ResponseEntity&lt;Page&lt;PostResponse&gt;&gt; getPosts(   @RequestParam long categoryId,   @RequestParam(required = false) String searchType,   @RequestParam(required = false) String search,   @PageableDefault Pageable pageable ) {  return ResponseEntity. ok(postService. getPosts(categoryId, searchType, search, pageable)); }다음과 같이 수정해주었다. 123456789101112131415161718 @DisplayName( 최대 제한값을 초과한 size가 요청될 시 size는 최대 제한값으로 설정된다.  )  public void 최대_제한값을_초과한_size가_요청될시_size는_최대_제한값으로_설정된다() throws Exception {   final int max_size = 100;   params. add( categoryId , String. valueOf(category. getId()));   params. add( searchType , null);   params. add( search , null);   params. add( page ,  0 );   params. add( size ,  1000 );   callGetPostsApi(memberToken, params)     . andExpect(status(). isOk()). andReturn();   ArgumentCaptor&lt;Pageable&gt; pageableCaptor = ArgumentCaptor. forClass(Pageable. class);   verify(postService). getPosts(any(Long. class), any(), any(), pageableCaptor. capture());   Pageable capturedPageable = pageableCaptor. getValue();   assertEquals(max_size, capturedPageable. getPageSize());  }테스트 코드도 Service단이 아닌 Controller 단으로 옮겨주었다. 아쉬운 점이 있다면 json 필드 값 확인으로 바로 size를 확인하고 싶었는데 응답 json을 page로 매핑하는 방법을 모르겠어서 전달된 pageable 인자를 캡쳐하는 식으로 테스트 했다…  배운 점: Spring 내부 인터페이스와 클래스에 대한 이해도를 높이자~ "
    }, {
    "id": 33,
    "url": "http://localhost:4000/building-BDD/",
    "title": "[BDD] 개발 동아리 만들기 (feat. Brighten Developer Domain)",
    "body": "2024/01/10 - BDD가 만들어지기까지:  동아리 노션 나는 보안에 큰 뜻이 없지만 대학 신입생 시절부터 모교의 보안 동아리에서 활동했다. 보안에 열정적이지 않았음에도 활동 회원이라면 반드시 해야하는 발표와 기술문서를 매년 수행하며 4년(정확히는 3년 반)의 기간동안 보안 동아리에 속해있던 이유라고 하면, 우리 학교에 있는 기타 다른 개발 동아리보다 해당 보안 동아리에 개발 인재가 많았기 때문이다. 어쩨서 보안 동아리가 풍부한 개발 환경을 가지고 있는가? 사정은 많았지만 축약해서 말하자면 우리 학교에는 개발 공부를 지원해줄만한 환경이 부족했다. 비록 보안동아리에서 활동하고 있었으나, 우리는 개발 스터디를 통해 자신의 분야에 대해 배울 수 있었고, 동아리 홈페이지 제작이라는 큰 프로젝트를 함께할 수 있는 좋은 기회 또한 얻을 수 있었다. 그러나 동아리가 ‘보안 동아리’의 정체성을 굳히기 시작하면서 문제가 생겼다. 정체성을 확실히 하는 것이 나쁜 것은 아니기에 그 정체성에 반하는 ‘개발’에 대한 지원과 관심이 점차 줄어드는 점은 어쩔 수 없었다고 생각한다. 하지만 우리는 개발 공부를 할 곳이 필요했다!: 그러나 본교에는 개발자들을 위한 체계와 매력적인 활동이 마련된 곳이 마땅히 없었다. 그렇다면 우리가 만드는 수밖에 없다. 그렇게 만들어진 동아리가 BDD(Bright Developer Domain)이다. 임원진 셋이 함께 기획하고, 주변 인물들을 끌어모아 완성된 웹 개발자와 디자이너들을 위한 커뮤니티이다. BDD에 대한 본격적인 기획이 시작된 것이 2023년 9월 초이고, 현재 2024년 1월 초이니 벌써 만들어진지 5개월이 지났다. 그동안 총 5개의 스터디가 열렸고, 2개의 프로젝트가 진행 중이며, 첫 번째 세미나가 다가오는 2월에 개최될 예정이다. 처음에는 회원과 임원진에게 모두 잊혀진 동아리가 될까 두려움도 있었으나 결과적으로 어느정도 성장한 동아리가 된 것 같아 안심이다. 이렇게 동아리가 커질 수 있었던 건 다른 두 명의 임원진의 역할이 컸다. 그 둘에게 매우 감사하고 있다. 개발자 동아리, 혹은 커뮤니티를 생각하고 있는 사람들을 위해 BDD가 무엇에 집중했는지에 대해 작성해볼까 한다. 참고로 BDD는 대학교 공식 동아리가 아니기에(공식 동아리 등록을 고려 중이다. ) 대학교 동아리 등록과 관련된 지식은 전달할 수 없다는 점을 먼저 밝힌다.  적극적이고 열정있는 임원진: BDD 개설에 대한 논의는 8월부터 이야기 되었으나 사실 그 이후 대략 한 달간은 방치되었다. 임원진 세명이 모두 학교와 부트캠프 활동 때문에 바빴고, 함께 모일 기회가 없었기 때문이다. 이대로는 영영 잊혀질 것이 뻔했기 때문에 임원진 셋은 매주 동아리 기획 회의를 진행하기로 결정했다. 열정적인 임원진들 덕분에 매 기획 회의에서 새로운 안건이 논의되었고, 그를 기반으로 동아리의 틀을 잡아갔다. 동아리의 방향성 또한 수십번씩 바뀌었다. 어느 정도 동아리의 모양이 잡힌 지금도 회의에는 항상 1시간 30분 정도의 시간이 소요된다. 그만큼 임원진들이 동아리에 많은 관심과 시간을 투자하고, 동아리의 방향에 대해 고민하고 있기에 BDD가 지금만큼 성장할수 있었다고 생각한다. 이는 정말로 다른 두 명의 임원진들의 덕이 컸다. BDD 기획 과정에 대해서는 아래 팀블로그 포스팅에 훌륭하게 설명되어 있으니 궁금한 사람은 읽어보길 바란다. 개발 소모임 ‘BDD’를 만들게 된 과정 회원들의 참여를 유도하라: 걱정했던 것과 달리 초기 동아리 인원은 쉽게 모아졌다. 오히려 주변에서 가입 요청이 들어올 정도… 이들은 이전에 언급한 보안 동아리에서 활동하던 개발자들이기도 했다. 이런 초기 동아리, 혹은 그룹에서 가장 두려워하고 경계해야 하는 것은 참여자들에게 잊혀지는 것이라 생각한다. 잊혀진다는 것은 동아리로써의 신뢰성을 잃는다는 것과 일맥상통한다. 아직 동아리 이름을 건 활동이 아무것도 이루어지지 않은 지금, 회원은 자신의 시간을 투자할만큼 동아리를 신뢰할 이유가 없고, 그럴수록 회원에게 잊혀진다는 건 타격이 크다. 설명회: 동아리 초기 인원들은 모두 입소문 혹은 임원진들에게 직접 간단한 설명만을 듣고 가입한 사람들로, 동아리의 정체성을 확실히 하기 위해선 이들에게 BDD가 정확히 어떤 동아리인지 설명할 필요가 있었다. 따라서 회원들에게 BDD와 그 내부에서 이루어지는 활동에 대해 설명하기 위한 설명회를 준비했다.  슬랙 활성화: 동아리에 회원들의 관심을 유지시키는 것은 힘든 일이다. BDD는 기획이 한창 진행되는 중인 동아리었고, 회원들이 BDD의 이름을 걸고 할만한 활동이 완성되지 않았다. 이런 상황에서 회원들에게 BDD를 인식시키기 위한 제일 좋은 방법은 BDD 슬랙의 주기적인 접속이라 생각했다. 매주 임원진 회의를 통해 새로운 결정사항에 대한 공지가 올라오긴 했으나 임원진측의 일방적인 메세지로는 접속률을 기대하기 어려웠다. 그리고 의미있는 활동률을 만들기 위해선 회원이 직접 메세지를 올려야 한다 생각했다. 따라서 BDD의 첫번째 공식 활동으로 챌린지가 시작됐다.  첫번째 챌린지로 글쓰기 챌린지와 갓생(생활 규칙 만들기) 챌린지 두 가지가 열렸다. 그 중 내가 진행한 갓생 챌린지는 메세지와 사진으로 자신의 목표를 인증하는 형태로, 인증을 하기 위해선 BDD 슬랙에 접속해 직접 메세지를 남겨야 했다. 게더: 또한 BDD 전용 게더를 생성해 BDD만의 온라인 공부 공간을 만들었다. 물론 접속하는 사람만 접속하곤 했으나 고정 접속 회원을 만든 것만으로도 의미가 있었다. 참고로 게더-왔다감 채널을 통해 다른 회원들의 접속 상황을 알수 있도록 했는데 상당히 좋아 추천한다.  회원들의 공통 목표를 만들어라: 당연하지만 위에 설명한 활동들은 BDD의 메인코스가 아니다. 임원진들이 BDD를 개설한 목적은 ‘프로젝트’였다. 프로젝트를 성공적으로 완성하기 위해 신뢰할 수 있는 동료들을 만날 수 있는 곳으로 만들고싶었다. 동아리 운영에 대한 조언을 얻기 위해 교수님과 BDD 임원진(+회원 한 분)끼리 미팅을 가진 적이 있는데, 이때 강조받았던 것이 동아리원 공동의 목표이다. 하나의 목표를 가지는 것으로 동아리원들의 소속감뿐만 아니라 동아리의 매력 또한 얻을 수 있다는 것이다. 또한 교수님께 들은 비판점 중 하나가 명확한 목표 없는 광범위한 활동을 경계하란 부분이었다. BDD의 개설 목적이 프로젝트이긴 했으나, 프로젝트 외로도 꽤 많은 양의 활동(세미나, 스터디, 기술문서 등등)이 존재하고 있었기 때문이다. 당연하게 BDD의 목표는 프로젝트 런칭이 되었다. 프로젝트를 동아리의 주 목표로 잡은 만큼 그에 더 많은 시간과 관심을 쏟고 있다. 실제로 프로젝트 기획을 시작한 이후로 본격적인 동아리로 활동하고 있다는 느낌을 강하게 받는다. 그것이 꼭 프로젝트가 아니더라도 동아리를 하나로 유지하기 위해선 동아리원들이 바라볼 하나의 목표가 중요하다 생각된다. 어쩌면 대회 입상일 수도 있겠고, 동아리 홈페이지 제작이 될 수도 있겠다. 이후 프로젝트가 종료된 뒤 교수님과의 미팅 내용과 실제 프로젝트 진행 경험을 비교하며 글을 써보고 싶다.  개발자 외 인원을 배려하라: 디자이너와 협업하는 경우 개발자의 사고를 멀리해야한다. BDD는 개발자뿐만 아니라 디자이너와 함께 꾸려나가는 동아리를 목표로 하나, 동아리를 구성하는 임원진 셋은 모두 개발자이다. 동아리를 기획하며 여러 아이디어를 실천에 옮겼으나 사실 프로젝트가 시작하기 전까지 디자이너가 참가할만한 활동이 마땅하지 않았다. 짧게 말해서 BDD는 디자이너들을 방치하고 있었다… 이를 해결하기 위해 임원진 회의에서 열심히 머리를 굴려보았으나 결론적으로 디자이너를 위한 활동은 개발자가 생각할게 아니라는 답이 나왔다. 따라서 디자이너를 위해 BDD에서 무엇을 할 수 있을지 얘기하기 위해 디자이너 두 분에게 대면 모임을 요청드렸다. 이 모임에서 임원진과 디자이너가 직접 만나 궁금했던 사항을 직접 질답하며 많은 의문점이 해소되었다. 물론 지금껏 디자이너를 위한 활동을 준비하지 못한 점에 대해서도 사과드렸다. 아래는 위 모임에서 여쭤본 질문들이다.     한 번에 처리할 수 있는 작업량은은 어느 정도가 적당한가  작업 기간은 어느 정도가 적당한가  웹 디자인 외로도 BDD 내부에서 필요한 디자인을 작업해도 괜찮은가  디자이너 커뮤니티에서도 개발자 커뮤니티처럼 기술문서와 세미나 발표를 하는가  팀 블로그를 작성할수 있는가  어떻게 하면 디자이너들에게 매력적인 동아리가 될 수 있을까  덕분에 개발자와 디자이너들 간 공부 지향점에 대한 차이를 알게 되었고 작업물을 맡길 때에 대한 규칙을 결정할 수 있었다. 꼭 디자이너와 개발자간의 관계에만 국한된 이야기는 아니지만, 개발자가 다수로 이루어진 그룹에서 개발자 외 사람들 소수와 작업할 때 개발자 중심적 사고로 팀을 이끌지 않도록 항상 주의해야한다. 마찰없이 팀을 이끌고 싶고, 다음에 그들과 또 다시 함께 일하고 싶다면 다른 사람들보다 더 신경써주고, 항상 감사하다는 말을 직접 전하자. 혹자는 굳이 그렇게 해서까지(개발자 회원보다 더 많은 신경을 쓰면서까지) 해야하나? 생각할지도 모르겠다. 그러나 사실 이 부분은 개발자에 국한된 이야기가 아니라, 자신과 다른 분야의 사람과 함께 일한다면 당연하게 해야하는 일이라 생각한다. 무엇보다 프로젝트는 개발자들끼지 진행하는 것이 아니기 때문에, 우리가 그들을 배려하는 만큼 그들이 자신이 맡은 일에 더 최선을 다하지 않을까, 하고 생각한다. 아래는 BDD의 디자이너분들이 만들어주신 작업물 중 일부다😄 "
    }, {
    "id": 34,
    "url": "http://localhost:4000/backJoon-hideAndSeek/",
    "title": "[BFS] 백준 1697- 숨바꼭질",
    "body": "2023/12/29 - 백준 숨바꼭질 문제: 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다. 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오. 입력: 첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다. 출력: 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.  문제를 읽고 위와 같은 Tree를 떠올렸다. 하나의 부모 노드가 2배, -1, +1의 값을 지니는 세개의 자식 노드를 가지는 형태의 트리이다. (이미 존재하는 노드와 동일한 값을 가지는 자식노드는 가지치기 했다. )위 트리를 탐색하며 K값을 가지는 노드를 찾으면 된다고 생각했다. 트리는 무한으로 이어지기에 DFS가 아닌 BFS를 사용해 Tree를 탐색했다. 총 탐색할 노드의 개수는 최대 100,001개로 O(100,001)의 시간복잡도가 소요된다. 첫번째 코드: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node {  int x;  int y;  public Node(int x, int y) {    this. x = x;    this. y = y;  }  public int getX() {    return x;  }  public int getY() {    return y;  }}public class Main {  static int k;  public static void main(String[] args) {    Scanner sc = new Scanner(System. in);    int n = sc. nextInt();    k = sc. nextInt();    System. out. println(bfs(n));  }  private static int bfs(int n) {    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();    List&lt;Integer&gt; visitedNode = new ArrayList&lt;&gt;();    q. offer(new Node(n, 0));    int result = 0;    while (!q. isEmpty()) {      Node node = q. poll();      int x = node. getX();      int y = node. getY();      if (x &gt; 100_000 || x&lt;0) {        continue;      } //범위를 벗어나는 경우      if (visitedNode. contains(x)) {        continue;      } //이미 방문한 노드인 경우      if (x== k) {        result = y;        break;      } //K를 찾은 경우      visitedNode. add(x);      q. offer(new Node(x * 2, y + 1));      q. offer(new Node(x + 1, y + 1));      q. offer(new Node(x - 1, y + 1));    }    return result;  }}위 코드의 제출 결과 시간 초과가 발생했다. 본 문제의 시간 제한은 2초로, 대략 20,000,000번 내의 탐색이 진행될 경우 통과 가능할 터였다. 방문 가능한 노드의 범위를 0&lt;= x &lt;= 100,000으로 제한했기에 탐색하는 노드는 모두 100,000 내의 노드였을 터이기 때문에 중복 노드가 발생했다고 짐작할 수 있다. 코드를 다시 보면 일반적인 BFS 탐색 순서와 틀린 부분이 있음을 확인할 수 있다.     BFS 전개 과정 일반적인 BFS는 해당 노드를 방문한 이후 step에서 노드를 poll하고, poll한 자식노드를 방문 노드로 저장한다. 그러나 위 코드는 노드를 poll함과 동시에 방문 노드로 저장하며, 그 자식 노드들은 방문 노드에 저장하지 않는다. 따라서 위 코드의 방문 Tree 상태가 위 이미지와 같다 판단했다. 물론 이런 트리 형태라고 해도 최대 N 개수가 100,000개니 중복이 된다 해도 20,000,000개를 넘기 힘들지 않나? 생각했으나…ㅎㅎ 잘 모르겠다~ 정답 코드: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Node {  int x;  int y;  public Node(int x, int y) {    this. x = x;    this. y = y;  }  public int getX() {    return x;  }  public int getY() {    return y;  }}public class Main {  static int k;  static int[] visitedNode = new int[100_001];  static Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();  public static void main(String[] args) {    Scanner sc = new Scanner(System. in);    int n = sc. nextInt();    k = sc. nextInt();    System. out. println(bfs(n));  }  private static int bfs(int n) {    q. offer(new Node(n, 0));    visitedNode[n] = 1;    int result = 0;    if (checkNode(n,0)) return 0;    while (!q. isEmpty()) {      Node node = q. poll();      int x = node. getX();      int y = node. getY();      if (checkNode(x*2,y+1) || checkNode(x-1,y+1) || checkNode(x+1,y+1)) return y+1;    }    return result;  }  private static boolean checkNode(int x, int y) {    if (x &gt; 100_000 || x&lt;0) {      return false;    }    if (x== k) {      return true;    }    if (visitedNode[x] != 1) {      q. offer(new Node(x, y));      visitedNode[x] = 1;    }    return false;  }}일반적인 BFS 탐색과 동일하게 노드를 방문한 이후 Stack에서 poll해주며 자식 노드들을 방문노드에 저장하는 방식으로 바꾸었다.  통과~ "
    }, {
    "id": 35,
    "url": "http://localhost:4000/2depth_sidbar2/",
    "title": "[Gitblog] 2-depth 사이드바 제작 - 중복 코드 삭제",
    "body": "2023/12/08 - 이전 코드의 문제: &#123;% assign sum = site. posts | size %}&#60;sdiv&gt; &#60;!--전체 글 수--&gt; &#60;sdiv class= common-list &gt;  . . .  &#60;/div&gt; &#60;!--카테고리--&gt; &#60;div class= parent_cat &gt;CS&lt;/div&gt; &#60;div class= common-list &gt;  &#60;ul&gt;   &#123;% for category in site. categories %} &#123;% if category[0] ==  CS  %}   &#60;li&gt;    &#60;a href= #h- &gt;     &#123;&#123; category[0] }}     &#60;span&gt;&#123;&#123; site. posts | where: field, category[0] | size }}&lt;/span&gt;    &#60;/a&gt;   &#60;/li&gt;   &#123;% endif %} &#123;% endfor %}    &#60;!-- 서브 카테고리가 추가될 때마다 위 블럭을 반복. . . --&gt;  &#60;/ul&gt; &#60;/div&gt; &#60;!-- 카테고리가 추가될 때마다 위 블럭을 반복. . . --&gt;&#60;/div&gt;2 depth sidebar을 만들고 방치해둔지 6개월… liquid를 모르는 상태로 2-depth 사이드바를 만든 것 자체로 진이 빠져 리팩토링은 미뤄둔 상태였다. 사실 이때까지만 해도 블로그에 카테고리가 그렇게 많진 않아서 카테고리를 만질 일이 없었는데, 이번에 다시 블러그를 시작하며 카테고리를 몇 개 추가하고 순서를 바꾸려고 하니 좀 귀찮다고 느껴졌다😅카테고리를 수정할 때 카테고리 코드가 아닌 ‘카테고리 구성’을 저장해둔 파일만 수정하면 편할거 같다는 생각이 들었다. 🤔 첫번째 시도 - JS: 처음에는 JS를 사용하려 시도했다. liquid에 익숙하지 않아 자연스럽게 중복코드를 JS를 사용하는 쪽으로 생각이 기울었던거 같다. JS를 사용해 사이드바를 구현하는 것까진 성공했으나…. . &#60;span&gt; &#123;&#123; site. posts | where: field, category[0] | size }}&lt;/span&gt;이녀석이 도무지 구현 불가능했다😱site. posts는 말 그대로 블로그에 있는 ‘포스트’를 들고오는 것으로 보이는데, 위의 Liquid문법을 JS에서 사용할 수 없었고, site. posts 데이터를 html에서 JS로 넘겨주는 것 또한 불가능했다. &lt;span&gt;이 굉장히 애매한 위치에 끼어있던 터라 위 코드는 html에서 처리하고 JS에서 중복 코드를 끼워넣는 방식으로 하는 것도 불가능했다. 멘붕…😂 두번째 시도 - Liquid: 결국 JS를 사용하는 것은 포기하고 순수하기 html내에서 중복코드를 처리하기로 마음먹었다. JS를 사용할땐 이중 배열에 카테고리와 서브카테고리 값들을 저장할 계획이었는데, Liquid를 사용해보니 Liquid에서 배열을 흉내낼순 있으나 이중 배열의 사용은 불가능한 거 같았다. 따라서 카테고리 형식을 저장할 다른 방법이 필요했다. Liquid 템플릿 언어에서는 site. data를 사용해 _data디렉토리에 저장된 외부 데이터를 참고할 수 있다. 예를 들어 _data에 main_category. yaml 파일이 있다면 site. data. main_category를 사용해 해당 데이터를 조회할 수 있다. 123456789101112131415161718 - name:  CS   subcategories:   -  CS    -  Algorithm  - name:  BackEnd   subcategories:   -  Spring    -  Java    -  JPA    -  오류기록장    . . .     - name:  기타   subcategories:   -  블로그_업데이트    -  회고    -  샘플 _data 디렉토리 내에 main_category. yaml파일을 생성했다. 구성은 사이드바 내용과 순서를 그대로 옮겨왔다. 이제 위 데이터를 가져와서 사이드바 코드를 작성하면…… &#123;% assign sum = site. posts | size %}&#60;sdiv&gt; &#60;!--전체 글 수--&gt; &#60;sdiv class= common-list &gt;  . . .  &#60;/div&gt; &#60;!--카테고리--&gt;  &#123;%- assign categories = site. data. main_category -%} &#123;% for category in categories %}  &#60;div class= parent_cat &gt;&#123;&#123; category. name }}&lt;/div&gt; &#60;div class= common-list &gt;  &#60;ul&gt;   &#123;% for subCategory in category. subcategories %}    &#60;li&gt;     &#60;a href= #h- &gt;      &#123;&#123; subCategory }}      &#60;span&gt;&#123;&#123; site. posts | where: field, subCategory | size }}&lt;/span&gt;     &#60;/a&gt;    &#60;/li&gt;    &#123;% endfor %}   &#60;/ul&gt;  &#60;/div&gt;&#123;% endfor %}&#60;/div&gt;이럴수가. . 너무 깔끔해졌다!JS로 했어도 이정도로 깔끔한 코드는 안나왔을 텐데, JS에서 실패하고 삽질을 꽤 오래 했었지만 차라리 잘된 일인거 같다. 😂 "
    }, {
    "id": 36,
    "url": "http://localhost:4000/bad-SQL-grammar/",
    "title": "bad SQL grammar []",
    "body": "2023/12/04 - 에러: 123456789101112  public Long save(Reservation reservation) {    final String sql =  insert into reservation (name, date, timeId) values (?, ?, ?) ;    jdbcTemplate. update(connection -&gt; {          final PreparedStatement preparedStatement = connection. prepareStatement(sql, new String[]{ id });          preparedStatement. setString(1, reservation. name());          preparedStatement. setString(2, reservation. date());          preparedStatement. setString(3, String. valueOf(reservation. timeId()));          return preparedStatement;        }, keyHolder);    return (Long) keyHolder. getKey();  }JDBC 템플릿을 통해 예약 데이터를 데이터베이스에 저장하는 실습을 진행하고 있었다. 오류가 발생한 코드는 위와 같다. error: “Internal Server Error”message:  PreparedStatementCallback; bad SQL grammar []  path: “/reservations”status: 500timestamp: “2023-12-04T08:26:13. 762+00:00” 오류는 위와 같이 발생했다. SQL 문법이 잘못됐을 경우에는 보통 bad SQL grammar [select * from member where name = ?]와 같이 어떤 SQL이 잘못됐는지 알려줬기 때문에 SQL을 인식하지 못했다고 판단했다. 해결 과정: 인터넷에 검색하니 나와 비슷한 오류를 겪은 인프런 질문글이 있었다. 위 글의 답변은 아래와 같다.  encrypted_password 컬럼을 인식하지 못하는 것으로 보여집니다. 작성한 쿼리 또는 DB에 해당 테이블의 컬럼이 정상적으로 생성되었는지 확인 부탁드려요. 위 답변으로 인해 컬럼 인식 문제라는 것을 알 수 있었다. 위 답변을 보고 데이터베이스를 확인했다. 데이터베이스에는 time_id값이 올바르게 생성된 것을 보아 정상적으로 작동했음을 알 수 있었다. 해결: 데이터베이스가 문제가 아니니 코드상 SQL문의 칼럼 문제이다. 다시 확인하니  insert into reservation (name, date, timeId) values (?, ?, ?) 에서 time_id 칼럼이 스네이크 케이스가 아닌 카멜 케이스 timeId로 작성되어 있음을 확인할 수 있었다. 이를 수정하니 해당 오류는 사라졌다. 앞으로 잘 확인하자… "
    }, {
    "id": 37,
    "url": "http://localhost:4000/web/",
    "title": "웹 계층 개발",
    "body": "2023/11/27 - 등록: MemberForm: 12345678910@Getter @Setterpublic class MemberForm {  @NotEmpty(message =  회원 이름은 필수입니다.  )  private String name;  private String city;  private String street;  private String zipcode;}MemberController: 12345678910111213141516171819202122232425@Controller@RequiredArgsConstructorpublic class MemberController {  private final MemberService memberService;  @GetMapping( /members/new )  public String createForm(Model model){    model. addAttribute( memberForm ,new MemberForm());    return  members/createMemberForm ;  }  @PostMapping( members/new )  public String create(@Valid MemberForm form, BindingResult result) {    if (result. hasErrors()) {      return  members/createMemberForm ;    }    Address address = new Address(form. getCity(), form. getStreet(), form. getZipcode());    Member member = new Member();    member. setName(form. getName());    member. setAddress(address);    memberService. join(member);    return  redirect:/  ;  } 조회: 수정: "
    }, {
    "id": 38,
    "url": "http://localhost:4000/Logger/",
    "title": "Logger 사용",
    "body": "2023/11/27 - 시스템이 작동하는 동안 발생하는 어떤 이벤트의 동작을 확인하고 싶을 때가 있다. 개발을 해본 사람이라면 언어 불문하고 누구나 시도해봤을 일이다. (아마도 “print”를 사용해서)간단한 Logging 작업으로 printf를 사용하는 것도 나쁘진 않으나 Java에서는 이러한 이벤트 기록 용으로 제공하는 라이브러리가 존재한다. Log4j라던지 SLF4J라던지 JUL(java util logging)이라던지… 수많은 로그 라이브러리들이 있으며 이 중 SLF4J(Simple Logging Facade for Java)는 다양한 로깅 프레임워크를 추상화 해주는 인터페이스의 모음이다. 인터페이스의 사용으로 개발자는 이후 로깅 라이브러리를 변경하더라도 코드를 수정할 필요가 없어진다.   Logging    DEBUG: 디버깅 목적으로 사용되는 메시지. 일반적으로 프로덕션 환경에서는 활성화되지 않는다.       INFO: 애플리케이션의 상태나 이벤트에 대한 일반 정보      WARN: 애플리케이션 작동을 방해하지 않는 잠재적인 문제를 나타내는 경고      ERROR: 주의가 필요하지만 애플리케이션이 반드시 중단될 필요는 없는 오류      FATAL: 애플리케이션 종료를 초래하는 심각한 오류  slf4j 사용 방법: slf4j은 두 가지 방법으로 사용 가능하다. 방법1: 1Logger log = LoggerFactory. getLogger(getClass());방법2: 1234@Slf4jpublic class HomeController {  . . . } 아래는 slf4j을 사용하여 controller가 실행됐는지 확인하는 예시이다. 12345678910@Controller@Slf4jpublic class HomeController {  @RequestMapping( / )  public String home() {    log. info( home controller );    return  home ;  }}정상적으로 home controller가 출력됐음을 확인할 수 있다. 따라서 우리는 home Controller가 실행은 되었으나 그 안에서 오류가 발생했단 것 또한 알 수 있다. "
    }, {
    "id": 39,
    "url": "http://localhost:4000/blog_update4/",
    "title": "23.11.22 블로그 업데이트4",
    "body": "2023/11/22 - 추가 기능: 1. NEW 태그 삭제  블로그 테마에서 제공하는 기능 중에 포스트 타이틀 옆에 new 태그를 달아주는 기능이 있었다.  그러나 최신 글에 new를 다는 게 아니라… 읽어보지 않은 글에 new가 달리는 로직이라 블로그에 처음 접속하게 되면 모든 글에 new가 뜨게 된다😂 나중에 최신 글에만 new가 뜨도록 고칠수 있다면 기능을 되살리고 싶다… _layout. scss에서 코드를 세 개 정도 주석 처리함. . 이후에 new 검색해서 찾아보기2. box css 또 수정      또 수정했다. . 이전에 box 레이아웃은 list가 삽입되면 위와 같이 box 옆에 마진이 생기는 문제가 있었다.  마진 없애고 패딩을 더 늘리는 식으로 수정했다. 3. 배너 사이즈, favicon 변경      배너의 높이가 너무 큰거 같아서 줄였다 하는 김에 favicon도 변경된 걸로 갈아치웠음 _config. yml 수정"
    }, {
    "id": 40,
    "url": "http://localhost:4000/blog_update3/",
    "title": "23.11.22 블로그 업데이트3",
    "body": "2023/11/22 - 블로그를 오랜만에 쓰려니 너무 불편하고 거슬리는 부분이 많다😂 블로그 다시 시작하자마자 하는 짓이 테마 수정이라니…그러나 깃허브 블로그는 이렇게 테마를 뜯어고치며 블. 꾸 하는 게 묘미인 거 같다~ 추가 기능: 1. 댓글 플랫폼 변경    기존에 사용하던 댓글 플랫폼을 Disqus에서 Utterances 변경했다. 사유!!!!          너무 못생김……. .          으윽! 윽!숨막히게 못생겼다. 사실 이 이유만으로도 댓글 플랫폼을 바꾸려고 생각하고 있었다 (귀찮아서 실행하지 않았을 뿐) 그에 비해 Utterances는 정말 아름답다.           결정적으로 댓글이 안달린다😂     사실 테스트용으로 만든거지 누군가가 댓글을 달거라 생각하고 만든 기능이 아니여서 전혀 신경쓰고 있지 않았는데…얼마전 친구와 카공을 하다가 댓글 기능이 아예 작동하지 않는다는 걸 알게 되었다😂사라진 친구의 댓글에게는 애도하는 마음 뿐이다… 어떻게 살려보려 했으나 Disqus을 사용한 블로그 게시글들이 다 오래된 게시글 뿐이고 그때에 비해 Disqus 사이트가 꽤 많이 바뀌어서 결국 해결 방법은 알아낼 수 없었다. 아무튼 Disqus구리다 쓰지마라          Issue로 댓글 관리가 가능하다💕      Disqus로 댓글을 유실하고 나니 정말 천사같은 기능이다. 위와 같이 Github레파지토리 이슈로 댓글관리가 가능하다.    2. 박스 css 변경    기존의 박스 css가 너무 안예뻐서 안쓰게 되길래 이번에 조금 가독성있고 예뻐보이도록 css를 바꿨다.  좀 둥글게 깎고 패딩을 더 넓히고 색을 연하게 만들었다. . 이제 좀 쓸만해진 거 같다. 3. 포스트 내 이미지 캡션/이미지 행 정렬  사실 기존에도 html로 이미지 캡션과 중앙 정렬을 사용하고 있긴 했다. 그러나 매번 css를 사용할때마다 해당 포스트에 동일한 스타일 코드를 복붙해야하는 현상이… 귀찮아서 해결 안하고 있었다.  이번에 레이아웃 설정 파일에 아예 이미지 캡션과 이미지를 행으로 정렬하는 기능을 작성해놓았다.  layout. scss에서 . post-content에 스타일 클래스를 추가했다.  {: . imageRow} {: . captionedImg}4. 글씨 컬러 지정  빨간색 글씨와 파란색 글씨를 추가했다.  이것도 그냥 html로 작성하고 있었는데 이번에 그냥 레이아웃 설정에 넣어버렸다.  &#60;red&#62;로 감싸면 해당 글자의 색이 바뀌도록 했다~ layout. scss에서 . post-content에 태그를 추가했다. 5. 글씨 마진 변경    기존 블로그에선 줄바꿈시 여백을 넣지 않았음에도 동일 문단의 글이 공백으로 띄어놓은 것처럼 갈라지는 문제가 있었다.  이것도 귀찮아서 안바꾸고 있었는데 글 작성이 너무 불편해서… 이번에 고쳤다. 강제적으로 줄 여백이 생기는 것보다 내가 직접 여백을 삽입하며 글을 적는 것이 글. 꾸 하는 데 훨씬 편한거 같다😂 하는 김에 리스트의 마진이 더 넓은게 가독성에 좋을 거 같아 더 넓혔다.  layout. scss에서 . post-content의 p와 li 마진을 변경했다. "
    }, {
    "id": 41,
    "url": "http://localhost:4000/member-repository-and-service-dev/",
    "title": "레파지토리와 서비스 개발",
    "body": "2023/11/22 - 12345678910111213141516@Entity@Getterpublic class Member {  @Id  @GeneratedValue  @Column(name =  member_id )  private Long id;  private String name;  @Embedded  private Address address;  @OneToMany(mappedBy =  member )  private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();}주어진 회원 도메인은 위와 같다. 회원 레파지토리 개발: 123456789101112131415161718192021222324252627package jpabook. jpashop. repository;@Repositorypublic class MemberRepository {  @PersistenceContext  private EntityManager em;  public Long save(Member member) {    em. persist(member);    return member. getId();  }  public Member find(Long id) {    return em. find(Member. class,id);  }  public List&lt;Member&gt; findAll() {    return em. createQuery( select m from Member m , Member. class)        . getResultList();  }  public List&lt;Member&gt; findByName(String name) {    return em. createQuery( select m from Member m where m. name = :name ,Member. class)        . setParameter( name , name)        . getResultList();  }}Repository는 계층형 아키텍쳐에서 Persistence Layer에 속하는 개념으로, 데이터베이스나 데이터 저장소와 상호 작용한다. 이렇게 Repository에 데이터베이스와의 상호작용의 책임을 부여함으로써 객체 지향 프로그래밍과 데이터베이스 연동 작업을 간소화하고 추상화할 수 있다. 지금부터 위 코드에서 사용된 개념을 하나씩 짚어서 살펴보자.  @PersistenceContext: 컨테이너가 EntityManager를 관리하고 주입123456789101112  EntityManagerFactory emf = Persistence. createEntityManagerFactory( helloJPA );  EntityManager em = emf. createEntityManager();  EntityTransaction tx = em. getTransaction();  tx. begin();		. . . code  tx. commit();  em. close();  emf. close();기존 JPA 구현 코드와 SpringBoot에서의 JPA 코드를 비교해보자. 기존 JPA에서는 엔티티 매니저 팩토리와 엔티티 매니저를 생성 했으나 SpringBoot에서는 둘 다 생성하지 않은 것을 확인할 수 있다. 이는 SpringBoot Starter Data JPA 라이브러리를 사용하고 있기 때문으로, 해당 라이브러리는 Spring Data JPA 라이브러리에서 yml 설정 파일을 읽어 엔티티 매니저 팩토리와 엔티티 매니저를 생성하는 기능을 제공한다. 또한 개발자가 직접 엔티티 매니저를 생성하지 않아도 @PersistenceContext 어노테이션을 통해 스프링에서 생성한 엔티티 매니저를 주입받는다.  createQuery(String qlString, Class&lt;T&gt; resultClass);: 객체를 조회하기 위한 JPQL     qlString: JPQL 쿼리 문자열   resultClass: 쿼리 결과를 매핑할 Java 클래스   SQL과 JPQL 모두 데이터베이스에서 정보를 조회하고 수정하기 위해 사용된다. JPQL은 실행 시에 JPA 구현체에 의해 SQL로 변환되어 실제 데이터베이스에 전달되며, JPQL은 SQL에 포함되는 개념이다. 하지만 SQL은 테이블을 대상으로 쿼리를 작성하나 JPQL은 엔티티 객체를 대상으로 쿼리를 작성한다. 따라서 JPQL은 SQL과 문법상 차이를 보인다. 위 예시의 JPQL String select m from Member m에서 나타나는 Member는 테이블 명이 아닌 객체 Member를 의미한다. 회원 서비스 개발: 1234567891011121314151617181920212223242526272829303132333435package jpabook. jpashop. service;@Service@Transactional(readOnly = true)public class MemberService {  @Autowired  private MemberRepository memberRepository;  //회원 가입  @Transactional  public Long join(Member member) {    validateMember(member);    memberRepository. save(member);    return member. getId();  }  private void validateMember(Member member) {    List&lt;Member&gt; findMembers = memberRepository. findByName(member. getName());    if (findMembers. isEmpty()) {      return;    }    throw new IllegalStateException( 이미 존재하는 회원입니다.  );  }  // 회원 조회  public List&lt;Member&gt; findMembers() {    return memberRepository. findAll();  }    public Member findMember(Long id) {    return memberRepository. find(id);  }} @Transactional: 로직을 트랜젝션 내에서 수행되도록 함 @Autowired: 자동 의존성 주입을 수행MemberService에서 MemberRepository를 사용하기 위해 @Autowired를 사용해 레파지토리를 주입해주었다. @Autowired를 사용하면 Spring은 자동으로 해당 타입의 빈을 찾아 필드, 메서드, 생성자를 자동으로 주입해준다. 우리는 뮈 예제에서 필드 주입을 위해 @Autowired 어노테이션을 사용했다. 1. Field Injection(필드 주입): 12  @Autowired  private MemberRepository memberRepository;필드 주입은 사용하려는 Controller의 필드에 직접 @Autowired를 부여하는 방법이다. 그러나 Field Injection 사용시 final 제어자를 사용이 불가능하며, 객체의 변경 가능성을 열어두어 Service의 불변성을 보장하지 못한다. 또한 테스트 코드 작성시 주입받는 객체의 생성이 어려우며, 따라서 단위 테스트가 불가능하다. 따라서 Field Injection은 지양해 사용하여야 한다. 2. Setter Injection(수정자 주입): 123456  private MemberRepository memberRepository;  @Autowired  public void setMemberRepository(MemberRepository memberRepository) {    this. memberRepository = memberRepository;  }위와 같이 Setter Injection을 사용하면 테스트 코드를 작성할 때 개발자가 직접 주입이 가능하다는 장점이 있다. 그러나 실제로 애플리케이션 동작 중에 객체를 변경하게 될 일은 거의 없으므로, 잘 쓰이지 않는 주입법이다. 3. Constructor Injection(생성자 주입): 123456  private final MemberRepository memberRepository;  //@Autowired  public MemberService(MemberRepository memberRepository) {    this. memberRepository = memberRepository;  }가장 권장되는 Injection 방식이다. 생성자 주입은 Service를 생성할 때 객체의 주입을 완료하기 때문에 중간에 객체의 변경이 불가능하며, 의존중인 객체들 중 하나라도 주어지지 않으면 객체 생성이 불가능하다. 또한 final 제어자를 사용해 불변성을 보장할 수 있다. @Autowired 어노테이션을 작성하지 않아도 생성자를 작성할 경우 자동으로 Injection을 하는 기능을 Spring이 제공하나. 생성자 작성 대신 Lombok에서 제공하는 @RequiredArgsConsturctor 어노테이션을 사용할 수도 있다.  @RequiredArgsConsturctor: 생성자를 작성하지 않아도 final 제어자가 있는 필드에 대해서 생성자를 생성해준다. 회원 기능 테스트: 1234567891011121314151617181920package jpabook. jpashop. repository;@ExtendWith(SpringExtension. class)@SpringBootTestclass MemberRepositoryTest {  @Autowired MemberRepository memberRepository;  @Test  public void testMember () {    Member member = new Member();    member. setUserName( memberA );        Long saveid = memberRepository. save(member);    Member findMember = memberRepository. find(saveid);    assertEquals(findMember. getId(), member. getId());    assertEquals(findMember. getUserName(), member. getUserName());  }} @ExtendWith(SpringExtension. class): JUnit에게 스프링 관련 테스트를 함을 알리기 위한 어노테이션 @SpringBootTest: 스프링 부트로 테스트하기 위한 어노테이션 No EntityManager with actual transaction available for current thread - cannot reliably process ‘persist’ call 위 테스트 코드를 실행하면 위와 같은 에러가 발생한다. 에러를 보면 알 수 있듯이 이는 트랜잭션이 존재하지 않기에 발생하는 문제이다. 엔티티 매니저를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다. 123456789101112131415 		@Test    @Transactional		@Rollback(value = false)  public void testMember () {    Member member = new Member();    member. setUserName( memberA );        Long saveid = memberRepository. save(member);    Member findMember = memberRepository. find(saveid);    memberRepository. find(saveid);    assertEquals(findMember. getId(), member. getId());    assertEquals(findMember. getUserName(), member. getUserName());  } @Transactional: 스프링의 선언적 트랜잭션 설정 어노테이션     테스트에 존재할 시 테스트 종료 후 DB를 롤백한다.     @Rollback(value = false): Transactional의 DB 롤백 설정을 False로 한다. @Rollback(value = false) 어노테이션 없이 @Transactional만 사용할 경우 Insert 쿼리가 실행되지 않음을 확인할 수 있다. 쿼리는 영속성 컨텍스트 내에 있는 멤버 객체가 flush가 될 때 실행되는데, @Transactional 어노테이션이 트랜잭션의 커밋 이전에 롤백을 하기 때문이다. 실제로 @Rollback(value = false)을 사용하지 않을 경우 테스트 코드를 실행해도 데이터베이스에 저장되지 않음을 확인할 수 있다. "
    }, {
    "id": 42,
    "url": "http://localhost:4000/application-architecture/",
    "title": "애플리케이션 아키텍쳐",
    "body": "2023/11/21 - 애플리케이션 아키텍쳐: 계층형 아키텍쳐(Layered Architecture)는 각 구성 요소들의 관심사를 분리하기 위해 각 계층의 책임을 분리한 아키텍쳐이다. 각 계층의 책임을 분리함으로 각 계층은 하나의 관심사만을 가지게 되고 이로써 계층의 응집도를 높이고 결합도를 낮출 수 있다. 소프트웨어 개발에 있어 계층은 3 혹은 4계층으로 나누어 진다. 각 계층은 다음과 같다.  Presentation Layer     가장 바깥 계층으로 사용자와 직접 상호작용하는 계층    Businness Layer     요청에 따른 비즈니스 로직을 다루는 계층    Persistence Layer     데이터베이스와 상호작용하는 계층    Database Layer     데이터가 저장되어 있는 계층 (데이터베이스)   각 계층은 하위 계층에 의존적이며, 상위 계층을 알지 못해야 한다. 위와 같은 애플리케이션 구조도를 예시로 들어보자. 이때Controller는 Presentation Layer,Service는 Business Layer,Repository는 Persistence Layer에 속하게 된다. 이때 Repository는 데이터베이스와 상호작용하는 계층이므로, JPA와 엔티티 매니저를 직접 사용한다. "
    }, {
    "id": 43,
    "url": "http://localhost:4000/start-JPA/",
    "title": "[JPA] JPA 시작하기",
    "body": "2023/09/06 - 프로젝트 생성:  강의에서는 데이터베이스로 H2, 빌드 툴로 메이븐을 채택했지만 스프링 스터디와 프로젝트 경험으로 Gradle 사용이 익숙하고, 이미 노트북에 설치되어 있는 MySQL을 두고 H2를 새로 설치하고 싶지 않아 나는 강의와 다르게 MySQL과 Gradle을 사용해 프로젝트를 빌드했다.  MySQL과 Gradle 사용으로 프로젝트 초기 설정이 강의와는 달랐기에, 따로 자료를 찾아보며 프로젝트를 생성했다. 설정 파일: pom. xml은 Marven의 설정 파일로, Gradle을 사용할 때는 사용되지 않는다. 이때 Gradle 사용시 pom. xml의 역할을 대신하는 것이 build. gradle 이다. 두 파일 모두 프로젝트의 이름, 버전, 그룹 id와 같은 구성과 프로젝트 빌드, 의존성 관리에 대한 정보를 담고있다. 강의 스크린샷에서 pom. xml 파일에 담긴 프로젝트 구성 정보와 JPA 하이버네이트, H2 데이터베이스에 대한 의존성 정보를 확인할 수 있다.  1234567891011121314151617181920212223242526plugins {  id( java )}group =  jpa-basic version =  1. 0-SNAPSHOT repositories {  mavenCentral()}dependencies {  testImplementation(platform( org. junit:junit-bom:5. 9. 1 ))  testImplementation( org. junit. jupiter:junit-jupiter )  // Hibernate  implementation( org. hibernate:hibernate-core:5. 5. 6. Final )  implementation( org. hibernate:hibernate-annotations:3. 5. 6-Final )  // MySQL JDBC 드라이버  implementation( mysql:mysql-connector-java:8. 0. 27 )} tasks. test {  useJUnitPlatform()}build. gradle은 위와 같이 작성된다. pom. xml과 동일하게 프로젝트 정보와 의존성 정보가 담겨있다. 다만, 나는 강의와 다르게 H2가 아닌 MySQL 데이터베이스를 사용하기 때문에 H2 의존성 정보 대신 MySQL 의존성 정보를 추가했다.  persistence. xml: persistence. xml은 JPA에서 필요로하는 설정을 관리하는 파일이다. 설정 파일이 클래스패스 경로/META-INF/persistence. xml 에 위치할 경우 별도의 설정 없이 JPA가 인식할 수 있다. . 123456789101112131415161718192021&lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;&lt;persistence version= 2. 2  xmlns= http://xmlns. jcp. org/xml/ns/persistence  xmlns:xsi= http://www. w3. org/2001/XMLSchema-instance  xsi:schemaLocation= http://xmlns. jcp. org/xml/ns/persistence http://xmlns. jcp. org/xml/ns/persistence/persistence_2_2. xsd &gt; &lt;persistence-unit name= helloJPA &gt;  &lt;properties&gt;   &lt;!-- 필수 속성 --&gt;   &lt;property name= hibernate. connection. driver_class  value= com. mysql. cj. jdbc. Driver /&gt;   &lt;property name= hibernate. connection. url  value= jdbc:mysql://localhost:3306/basicJPA /&gt;   &lt;property name= hibernate. connection. username  value= root /&gt;   &lt;property name= hibernate. connection. password  value= fostree1351 /&gt;   &lt;property name= hibernate. dialect  value= org. hibernate. dialect. MySQL5InnoDBDialect /&gt;   &lt;!-- 옵션 --&gt;   &lt;property name= hibernate. show_sql  value= true /&gt;   &lt;property name= hibernate. format_sql  value= true /&gt;   &lt;property name= hibernate. use_sql_comments  value= true /&gt;   &lt;!--&lt;property name= hibernate. hbm2ddl. auto  value= create  /&gt;--&gt;  &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt;강의의 h2 설정을 MySQL 설정으로 바꾸어주었다. 이때 hibernate. connection. ~ 에는 연결되는 데이터베이스의 사용자 이름, 비밀번호, 주소와 같은 설정을 지정하고, hibernate. dialect에는 하이버네이트가 데이터베이스와 통신을 하기 위해사용하는 방언을 지정한다.  방언이란 SQL 표준을 지키지 않는 특정 데이터베이스만의 고유한 기능을 의미한다. 그러므로 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다르고, 사용하는 데이터베이스에 알맞는 방언을 사용하도록 주의해야한다.   ❓   없어도 되나?  그런데 해당 `persistence. xml`이 존재하지 않아도 코드를 살행시켰을 때 정상적으로 돌아가는 걸 확인할 수 있었다. 이제 생각하면 당연한 것이, 나는 main 메소드 내에 아무것도 안넣고 실행을 눌렀기 때문이었다.      Persistence 클래스가 없으니 당연히 persistence. xml도 조회하지 않았을 것이고, 그렇다면 persistence. xml이 있든 없든 실행에 영향을 미치는 않을 테니 말이다. 다행히 금방 알아차렸다.  애플리케이션 개발: JPA의 Persistence 클래스는 엔티티 클래스를 나타낸다. 그리고 엔티티 클래스란, 데이터베이스 테이블과 매핑되는 데이터베이스 레코드를 나타낸다. 12345678910111213package helloJPA;public class JpaMain { public static void main(String[] args) {  EntityManagerFactory emf = Persistence. createEntityManagerFactory( helloJPA );  EntityManager em = emf. createEntityManager();  //code  em. close();  emf. close(); }}여기서 “helloJPA”는 가져올 Persistence Unit의 이름을 의미한다. 이는 엔티티 클래스와 데이터베이스 연결 정보, 트랜잭션 설정 및 기타 JPA 설정을 묶는 단위로, 하나의 persistence. xml에는 여러개의 Persistence Unit이 존재할수 있기에 고유한 이름을 지녀야 한다.  &lt;persistence-unit name= helloJPA &gt;Persistence. xml파일에서 설정해놓은 persistence unit 이름을 확인할 수 있다.  엔티티 매니저 팩토리는 어플리케이션 로딩 시점에 하나만 생성되어야 한다(DB당 하나). 즉 필요할때마다 계속 재활용된다. 생성된 엔티티 매니저 팩토리는 일관적인 트랜젝션 범위 내에서 엔티티 매니저를 생성하고, 엔티티 매니저가 데이터베이스 커넥션을 얻고 쿼리를 날리면 엔티티 매니져를 종료시킨다. 그러나 엔티티 매니저는 엔티티 매니저 팩토리와 다르게 재활용될 수 없다. 회원의 요청이 들어올 때마다 새로 생성하고 요청이 끝나면 close()를 사용하여 버려야 한다. 즉 쓰레드간 공유할 수 없다.  12345678910package helloJPA;@Entitypublic class Member { @Id private Long id; private String name;	//getter, setter} @Entity: 해당 클래스가 JPA를 사용함을 명시 @Id: id 키가 해당 클래스의 PK임을 명시1234567891011121314151617181920public class JpaMain { public static void main(String[] args) {  EntityManagerFactory emf = Persistence. createEntityManagerFactory( helloJPA );  EntityManager em = emf. createEntityManager();  EntityTransaction tx = em. getTransaction();  tx. begin();  Member member = new Member();  member. setId(1L);  member. setName( memberA );  em. persist(member);  tx. commit();  em. close();  emf. close(); }}데이터베이스의 일관성과 무결성을 유지하기 위해 우리는 트랜잭션(Transaction)을 사용해야 한다. 위 코드는 특정 멤버 데이터를 데이터베이스에 저장하는 코드이다(em. persist(member);). 이렇게 데이터베이스를 조작하면서도 데이터베이스의 일관성과 무결성 유지를 위해 트랜잭션이 사용되며, 모든 데이터베이스의 변경은 트랜젝션 내에서 수행되어야 한다.  12345678Hibernate:   /* insert helloJPA. Member    */ insert     into      Member      (name, id)     values      (?, ?)위 코드를 실행시키면 콘솔에서 JPA가 생성한 쿼리를 확인할 수 있다. 해당 설정은 persistence. xml에서 확인할 수 있다. 	&#60;!-- 옵션 --&gt;  &#60;property name= hibernate. show_sql  value= true / &#62;  &#60;property name= hibernate. format_sql  value= true /&#62;  &#60;property name= hibernate. use_sql_comments  value= true /&#62;  그러나 위 코드는 좋은 코드라고 볼 수 없다. 만일 실행 중간에 오류가 생겼을 경우 엔티티 매니저와 엔티티 매니저 팩토리를 종료시키는 코드가 실행되지 않기 때문이다. 특히 엔티티 매니저의 경우 데이터베이스 커넥션을 물고 동작하기 때문에 꼭 종료 되도록 코드를 짜야한다.  123456789101112131415161718192021222324252627package helloJPA;public class JpaMain { public static void main(String[] args) {  EntityManagerFactory emf = Persistence. createEntityManagerFactory( helloJPA );  EntityManager em = emf. createEntityManager();  EntityTransaction tx = em. getTransaction();  tx. begin();  try {   Member member = new Member();   member. setId(1L);   member. setName( memberA );   em. persist(member);   tx. commit();  } catch (Exception e) {   tx. rollback();  } finally {   em. close();  }  emf. close(); }}JPQL: JPA로도 조회는 가능하지만 좀 더 복잡한 조회라면 말이 다르다. 예를 들어 18세 이상인 회원만을 검색하고 싶다면? 이때 사용하는 것이 JPQL이다. 123456789101112try {   List&lt;Member&gt; result = em. createQuery( select m from Member as m , Member. class)     . setFirstResult(5)     . setMaxResults(8)     . getResultList();   for (Member member:result) {    System. out. printf(member. getName());   }   tx. commit();  }5번부터 8번까지의 항목을 리스트 형태로 가져오고, 그것을 나열하는 코드이다. JPQL로 짠 쿼리는 설정된 방언에 맞춰서 번역되는 번역의 역할을 하기도 한다. "
    }, {
    "id": 44,
    "url": "http://localhost:4000/JPA-introduction/",
    "title": "[JPA] JPA 소개",
    "body": "2023/09/05 - JPA 소개: JPA란 Java Persistence API의 약칭으로, 자바 진영의 ORM 기술 표준이다.  💡 	ORM: Object relational mapping(객체 관계 매핑)	객체대로 설계된 객체와 데이터베이스대로 설계된 데이터베이스 사이를 매핑해주는 것이 ORM이다. ORM은 객체와 데이터베이스 사이 패러다임 불일치를 해결해준다.   JPA는 DB와 Java 어플리케이션 사이에 존재한다. 예전에는 개발자가 직접 JDBC API를 사용하여 DB와 통신했지만, JPA를 사용으로 개발자는 JPA에게 JDBC API를 사용을 넘겨줄 수 있게 됐다. 이렇게만 보면 JPA가 Mybatis나 JDBC 템플릿 같은 다른 자바 퍼시스턴스 프레임워크와 비슷해보일 수 있으나, JPA의 가장 큰 특징은 따로있다.  Member 객체를 DB에 저장한다고 가정해보자. 단순히 MemberDAO가 JPA에게 Member 엔티티(객체)를 던져주는 것만으로, JPA는 Member 엔티티를 분석하고 Insert SQL을 생성한다. 그뿐만이 아니라 JDBC API를 사용하여 Insert 쿼리를 실행한다. 그리고 가장 중요하게, 패러다임 불일치를 해결한다. JPA를 사용하는 것으로 마치 자바 컬렉션에 객체를 저장하듯 한 줄 만으로 데이터베이스에 객체를 저장할 수 있게 된 것이다! 조회하는 것 또한 간단하다. JPA에게 Id를 전달해주는 것 만으로, JPA는 우리에게 엔티티 객체를 전달해준다. JPA의 사용으로 판은 SQL중심적인 개발에서 객체 중심적인 개발로 이동했다. 이는 생산성의 확대를 가져왔을 뿐만 아니라 유지보수의 편리성과 성능을 증대시켰다. JPA와 CRUD:  저장: jpa. persist(member) 조회: Member member = jpa. find(memberId) 수정: member. setName(“변경할 이름”) 삭제: jpa. remove(member)JPA와 유지보수: JPA 도입 이전, 객체에 새로운 필드가 추가되면 개발자가 필요한 SQL을 찾아다니며 해당 필드를 직접 추가해주어야 했다. 당연히 유지보수가 잘 될리가 없다. 반면 JPA를 사용하면, 단순히 객체에 필드를 추가해주는 것으로 모든 것이 끝난다. JPA가 모든 SQL문을 알아서 처리하기 때문이다. 이는 개발자의 유지보수 영역을 축소시킨다. 신뢰할 수 있는 엔티티, 계층: 12345678class MemberService {	. . . 	public void process() {		Member member = memberDAO. find(memberId);		member. getTeam(); //자유로운 객체 그래프 탐색		member. getOrder(). getDelivery();	}}memberDAO가 jpa를 사용한다면, 지연로딩이라는 기술을 사용해 객체 그래프 내에 존재하는 모든 객체를 사용할 수 있게 된다. 지연로딩에 대해서는 이후에 설명한다. JPA의 비교: 12345String memberId =  100 ;Member member1 = jpa. find(Member. class, memberId);Member member2 = jpa. find(Member. class, memberId);member1 == member2; //같다. JPA는 동일한 트랜잭션에서 조회한 엔티티의 동일성을 보장해준다. JPA의 성능 최적화: 1. 1차 캐시와 동일성(identity) 보장 위에서 JPA는 동일 트랜젝션에서는 동일한 엔티티를 반환한다고 설명했다. 이러한 동일성 보장은 약간의 조회 성능향상을 불러오기도 한다. 어떤 기술이 두 시스템을 연결해주는 경우(JPA가 데이터베이스와 Java어플리케이션을 연결하 듯이) 캐싱을 사용할 수 있게 된다. 이전에 조회했던 데이터를 캐시로 저장해두고, 동일한 데이터가 조회 됐을 때 캐시를 전달해주는 것이다. 123String memberId =  100 ;Member member1 = jpa. find(Member. class, memberId); //SQLMember member2 = jpa. find(Member. class, memberId); //캐시2. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 어떤 기술이 두 시스템을 연결해주는 경우에 사용할 수 있는 성능 향상 기술이 하나 더 있다. 바로 버퍼이다. 트랜잭션을 커밋할 때까지 INSERT SQL을 모으고, JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송이 가능하다. 이를 통해 네트워크 통신 비용을 줄일 수 있다. 123456789transaction. begin(); // [트랜잭션] 시작em. persist(memberA);em. persist(memberB);em. persist(memberC);//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다. //커밋하는 순간 데이터베이스에 INSERT SQL을 모아서 보낸다. transaction. commit(); // [트랜잭션] 커밋3. 지연 로딩(Lazy Loading) 지연 로딩과 대비되는 것으로 즉시 로딩이 있다.  지연로딩: 객체가 실제 사용될 때 로딩한다. (연관된 객체를 함께 들고오지 않는다. ) 즉시로딩: 연관된 객체를 함께 들고온다. 예를 들어 Team과 Member가 연관관계에 있다고 생각해보자. 그렇다면 Member를 가져올 때 Join을 통해 Team을 함께 들고오는 것이 성능상 유리할 것이다. 그러나 Team 객체가 쓰이는 빈도가 매우 적다면 Member만 조회하는 것이 옳다. 그러나 연관 관계의 객체를 함께 들고오는 것이 나을지, 아니면 사용하는 객체 하나만 가져올 것인지는 쓰임마다 다를 것이고, 따라서 JPA는 지연로딩과 즉시로딩을 모두 지원한다.  일반적으로 JPA를 사용해 개발할 때는 지연 로딩으로 개발해두고, 이후 즉시로딩으로 변경하는 것으로 최적화한다. JPA는 데이터베이스와 JAVA어플리케이션을 매핑하는 기술이다. 즉, JPA를 잘 알기 위해서는 JPA가 연결하고 있는 두 기술을 잘 이해하는 것이 필요하다. "
    }, {
    "id": 45,
    "url": "http://localhost:4000/difference-of-objects-and-relational-databases/",
    "title": "[JPA] 객체와 데이터베이스간 불일치",
    "body": "2023/09/04 -  JPA를 사용하는 큰 이유 중 하나는 객체와 데이터베이스 간의 매핑(ORM)에 있다. 해당 게시글에서는 객체와 데이터베이스 간의 차이와, 그로 인해 발생하는 문제점에 대해 다룬다. SQL 중심적인 개발의 문제점: 객체를 저장하는 수단은 RDB, NoSQL, File 등 다양하게 존재하나 현실적으로 쓰이는 대안은 RDB(관계형 데이터베이스)이다. (NoSQL은 보통 RDB의 보조적인 수단으로 쓰인다. ) 그렇다면 관계형 데이터베이스에 객체를 저장하기 위해선 어떻게 해야하는가? 데이터베이스에 객체를 저장하기 위해선 객체를 SQL로 변환하는 선수과정이 필요하다. 회원 정보를 DB에 저장할 때는 insert문을 사용해 SQL로 변환시켜 RDB에 전달하고, 반대로 조회할 때 또한 select문을 작성해 DB에 저장된 데이터를 객체로 바꾼다. 이런 SQL 매핑은, 개발자에게 불가피한 과정이다. 그렇다면 SQL을 배우기 전 객체와 관계형 데이터의 차이를 먼저 알아보자. 객체와 관계형 데이터베이스의 차이: 객체와 관계형 데이터베이스 사이에는 크게 상속, 연관관계, 데이터 타입, 데이터 식별 방법의 4가지 차이점이 있다. 상속: 데이터베이스엔 객체에서 흔히 말하는 상속관계가 존재하지 않는다. 그렇다면 객체의 상속관계를 데이터베이스에 저장하기 위해선 어떻게 해야하는가? 슈퍼타입 서브타입: 객체의 상속관계를 데이터베이스에 저장하기 위해 데이터베이스 테이블 설계 기법 중 하나인 슈퍼타입 서브타입 관계를 사용할 수 있다. 슈퍼타입 서브타입 관계란 부모와 자식에 해당하는 객체들을 테이블로 만든 후 SQL을 사용해 상속관계를 흉내내는 기법이다. 그러나 위 방식을 사용하면 곤란한 부분이 있다. 예를 들어 Album 객체를 데이터베이스에 저장하는 과정을 생각해보자.  1. 먼저 Album 객체를 분해해야한다. 2. 분해된 객체의 데이터(id, 이름, 가격)를 Insert문을 사용해 ITEM 테이블에 저장한다.  3. 2와 동일한 방식으로 데이터(id, 작곡가)를 ALBUM 테이블에 저장한다. Album을 조회하는 경우는 더 까다롭다. 1. ITEM 테이블과 ALBUM테이블을 Join하기 위한 SQL을 작성한다. 2. 객체를 생성한다. 3. 조인된 테이블의 데이터를 객체에 다 집어넣는다. 4. … 생략 심지어 위 단계를 다른 객체를 조회하는 경우에도 또 다시 반복해야하니 복잡해질 수밖에 없고, 이는 SQL을 작성하는 개발자에게 힘이 드는 일이 아닐 수 없다. 그렇기 때문에, DB에 저장할 객체에는 상속관계를 사용하지 않는다. 자바 컬렉션: 자바 컬렉션을 사용하면 슈퍼타입 서브타입을 사용하는 것보다 훨씬 간단한 방법으로 객체의 저장과 조회가 가능하다.  저장: list. add(Album); 조회: Album album = list. get(albumId); 또는 Item item = list. get(albumId);이렇게 자바 컬렉션을 사용한 객체 관리가 간단한 이유는, 자바 컬렉션 또한 객체 차원에서 사용되는 도구이기 때문이다. 즉, 자바 컬렉션은 객체를 데이터베이스에 저장하는 것이 아닌, 메모리 내에서 객체를 저장하고 관리하는 자료 구조이다. 연관 관계: 연관 관계의 데이터를 가져오기 위해 객체는 member. getTeam()과 같은 참조를 사용한다. 그러나 데이터베이스에는 객체와 같은 참조가 없다. 그렇기에 데이터베이스에선 연관관계를 만들기 위해 외래 키를 사용해 Join하는 방식을 사용한다. (JOIN ON M. TEAM_ID = T. TEAM_ID) 이렇게 객체는 참조를 사용하고, 데이터베이스는 외래키를 사용하는 차이에서 문제가 발생한다. 12345678910class Member {	String id; //MEMBER_ID 컬럼 사용	Long teamId; //TEAM_ID FK 컬럼 사용	String username;//USERNAME 컬럼 사용}class Team {	Long id; //TEAM_ID PK 사용	String name; //NAME 컬럼 사용}객체 저장을 쉽게 하기 위한 객체 구조를 생각해보자. 기존의 Team team;과 같은 참조 대신 Long teamId;라는 외래키를 사용한 것을 확인할 수 있다. 이렇게 참조 대신 외래키를 사용하므로써 Insert문 작성이 간단해진다.  그러나 이를 객체다운 모델링이라 할 순 없다: Member 클래스와 Team 클래스 사이의 관계가 명시적으로 표현되지 않았다. 즉, 참조가 빠져있다. 그렇다면 참조를 사용하는 것이 바람직하다. 참조를 사용해 INSERT문을 만들기 위하여 아래와 같은 객체 구조를 생각해볼 수 있다. 1234567891011121314class Member {	String id; //MEMBER_ID 컬럼 사용	Team team; //참조로 연관관계를 맺는다. //**	String username;//USERNAME 컬럼 사용	Team getTeam() {		return team;	}}class Team {	Long id; //TEAM_ID PK 사용	String name; //NAME 컬럼 사용} 참조를 사용하니 데이터베이스에 Insert하기가 이전에 비해 까다로워졌다. 그러나 더 문제가 되는 것은 조회이다. 1234567891011121314SELECT M. *, T. * FROM MEMBER MJOIN TEAM T ON M. TEAM_ID = T. TEAM_IDpublic Member find(String memberId) {	//SQL 실행 . . . 	Member member = new Member();	//데이터베이스에서 조회한 회원 관련 정보를 모두 입력	Team team = new Team();	//데이터베이스에서 조회한 팀 관련 정보를 모두 입력	//회원과 팀 관계 설정	member. setTeam(team);	return member;}생략된 부분이 많으나, 충분히 번거로워 보인다. 그렇다면 번거로운 부분을 어떻게 줄일 수 있을까? 이 모든 번거로움은 객체와 데이터베이스간의 불일치에서 발생하는 일이다. 그럼 Member와 Team을 DB가 아닌 자바 컬렉션에 관리한다면? 자바 컬렉션: 위에서 언급했듯이, 자바 컬렉션은 객체 차원에서 사용되는 도구이기 때문에 DB에서 객체를 관리할 때에 비해 훨신 간결하게 코드를 작성이 가능하다.  저장: list. add(member); 조회: Member member = list. get(memberId); Team team = member. getTeam();SQL 매핑에서의 해방: 객체와 DB간 패러다임 불일치에서 번거로움이 있다면 객체 안에서 객체를 관리하면 되는 일이다. 이는 복잡한 변환 과정을 제거해주고, 자유로운 객체 그래프 탐색을 가능하게 해준다.  💡  	객체 그래프 탐색		자유로운 객체 그래프 탐색을 충족시키기 위해선, 참조를 통해 한 객체에서 다른 객체로 이동하며 전체 객체를 자유롭게 탐색할 수 있어야 한다.  	그러나 데이터베이스에선 처음 실행한 SQL문에 따라 탐색 범위에 제한이 걸리게 된다. 	예를 들어 SELECT M. *, T. * FROM MEMBER M JOIN TEAM T ON M. TEAM_ID = T. TEAM_ID 와 같은 SQ이 있을 때, 탐색 가능한 객체는 Member와 Team뿐이다. 	이러한 탐색의 제한은 엔티티 신뢰 문제를 발생시킨다.  객체 지향 설계가 중요하다고 말들은 하나, 객체답게 모델링 할 수록 SQL로 매핑하는 비용이 늘어나게 된다. 이런 문제를 해결하기 위해, 객체를 자바 컬렉션에 저장하듯이 DB에 저장하는 방식이 바로 JPA(Java Persistence API)이다. "
    }, {
    "id": 46,
    "url": "http://localhost:4000/seminarAttend1/",
    "title": "출석 체크 페이지 제작 1- 설계",
    "body": "2023/06/25 -  서론: Keeper라는 부산대학교 보안동아리에서 난데없이 개발을 하고 있는 나는 이번 홈페이지 리뉴얼 작업에서 출석체크 페이지 개발을 맡았다. 사실 버전 1에서도 동일한 기능을 개발했던 터라 개발이 쉬울 줄 알았는데… 여러가지 바뀐 점 + TypeScript와 eslint 사용으로 꽤 많은 부분을 수정해야 했다. (버전 1 코드가 개발새발이어서 그런 것도 있다. ) 앞으로 해당 기능을 어떻게 개발했는지, 어떤 오류가 있었는지, 어떤 부분이 수정되었는지는 실시간으로 게시글로 작성할 생각이다.  이 게시글을 포함 앞으로 올라올 출석페이지 관련 게시물은 앞으로 해당 기능을 유지, 보수 할 회원의 편의를 목적으로 한다. FlowChart: Permission:             대구분      중구분      사용자      보기      수정      삭제      쓰기      비고                  출석체크 페이지      출석 시간 설정      회장      O                  O                       부회장      O                  O               서기      O                  O              회원      X                  X              출석 시작      회장      O                  O                       부회장      O                  O               서기      O                  O              회원      X                  X              출석      회장      O                  O      회원은 출석 기능만 접근 가능                 부회장      O                  O               서기      O                  O              회원      O                  O              관리 페이지 이동      회장      O                  O                       부회장      O                  O               서기      O                  O              회원      X                  X      UI: UI 부분은 개발을 진행하며 추가할 사항이 존재하며, 실시간으로 업데이트 될 예정이다.  Page Title: 세미나 출석Author: 파녀미Screen Path: HOME&gt; 참여 마당&gt; 세미나 출석권한: 회장, 부회장, 서기    Description  Check Point       1   세미나 관리 페이지로 이동   좌측에 예정된 세미나 카드가, 우측에 종료된 세미나 카드가 배치된다. 새로고침/로그아웃 시에도 타이머가 리셋되지 않도록 한다. 출석을 시작한 회원은 자동으로 출석처리하도록 한다. 출석 시간 옵션은 5분, 10분, 15분, 20분이 있다    2  출석 마감 시간 설정    3  지각 마감 시간 설정    4  출석 시작   Page Title: 세미나 출석Author: 파녀미Screen Path: HOME&gt; 참여 마당&gt; 세미나 출석권한: 회장, 부회장, 서기, 회원    Description  Check Point       1   세미나 관리 페이지로 이동   지각시간 마감 전까지 출석하지 않을 경우 결석처리 한다. 출석코드 제출 횟수는 5회로 제한한다. 출석코드 제출 횟수가 5화를 초과하면 모달을 띄우고 결석 처리한다. 생성되었으나 시작되지 않은 세미나의 시간은 --:--으로 보인다. 회장,부회장 혹은 서기 권한을 가지지 않은 회원은 세미나 관리 버튼을 볼 수 없다.     2  출석코드 입력    3  출석 버튼     4  모달 확인 버튼  "
    }, {
    "id": 47,
    "url": "http://localhost:4000/blog_update2/",
    "title": "23.6.9 블로그 업데이트2",
    "body": "2023/06/09 - 추가 기능: 1. 박스 레이아웃 추가        테마 샘플 포스트엔 존재했지만 실제로는 적용되지 않던 박스 레이아웃을 추가했다.  note 박스가 dark 모드에선 안보여서 하얀색 테두리 추가함 _sass/yat/_layout. scss 파일 참고 사용은 test-markdown 게시물 참고2. 콜아웃 추가  콜아웃 레이아웃을 제작하였다.  디자인은 노션에 있는 콜아웃 뺏겨옴ㅎㅎ _sass/yat/_layout. scss 파일 참고 사용은 test-markdown 게시물 참고3. favicon 추가  relative path가 아닌 absolute path 사용할 것 (안그럼 게시글 클릭 시 사라짐) 정말 귀엽다🥰 한동안은 오른쪽으로 해둘 거 같다4. 조회수 등록  /_includes/views/banner. html HITS에서 제공해주는 기능이다. 5. 사이드바 수정   기존 사이드바   기존 블로그 테마가 제공해주던 사이드바 디자인이 마음에 안들었다… 2 depth를 제공해주는 사이드바로 수정함 수정한 내용은 너무 길어서 따로 게시글에 포스팅했다. "
    }, {
    "id": 48,
    "url": "http://localhost:4000/2depth_sidbar/",
    "title": "[Gitblog] 2-depth 사이드바 제작",
    "body": "2023/06/09 -  내가 사용하는 테마인 Yat은 위와 같은 사이드바를 제공해준다. 당연히 마음에 들지 않았다…. 😌 특히 카테고리 종류가 늘어날수록 지저분해 보여 항상 사이드바를 2-depth로 수정하자고 생각하고 있었다. 그러나 jekyll를 잘 몰랐기에 jekyll 테마의 코드는 해독이 어려웠고; 사이드바를 만드는 방법을 열심히 구글링해봤지만 2-depth의 사이드바를 적용한 얘시를 찾기 어려웠다. 특히 대부분 다른 테마를 사용하고 있었고, 그로인한 파일구조가 달랐기에 내 블로그에 적용하기는 더 어려워보였다🥲 [Github 블로그] minimal-mistake 블로그 카테고리 만들기 (+ 전체 글 수) 그때 발견한 게시글! 이거라면 내 블로그에도 적용할 수 있을 것 같았다. 많은 부분을 위 블로그를 참고했다! 정말 훌륭한 게시글! 그러나 위에서 서술했듯 나는 Yat 테마를 사용하고 있었고, 위 게시글에서 사용한 테마와는 다른 점이 참 많았다. + jekyll과 Liquid를 잘 몰랐기 때문에 정말 많은 부분을 감으로 시도해야했다. 이 게시글은 2-depth 사이드바를 블로그에 적용하는 방법과 그로 이해하게 된 약간의 원리…?를 서술하는 게시글이 될 것 같다. 위 게시글을 참고한 내용이므로 위 게시글에서 서술된 많은 부분이 생략될 예정이다. 게시글을 먼저 읽고오는 것을 추천한다. 파일 생성: 2-depth 사이드바를 만들기 위해서 우선 아래 파일을 추가해야한다.  _includes/category_list_main. html   🔎    _includes 폴더 내부의 파일들은 Liquid에서 include 명령을 통해 가져올수 있다.    &#123;% include sidebar/category_list_main. html %}       사이드바를 구성하는 html 파일이다. 참고한 블로그의 파일명은 nav_list_main였으나 수정했다.    html 파일 내용은 위 블로그에서 긁어와 거의 수정하지 않았다.    위 블로그에선 html 확장자를 붙이지 말라고 했는데 나는 붙여도 정상적으로 작동했다. 기존 사이드바 파일도 html 확장자가 붙어있어 확장자를 붙이는 식으로 통일했다.       _posts/categories/category-{카테고리 이름}. md          나는 이 파일을 사용하지 않은 거 같다       아마 해당 카테고리 내의 파일만 보여주는 기능도 담당하는 거 같은데… 사이드바 만드는 것만으로도 너무 진이 빠져서 다음에 사용해 보는 걸로…^^;   작은 카테고리 별로 categories 폴더 안의 md 파일로 저장하는 기능을 한다.    이때 _posts/categories/category-{카테고리 이름}. md에서 include 하는 내용을 include views/post-item. html 로 수정했다. &#45;&#45;&#45;title:  블로그 Jekyll layout: frameworkpermalink: categories/jekyllauthor_profile: truesidebar_main: true---&#123;% assign posts = site. categories. Jekyll %}&#123;% for post in posts %}&#123;% include views/post-item. html %}&#123;% endfor %}테마가 다르기 때문에 비슷한 기능을 하는 파일도 파일명이 다르기 때문인데, 이때 views/post-item. html은와 같이 게시글을 같이 표현해주는 html 파일이다. 내 블로그 테마에선 기존에 제공해주던 기능이었기에 해당 기능을 제공해주는 파일을 찾아 대신 include 해주었다. (자신의 블로그에서도 위와 비슷한 기능을 제공하나 파일을 찾지 못하겠다면 개발자 도구의 select 기능을 사용해 class 이름을 확인해보도록 하자…) include nav_list_main: 기존 사이드바를 제공하는 HTML 파일 제일 아래에 아래와 같은 코드를 추가한다. &#123;% if site. sidebar_main%}   &#123;% include category_list_main. html %} &#123;% endif%} &#123;% if site. sidebar_main%}     _config. yml 파일의 sidebar_main 값이 true인지 판단한다.        참고한 블로그에서는 _config. yml 파일의 값을 가져오기 위해 page를 사용한 거 같은데(추정) page가 아니라 site를 사용해야 들고와졌다. 참고   _config. yml에 아래 코드를 추가했다.    만일 참고한 블로그처럼 default 아래에 sidebar_main을 추가하고 싶다면 위 코드를 &#123;% if site. defaults. values. sidebar_main%}으로 수정하고 _config. yml을 다음과 같이 수정하면 된다.     &#123;% include category_list_main. html %}     include를 사용해 category_list_main. html 내용을 가져왔다.    적용이 안된다면 if 문을 빼고 include 문만 사용해보는 걸 권한다. 적어도 어느쪽이 문제인지는 알 수 있을 거다…^^; 적용된 모습: 헤더에 categories: Jekyll가 적용된 게시글들이 &#123;% assign posts = site. categories. Jekyll %} 코드에 의해 categoty-jekyll. md 파일이 표시한 Jekyll이라는 작은 카테고리 안으로 들어간걸 확인할 수 있었다.   &#60;span class= nav__sub-title &gt;Jekyll&lt;/span&gt;      &#60;ul&gt;        &#123;% for category in site. categories %}          &#123;% if category[0] ==  Jekyll  %}            &#60;li&gt;	&#60;a href= /categories/jekyll  class=  &gt;Jekyll ()&lt;/a&gt;&lt;/li&gt;          &#123;% endif %}        &#123;% endfor %}      &#60;/ul&gt;참고로 내 category_list_main. html은 위와 같이 수정해뒀다. 사이드바 교체: 이 정도면 다 끝났다! 내 블로그에 맞게 수정하기만 하면 된다. 참고로 내 블로그에서 사용하고 있는 테마는 sidebar를 여러개 사용한다. tag, home, archives에 들어가면 보이는 사이드바의 모습이 각각 다 다르다^^;      archives의 sidebar       home의 sidebar       tag의 sidebar  그래서 사이드바마다 파일이 따로 존재한다^^; main이 되는 사이드바, 즉 home에서 보이는 사이드바는 common-list. html이며, 새로운 사이드바 코드는 임시로 common-list. html의 제일 아래쪽에 추가해두었다. 이제 home에 접속했을 시 common-list. html 대신 category_list_main. html이 뜨도록 수정해보자. common-list. html을 검색해보니 common-list. html을 include하는 파일은 category-list. html이란 걸 알 수 있었다. &#123;%- include functions. html func='log' level='debug' msg='Get categories value'-%} &#123;%- include functions. html func='get_categories' -%} &#123;% assign categories= return %} &#123;% assign keys = categories %} &#123;% assign field = 'categories' %} &#123;% assign url = '/categories. html' | relative_url %} &#123;% include sidebar/common-list. html %}기존 category-list. html &#123;%- include functions. html func='log' level='debug' msg='Get categories value'-%} &#123;%- include functions. html func='get_categories' -%} &#123;% assign categories= return %} &#123;% assign keys = categories %} &#123;% assign field = 'categories' %} &#123;% assign url = '/categories. html' | relative_url %} &#123;% if site. sidebar_main%}   &#123;% include sidebar/category_list_main. html %}&#123;%endif %}category-list. html를 위와 같이 수정해주었다.  기존에 뜨던 사이드바 대신에 수정한 사이드바가 뜨는 것을 확인할 수 있었다! 당연하지만 tag와 archives에 사용되는 사이드바는 교체되지 않았다. 변수 추가: 이전에 있던 사이드바를 삭제하기엔 아깝다. 현재 코드는 _config. yml의 sidebar_main의 값이 true일 때 수정된 사이드바가 뜨도록 구성되어있다. 그러면 기존의 사이드바도 변수를 따로 만들어 해당 값이 true일때만 출력되도록 수정해보자.  _config. yml에 sidebar_defualt 값을 추가했다. &#123;%- include functions. html func='log' level='debug' msg='Get categories value' -%}&#123;%- include functions. html func='get_categories' -%}&#123;% assign categories = return %}&#123;% assign keys = categories %}&#123;% assign field = 'categories' %}&#123;% assign url = '/categories. html' | relative_url %}&#123;% if site. sidebar_main%}   &#123;% include sidebar/category_list_main. html %}&#123;%endif %}&#123;% if site. sidebar_defualt%}   &#123;% include sidebar/common-list. html %}&#123;%endif %}category-list. html에 위와 같은 코드를 추가했다. sidebar_defualt의 값이 true일 경우에 common-list. html을 출력할 것이다.  이렇게 말이다. 제대로 작동함을 확인했으면 sidebar_defualt를 false로 적용해 필요할 때만 보이도록 만들자. css 수정: css를 손보고 카테고리도 추가해주었다. 이건 본인의 블로그에 맞게 수정하면 될 거 같다 이걸로 완성~~~! 접었다 폈다 할 수 있는 기능도 넣고 싶은데 이건 나중에…. 😅 중복 코드 삭제: 6개월만에 리팩토링을 했다. 카테고리와 서브카테고리를 추가할 때 직접 사이드바 코드를 수정해야 하는 부분이 마음에 걸리기도 했고, 카테고리가 어떻게 구성되어 있는지 코드상으로 확인하기 어려웠기 때문이다. 해당 게시글 참고 "
    }, {
    "id": 49,
    "url": "http://localhost:4000/Spring_build_and_run/",
    "title": "스프링 프로젝트 생성과 실행",
    "body": "2023/06/07 - 읽기 전 이 게시물을 먼저 읽고 오는 것을 추천한다. 스프링 프로젝트 생성: start. spring. io Dependancies로 Spring Web과 Thymeleaf를 추가한 뒤 build해준다.  Spring Web: 웹프로젝트용 스프링을 개발하는데 필요한 모듈 Thymeleaf: HTML 만들어주는 템플릿 엔진   스프링 실행: 정적 페이지: 123456789101112package y2h. Springbegin;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;@SpringBootApplicationpublic class SpringBeginApplication {	public static void main(String[] args) {		SpringApplication. run(SpringBeginApplication. class, args);	}}Spring을 실행시켜준다. 실행버튼을 누르면 터미널의 Spring 화면과 함께 localhost:8080에 에러 페이지가 뜨는 것을 확인할 수 있다. 웰컴 페이지가 없어서 그러는 것이니 만들어주자. Spring Boot에서는 static/index. html 을 올려두면 Welcome page 기능을 제공하도록 되어있다.  1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Hello&lt;/title&gt;  &lt;meta http-equiv= Content-Type  content= text/html; charset=UTF-8 /&gt;&lt;/head&gt;&lt;body&gt;Hello&lt;a href= /hello &gt;hello&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 위 코드는 static한(정적인) 웰컴 페이지를 제공해준다. 동적인 페이지를 만들기 위해서는 템플릿 엔진을 사용해야한다. Thymeleaf 템플릿 엔진: 1234567891011121314package y2h. Springbegin. controller;import org. springframework. stereotype. Controller;import org. springframework. ui. Model;import org. springframework. web. bind. annotation. GetMapping;@Controllerpublic class HelloController {  @GetMapping( hello ) //웹페이지에서 /hello로 이동할시 메서드를 호출  public String hello(Model model) {//요청 처리 로직    model. addAttribute( data , hello!! );    return  hello ;  }}HelloController. java @GetMapping은 HTTP GET 요청을 처리하는 핸들러 메서드를 정의하는 데 사용되는 어노테이션이다. 핸들러 메서드 hello에 @GetMapping 어노테이션을 적용한다. 이때 어노테이션의 매개변수로는 해당 요청을 처리할 URL인 /hello를 지정했다. 클라이언트로부터 /hello경로의 GET 요청이 올시, 요청은 hello() 메서드에 의해해 처리된다. model. addAttribute( data , hello!! );은 Spring MVC에서 사용되는 메서드로, 컨트롤러에서 모델에 데이터를 추가하는 역할을 한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html xmlns:th= http://www. thymeleaf. org &gt; &lt;head&gt;  &lt;title&gt;Hello&lt;/title&gt;  &lt;meta http-equiv= Content-Type  content= text/html; charset=UTF-8  /&gt; &lt;/head&gt; &lt;body&gt;  &lt;p th:text= '안녕하세요. ' + ${data} &gt;안녕하세요. 손님&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;resources/templates/hello. html th: thymeleaf 문법 위는 data 속성 값을 동적으로 출력하는 HTML 코드이다. 모델에 data라는 속성이 존재할시 해당 속성값을 모델에서 가져와 출력한다. HelloController. java에서 우리는 data의 값으로 “hello!!”를 입력했다. 따라서 결과적으로 출력되는 값은 안녕하세요. hello!!가 된다. 실행: 터미널 입력 . /gradlew buildcd build/libsjava -jar Spring-begin-0. 0. 1-SNAPSHOT. jar 원리: 정적 컨텐츠:   https://www. inflearn. com/course/lecture?courseSlug=스프링입문웹브라우저가 /hello-static. html으로 이동하며 hello-static. html 파일을 요청한다. 요청을 받은 내장 톰켓 서버는 스프링 컨테이너에서 hello-static과 매칭되는 컨트롤러를 찾는다. 만일 매칭되는 컨트롤러가 존재하지 않을 경우 resources에서 hello-static. html 파일을 찾아 반환한다. 정적 컨텐츠는 static 폴더 내부에 html파일을 생성하는 것으로 생성할 수 있다. MVC 템플릿 엔진:   https://www. inflearn. com/course/lecture?courseSlug=스프링입문웹브라우저에서 /hello로 이동하면 내장 톰켓 서버는 GetMapping을 사용해 스프링 컨테이너에서 /hello경로와 동일한 메서드를 찾아 매칭하고, 해당 메서드를 실행시킨다. 실행된 메소드가 리턴 값으로 문자열을 반환하면 viewResolver가 viewName을 매핑해 templates 폴더 아래에 매칭된 html을 랜더링한다. (resorces: templates/ + {ViewName} + . html)  웹 브라우저: /hello로 url 이동 내장 톰켓 서버: GetMapping으로 경로와 동일한 메서드 찾아 실행 스프링 컨테이너     메서드: 로직을 실행시킨다. 파라미터로 넘어온 data를 model에 넘기고 문자열을 return한다.    viewResolver: model의 키 값을 이용해 model로부터 값을 가져온다, 또한 반환된 문자값을 기반으로 viewName을 매핑해 templates 폴더 아래에 있는 html을 화면에 표시한다.    API: 12345@GetMapping( hello-string ) //api방식@ResponseBody //응답 body 부분에 반환값을 직접 넣어준다. public String helloString(@RequestParam( name ) String name) {  return  hello   + name;}     mvc 방식 코드       @ResponseBody를 사용한 코드  @ResponseBody를 사용해 반환값을 HTTP 응답의 body 부분에 직접 넣었다. 또한 @RequestParam을 사용해 클라이언트가 URL의 쿼리부분에 name이라는 이름의 요청 파라미터값을 전달하도록 했다. 1234567891011121314151617@GetMapping( hello-api )@ResponseBodypublic Hello helloApi(@RequestParam( name ) String name ){  Hello hello = new Hello();  hello. setName(name);  return hello;}static class Hello {  private String name;  public void setName(String name) {    this. name = name;  }  public String getName() {    return name;  }} 위 코드와 다르게 문자열이 아닌 객체를 반환하는 코드다. 그 결과값으로 HTTP의 body에 Json값이 삽입되었다.  @ResponseBody가 사용된 경우 viewResolver 대신 HttpMessageConverter가 작동한다. 이때 메서드가 반환한 값이 문자열인가 객체인가에 따라 다른 컨버터가 실행된다.  단순 문자 반환: StringConvertor 동작 객체 반환: JsonConverter를 통해 json으로 변환됨. "
    }, {
    "id": 50,
    "url": "http://localhost:4000/MVC/",
    "title": "MVC 패턴",
    "body": "2023/06/07 -     https://shreysharma. com/mvc-architecture/  💡   MVC 패턴  하나의 어플리케이션, 혹은 프로젝트의 구성요소를 Model, View, Controller 세 가지의 역할로 구분한 디자인 패턴  사용자는 컨트롤러를 조작하고, 컨트롤러는 모델을 통해 데이터를 가져오며 모델은 데이터를 바탕으로 뷰를 업데이트해 사용자에게 전달한다.     https://ko. wikipedia. org/wiki/모델-뷰-컨트롤러MVC 패턴을 정확히 표현하면 위와 같다. 모델:  데이터베이스에서 데이터를 가져오거나, 데이터를 담는 객체로서 사용된다. 컨트롤러로부터 데이터를 검색하도록 지시 받으면 데이터베이스에서 데이터를 검색하고 controller에게 데이터를 전송한다. 데이터를 검색하는 것 외에도 검색된 데이터를 데이터베이스에 저장, 업데이트, 삭제할 수 있다. 뷰와 직접 소통하는 일은 x 컨트롤러:  View와 Model의 동작을 제어한다. 웹 어플리케이션의 요청을 처리한다. 클라이언트의 입력에 따라 필요한 로직을 검색하도록 Model에게 지시하며, 조회된 데이터를 받아와 view로 보낸다. 뷰:  데이터 및 객체의 입력, 출력을 포함해 사용자 인터페이스 부분의 처리를 담당한다. MVC패턴은 어플리케이션을 역할에 따라 모델,뷰,컨트롤러로 분류하는 것으로 코드의 가독성과 유지보수성을 높이고, 하나의 기능이 자신의 역할에 집중할 수 있도록 합니다. 또한 각각의 역할이 독립적으로 개발됨으로써 어플리케이션의 유연성과 확장성을 높여주며 업데이트시 서로 영향 없이 쉽게 수정이 가능합니다. 3줄요약  MVC: Model,View, Controller로 이루어진 디자인 패턴     모델: 데이터, 로직 처리   뷰: 사용자 인터페이스 표현   컨트롤러: 사용자 요청 처리   "
    }, {
    "id": 51,
    "url": "http://localhost:4000/orthogonality/",
    "title": "프로그래밍에서의 직교성(Orthogonality)",
    "body": "2023/06/03 - https://www. baeldung. com/cs/orthogonality-cs-programming-languages-software-databases  💡   직교성(Orthogonality)  프로그래밍 언어의 다양한 기능들을 모든 방법으로 조합 가능하게 만드는 것  기능의 독립성이 보장되어 있다.  임의의 여러 기능이 조합 가능하다. C는 언어가 가진 여러 특징 때문에 직교성이 낮은 언어로 알려져 있습니다. 하지만 이는 C가 직교성을 가지고 있지 않다는 뜻은 아니며, C 또한 여러가지 직교성을 제공합니다. C가 제공하는 직교성의 예시와, C에서 발생하는 직교성에 기반한 오류의 예시를 살펴보며 직교성에 대해 알아봅시다. C가 제공하는 Orthogonality와 그에 기반된 오류: 12int x = 1;float x = 2. 0;위는 변수 x에 대해 자료형과 값에 대한 변경이 이루어지는 예시입니다. 이와 같이 C에서는 변수의 자료형 지정과 변수명 선언, 변수 초기화에 대해 기능의 독립성이 보장되있음을 알 수 있습니다. 직교성에 의한 오류 123int x = 1;float y = 2. 15;int z = x + y;위의 코드는 프로그래머의 실수로 정수형으로 선언된 변수 z에 기존의 정수형 변수와 실수형 변수 x, y의 합이 할당되는 코드입니다. z는 정수형으로 선언되어 있기에 직교성으로 인해 실수형 변수인 y에 대해 자동으로 형변환이 이루어집니다. 이는 프로그래머의 의도와 다르게 y의 소수점 아래의 값을 유실시키는 결과를 낳습니다.  1if (x = y)위는 if의 조건문에 x = y라는 할당문이 입력되어있는 예시입니다. C는 조건문 안에 할당문을 삽입하는 것을 허용하며, 따라서 위 코드는 오류 없이 실행 가능합니다. 위 코드는 조건문과 할당문의 조합으로 이루어져 있으며 오류 없이 동작 가능하단 것으로 C에서 제공하는 직교성이라 볼 수 있습니다. 직교성에 의한 오류그러나 이러한 코드는 x와 y의 값을 비교한 결과가 조건문을 판별하는 것이 아니라, x에 할당된 결과로 조건문을 판별하게 되어 프로그래머가 의도하지 않은 결과를 유발할 수 있습니다. 직교성을 높이기 위해선 코드의 목적과 의도를 명확하게 표현해야합니다. 위 코드의 경우 할당 연산자가 아닌 동등 연산자(==)를 사용하는 것으로 코드의 의미를 명확하게 전달하며 오류를 예방할 수 있습니다.  1234567891011121314151617181920212223struct exampleS{  int x;  int y;};exampleS modifyS(int Px, int Py) {  exampleS s;  s. x = Px;  s. y = Py;  return s;}int main(void) {  exampleS s1;  s1 = modifyS(1,2);  exampleS s2;  s2. x=3;  s2. y=4;  return 0;}위 코드는 구조체의 멤버 변수에 직접 접근하여 값을 수정하는 예시입니다. C에서는 modifyS함수를 사용해 구조체의 멤버 변수 x,y를 수정하거나 main함수 내에서 바로 구조체의 멤버 변수를 수정할 수 있습니다. 이러한 동작은 C에서 제공하는 직교성에 해당합니다. 직교성에 의한 오류그러나 이러한 방식으로 구조체의 멤버 변수를 직접 수정하는 행위는 해당 구조체를 사용하는 다른 코드의 실행에 영향을 줄 수 있으며, 프로그래머가 의도하지 않은 결과를 유발할 수 있습니다. 이러한 오류를 방지하기 위해선 구조체 내부에 x,y값을 수정하는 멤버 함수를 작성해 해당 멤버 함수를 통해 구조체의 멤버 변수를 간접적으로 접근하여 수정하는 방식을 사용해야 합니다. "
    }, {
    "id": 52,
    "url": "http://localhost:4000/backtracking/",
    "title": "[Algorithm] 백트래킹(Bactracking)",
    "body": "2023/06/03 - https://www. programiz. com/dsa/backtracking-algorithm  💡   Backtracking  주어진 문제에 대한 가능한 모든 경우의 수를 탐색하면서 해를 찾는 알고리즘  주어진 자식 노드 중 하나를 골라 탐색한다.      만일 선택한 노드가 조건에 맞지(Promising하지) 않다면 부모 노드로 돌아간다.    만일 선택한 노드가 조건에 맞다면 다음 자식 노드로 이동한다.     트리의 끝에 도착했다면 경로를 해에 추가한다. 경로 도출하기: 어떠한 최적의 답을 구하기 위해서, 우리는 후보 솔루션들을 트리 형태로 구축하라 수 있습니다. 이렇게 구축된 트리를 상태 공간 트리(State Space Tree)라고 부릅니다. 이렇게 주어진 상태 공간 트리에서 도출할 수 있는 경로를 구하기 위해 사용되는 알고리즘에는 DFS(깊이 우선 탐색)와 BFS(너비 우선 탐색)가 있습니다. 그러나 DFS와 BFS는 트리에서 찾을 수 있는 모든 경로를 탐색하므로, 해답에 대한 조건이 주어진 경우 불필요한 경로까지 탐색하여 비효율적일 수 있습니다. 따라서 어떤 조건에 대한 최적의 해를 구하기 위해 백트래킹이 사용됩니다. Promising한 노드:  백트래킹은 결정 문제(예, 아니오로 답할 수 있는 문제)를 다루는 데 사용된다. 백트래킹은 일반적으로 DFS과 결합되어 사용됩니다. 단, DFS가 해답에 대한 조건과 상관없이 모든 경로를 탐색하는 반면, 백트래킹은 노드를 지날 때마다 해당 노드가 경로에 부합하는가 여부를 판단하는 과정을 거칩니다. 노드가 조건에 부합함을 ‘유망하다(Promising 하다)’고 하며, 노드가 유망한 경우 다음 자식 노드 중 하나를 골라 탐색합니다. 만일 노드가 유망하지 않을 경우, 우리는 바로 직전의 노드로 돌아가 다른 경로를 선택하게 됩니다. 이를 Backtracking이라 부릅니다. 이때, 직전의 노드로 돌아가기위해 DFS의 재귀적인 특성이 사용됩니다. 이렇게 노드의 유망성을 따지는 것으로 백트래킹은 조건에 맞지 않는 경로를 사전에 차단해 살펴봐야하는 노드의 수와 해답에 대한 경우의 수를 줄여 더 효율적인 탐색을 가능하게 합니다. 이렇게 Backtracking으로 유망성을 따져 만들어진 경로만을 모아 만들어진 트리를 pruned state space tree라고 합니다. Backtracking이 사용되는 예시:  조합 가능한 모든 경우의 수 탐색 n-Queens Problem Sum of subset Problem 그래프 경로 찾기예시 코드: 일반적으로 백트래킹은 아래와 같은 형태로 사용됩니다. 12345678910111213def getRoute(k): #백트래킹을 사용해 트리를 탐색.     global route    if (len(route)==N):        getDis()        return    for i in range(1,N):        if i not in route:            route. append(i)            if promising(i): #노드의 유망성 판단                getRoute(i+1)            route. pop()getRoute(0)12345678def getcombination(k):  # 백트래킹을 사용해 n개로 가능한 모든 조합을 구함.     for i in range(k, n):        if i not in combination:            combination. append(i)            getcombination(i+1)            combination. pop()getCombination(0)"
    }, {
    "id": 53,
    "url": "http://localhost:4000/ch6/",
    "title": "P4Ch8. 비동기",
    "body": "2023/05/25 - 동기와 비동기:  동기(synchronous): 순차적으로 코드 실행비동기(Asynchronous): 순차적인 코드 실행X (ex. 버튼 클릭, 요청) 아래는 setTimeout을 사용한 비동기 코드의 예시이다. 12345console. log(1);setTmeout(() =&gt; { console. log(2);}, 1000);console. log(3);결과: 1 3 2=&gt; 코드 순서대로 실행되지 않았다! 콜백과 콜백 지옥: 123456789const a = () =&gt; { setTimeout(() =&gt; {  console. log(1); }, 1000);};const b = () =&gt; console. log(2);a();b();위 코드는 1초 후에 console. log(1)을 실행하는 코드이다. 코드는 a(),b()의 순으로 순차적으로 실행되나 함수 a() 내부의 코드 console. log(1)은 setTimeout()으로 인해 비동기적으로 실행되기에 console. log(2) 이후에 실행된다. 콜백(Callback) 패턴: callback을 사용해 코드의 실행 순서를 보장할 수 있다. 1초 뒤 console. log(1)가 실행된 다음에 console. log(2) 가 실행되길 원한다. const a = (callback) =&gt; { setTimeout(() =&gt; {  console. log(1);  callback(); }, 1000);};const b = () =&gt; console. log(2);a(() =&gt; { b();});a 함수의 callback 매개변수로 b함수 데이터를 넣음으로 a함수 실행 뒤 b함수의 실행을 보장할 수 있다. 콜백 지옥:  비동기 패턴에서 실행순서를 보장하기 위해 콜백 함수를 중첩해 사용하고, 그로인해 연속적인 들여쓰기가 발생하는 것 123456789101112131415161718const a = (callback) =&gt; { setTimeout(() =&gt; {  console. log(1);  callback(); }, 1000);};const b = (callback) =&gt; { setTimeout(() =&gt; {  console. log(2); }, 1000);};const c = () =&gt; console. log(3);a(() =&gt; { b(() =&gt; {  c(); });});여기서 const d = () =&gt; console. log(4)를 추가해 1,2,3,4 순서로 값이 출력되길 원한다면…?😵‍💫콜백 지옥은 코드의 가독성을 떨어뜨리고, 프로그래머가 코드를 유지보수하기 어렵게 만든다. 콜백 지옥 탈출법: Promise:  Promise를 사용하면 콜백 지옥을 피할 수 있다.      callback 대신 resolve 매개변수를 사용해 실행순서를 보장할 수 있다.    123456789101112131415161718192021222324252627282930313233const a = () =&gt; {	return new Promise((resolve) =&gt; {		setTimeout(() =&gt; {			console. log(1)			resolve()		},1000)	})}const b = () =&gt; {	return new Promise((resolve) =&gt; {		setTimeout(() =&gt; {			console. log(2)			resolve()		},1000)	})}const c = () =&gt; {	return new Promise((resolve) =&gt; {		setTimeout(() =&gt; {			console. log(3)			resolve()		},1000)	})}const d = () =&gt; console. log(4)a(). then(() =&gt; {	return b()}). then(() =&gt; {}	return c()). then(() =&gt; {	d()}) 함수 a는 Promise를 통해 생성한 인스턴스를 반환한다.      Promise로 만들어진 인스턴스에서는 then 메소드를 이어서 사용 가능하다.    이때 then의 콜백 함수는 Promise 생성자 함수의 resolve 매개변수로 사용된다.    then의 콜백이 Promise 인스턴스를 반환하는 경우, 메소드 체이닝으로 then 메소드를 한 번 더 사용 가능하다.    123456a() . then(() =&gt; b()) . then(() =&gt; c()) . then(() =&gt; {  d(); });위의 코드에서 then이 인수로 가진 화살표 함수 내부에 return 외 다른 코드가 존재하지 않으므로, 위 코드는 다음과 같이 쓸 수 있다. 1a(). then(b). then(c). then(d);또한 resolve 매개변수로 넘어가는 데이터는 함수 데이터이기 때문에, 위와 같은 코드 대신 화살표 함수 대신 실행하려는 a,b,c,d 함수 데이터 자체를 넣어줄수도 있다. Async Await 패턴: 우리는 a 함수 실행 후 b함수를 실행하는 순서를 보장하기 위해 Promise를 사용할 수 있다는 것을 앞서 학습했다. 이와 같이 실행 순서를 보장하는 또다른 방법으로 Async Await 패턴을 사용하는 방법이 있다. 12345678910111213141516const a = () =&gt; { return new Promise((resolve) =&gt; {  setTimeout(() =&gt; {   console. log(1);   resolve();  }, 1000); });};const b = () =&gt; console. log(2);const wrap = async () =&gt; { await a(); b();};wrap();// a(). then(() =&gt; b()) a는 Promise 인스턴스를 반환하는, 비동기 코드로 만들어진 함수이다.      await 키워드는 Promise 인스턴스를 반환하는 비동기 함수 바로 앞에 붙여 사용한다.    await는 해당 비동기 함수의 Promise 인스턴스가 반환될때까지 기다린다.    await를 사용하는 코드는 async를 사용하는 함수 내부에 존재해야한다.    Resolve, Reject 그리고 에러 핸들링: 아래는 콜백을 사용해 에러를 핸들링하는 예제코드다. const delayAdd = (index, cb, errorCb) =&gt; { setTimeout(() =&gt; {  if (index &gt; 10) {   errorCb(`${index}는 10보다 클 수 없습니다. `);   return;  }  console. log(index);  cb(index + 1); }, 1000);};delayAdd(4,(res) =&gt; console. log(res),(err) =&gt; console. error(err));위 코드는 비동기적으로 동작하며, 로직이 정상 동작할 시 delayAdd의 두 번째 인수 부분의 콜백(cb)이 실행되고, 정상적으로 처리 되지 않았다면 세 번째 인수의 콜백(errorCb)이 실행되는 방식으로 에러를 핸들링하는 코드이다.  ⚠️   하지만 이러한 방식의 에러 핸들링은 코드의 가독성을 떨어뜨리고, 여러개의 비동기 함수가 이어지는 경우 콜백 지옥과 같은 문제가 발생할 수 있다.  따라서 비동기 작업에서의 에러 핸들링은 Promise를 사용하는 것이 선호된다.  Promise를 사용한 에러 핸들링: 함수 delayAdd의 정의는 아래와 같다. const delayAdd = (index) =&gt; { return new Promise(( resolve, reject) =&gt; {  setTimeout(() =&gt; {   if (index &gt; 10) {    reject(`${index}는 10보다 클 수 없습니다. `);    return;   }   console. log(index);   resolve(index + 1);  }, 1000); });};이때, Promise를 사용해 에러 핸들링을 하는 3가지 방법이 있다. then, catch 메소드 사용: 1234delayAdd(4) . then((res) =&gt; console. log(res)) . catch((err) =&gt; console. error(err)) . finally(() =&gt; console. log( Done! )); then과 catch 메소드를 사용해 에러 핸들링이 가능하다.      then 메소드의 콜백은 resolve 매개변수로 들어간다.    catch 메소드의 콜백은 reject 매개변수로 들어간다.     reject와 resolve 둘 중 하나가 실행되면 다른 하나는 실행되지 않는다.  finally 메소드는 reject 혹은 resolve의 동작 여부와 관계없이 항상 동작한다. Async Await 패턴: 12345const wrap = async () =&gt; { const res = await delayAdd(2); console. log(res);};wrap(); 데이터를 받아와(then과 catch 메소드의 res, err와 같이) 변수에 할당 할 수 있다. Async Await 패턴에서의 catch 사용: 1234567891011const wrap = async () =&gt; { try {  const res = await delayAdd(12);  console. log(res); } catch (err) {  console. error(err); } finally {  console. log( Done! ); }};wrap(); error가 발생하면 catch 구문이 실행된다.      reject의 인수는 catch 구문의 err 변수로 들어간다.     finally 구문은 reject 혹은 resolve의 동작 여부와 관계없이 항상 동작한다. 반복문에서의 비동기 처리: forEach에서의 await는 실행 순서를 보장하지 못한다! 12345678910111213const getMovies = (movieName) =&gt; { return new Promise((resolve) =&gt; {  fetch(`https://www. omdbapi. com/?apikey=7035c60c&amp;s=${movieNAme}`)   . then((res) =&gt; res. json())   . then((res) =&gt; resolve(res)); });};const titles = [ frozen ,  avengers ,  avatar ];titles. forEach(async (title) =&gt; { const movies = await getMovies(title); console. log(title, movies);});forEach 메소드는 비동기 작업의 완료를 기다리지 않고 다음 반복을 시작한다. 따라서 getMovies 함수 호 frozen, avengers, avatar의 순차적인 실행을 보장할 수 없다. 반복문에서의 비동기 처리를 위해 forEach 메소드 대신 for 반복을 사용해야 한다. 1234567const wrap = async () =&gt; { for (const title of titles) {  const movies = await getMovies(title);  console. log(title, movies); }};wrap();"
    }, {
    "id": 54,
    "url": "http://localhost:4000/ch7/",
    "title": "P4Ch7. 모듈",
    "body": "2023/05/22 - 모듈: 모듈: 특정 데이터들의 집합(파일), 가져오기(Import), 내보내기(Export)가 된 Javascript 파일. 예시 1export const hello =  Hello world! ;module. js 12import { hello } from  . /module. js ;console. log(hello);main. js 가져오기와 내보내기: export를 통해 다른 파일로 내보내기가 가능하고, import를 통해 다른 파일의 내용을 가져와 사용할 수 있다. → 모듈화 내보내기에는 두 가지의 패턴이 있다.  기본 내보내기: default키워드를 사용해 export 하는 것     default 를 중복사용할 수 없다.     이름 내보내기: 이름을 명시해 export하는 것     한번에 여러개를 내보낼 수 있다.    import할때 중괄호를 사용해서 해당 이름으로 가져와야 한다.    import 할 때 as를 사용해 이름을 변경할 수 있다.    123456//기본 내보내기export default 123;//이름 내보내기export const str =  ABC ;export const arr = [];export const hello = () =&gt; {};module. js 1234import number, { str as xyz, arr, hello } from  . /module. js ;console. log(number); //123console. log(xyz); //ABCconsole. log(hello); //hello() {}main. js  모든 데이터를 하나의 변수에 할당해 가져올 수 있다.      이때 *를 와일드카드라고 한다.    와일드카드: 여러개의 개념을 한 번에 지정함   12345import * as abc from  . /module. js ;console. log(abc); //arr: Array(0)//defualt: 123//hello: f hello()//str: 'ABC'main. js 동적인 모듈 사용: 동적으로 모듈 가져오기:  ❓   코드 중간에서 바로 모듈을 가져오기  import를 키워드를 사용한 가져오기는 코드 최상단에서밖에 사용할 수 없다.   코드 중간에서 모듈을 동적으로 import하기 위해 import() 함수를 사용할 수 있다.  123456//기본 내보내기export default 123;//이름 내보내기export const str =  ABC ;export const arr = [];export const hello = () =&gt; {};module. js import() 함수는 비동기적으로 동작한다! 모듈이 모두 import 됐는지 기다릴 필요가 있다.  then을 사용한 import()12345setTimeout(() =&gt; { import( . /module. js ). then((abc) =&gt; {  console. log(abc); });}, 1000);main. jsimport()를 사용해 모듈을 가져오고, 모듈을 다 가져왔다면 **then**을 통해 콜백을 실행한다.  await과 async를 사용한 import()1234setTimeout(async () =&gt; { const abc = await import( . /module. js ); console. log(abc);}, 1000);main. jsimport()를 사용해 모듈을 가져오고, await을 사용해 모듈을 다 가져올때까지 기다린다. 이때 await 키워드를 사용하기 위해서는 콜백 함수 앞에 async 키워드를 추가해야한다. 동적으로 모듈 내보내기: 12345import { a } from  . /a. js ;import { b } from  . /b. js ;console. log(a());console. log(b());main. jsa와 b를 사용하기 위해선 각 모듈에서 따로 함수를 들고와야한다. ⇒ utils. js를 사용해 한번에 import한다. 12export { a } from  . /a. js ;export { b } from  . /b. js ;utils. js 1234import { a, b } from  . /utils. js ;console. log(a());console. log(b());main. js "
    }, {
    "id": 55,
    "url": "http://localhost:4000/ch6_1/",
    "title": "P4Ch6.표준 내장 객체- 날짜 ",
    "body": "2023/05/19 - 날짜 인스턴스: 123const date = new Date();console. log(date);//Fri May 19 2023 21:17:14 GMT+0900 (한국 표준시)new Date(): 현재의 날짜와 시간 정보를 출력. 출력되는 시간은 실행 환경의 시스템 시간을 기준으로 한다. 123const d1 = new Date(2023, 4, 19, 21, 9, 30);console. log(d1);//Fri May 19 2023 21:09:30 GMT+0900 (한국 표준시)new Date()의 내부에 인자를 넣는 것으로 프로그래머가 지정한 시간과 날짜를 가진 인스턴스를 생성할 수 있다. Javascript에서는 Month를 표시할때 zero-based numbering을 사용함에 유의해야한다. 따라서 위의 예제에서의 4는, 5월을 의미한다. 123const d2 = new Date( Fri May 19 2023 21:09:30 GMT+0900 (한국 표준시) );console. log(d2);//Fri May 19 2023 21:09:30 GMT+0900 (한국 표준시)Date 클래스를 생성자 함수로 호출할 때 년,월,일,시분초를 따로 인수로 넣어줄 수도 있지만, 타임스탬프 문자열을 넣는 걸로도 특정 시간과 날짜를 지닌 인스턴스를 생성 가능하다. 이때 들어가는 문자열은 YYYY-MM-DD 등과 같이 브라우저가 지원하는 유효한 형식이어야 한다. 프로토타입 메소드: 시분초일월년 반환, 지정:    getFullYear(), setFullYear()   날짜 인스턴스의 년도를 반환하거나 지정한다.   1234567const date = new Date();console. log(date. getFullYear()); //2023date. setFullYear(2022);console. log(date. getFullYear()); //2022console. log(date); //Thu May 19 2022 21:36:37 GMT+0900 (한국 표준시)         getMonth(), setMonth()   날짜 인스턴스의 ‘달’을 반환하거나 지정한다.   zero-based numbering이 사용됨에 유의   1234567const date = new Date();console. log(date. getMonth()); //4 //5월date. setMonth(0);console. log(date. getMonth()); //0 //1월console. log(date); //Thu Jan 19 2023 21:40:01 GMT+0900 (한국 표준시)         getMonth(), setMonth()   날짜 인스턴스의 ‘일’를 반환하거나 지정한다.   1234567const date = new Date();console. log(date. getDate()); //19date. setDate(11);console. log(date. getDate()); //11console. log(date); //Thu May 11 2023 21:42:06 GMT+0900 (한국 표준시)       getHours(), setHours() getMinutes(), setMinutes() getSeconds(), setSeconds() getDay(): 날짜 인스턴스의 요일을 반환한다.  월~일까지의 요일을 0~6으로 반환한다. set 메소드는 존재하지 않는다. 123456789101112131415161718192021222324const date = new Date();const day = date. getDay();console. log(day); //5console. log(getDatKo(day)); //토function getDatKo(day) { switch (day) {  case 0:   return  월 ;  case 1:   return  화 ;  case 2:   return  수 ;  case 3:   return  목 ;  case 4:   return  금 ;  case 5:   return  토 ;  case 6:   return  일 ; }}getTime(), setTime(): 1970-01-01 00:00:00 (유닉스타임)부터 경과한 날짜 인스턴스의 밀리초를 반환하거나 지정한다. 12345678const date = new Date();console. log(date. getTime()); //1684500722976console. log(date); //Fri May 19 2023 21:52:02 GMT+0900 (한국 표준시)date. setTime(1700000000000);console. log(date. getTime()); //1700000000000console. log(date); //Wed Nov 15 2023 07:13:20 GMT+0900 (한국 표준시)getTime으로 반환된 밀리초 값이 더 클수록 더 미래의 시간이다. 아래의 예제는 getTime을 사용해 어떤 날짜 인스턴스가 인수로 들어온 날짜 인스턴스보다 더 미래의 시간인지 여부를 판단하는 프로토타입 메소드를 만드는 예시이다. 1234567891011Date. prototype. isAfter = function (date) { const a = this. getTime(); const b = date. getTime(); return a &gt; b;};const d1 = new Date( 2022 21:52:25 GMT+0900 (한국 표준시) );const d2 = new Date( 2023 21:52:25 GMT+0900 (한국 표준시) );console. log(d1. isAfter(d2)); //falseconsole. log(d2. isAfter(d1)); //trueDate. now(): 메소드가 호출될 때 1970-01-01 00:00:00 (유닉스타임)으로부터 경과한 밀리초를 반환 12345678const time = new Date(). getTime();console. log(Date. now());  //1684501572151console. log(time);     //1684501572151setTimeout(() =&gt; { console. log(Date. now()); **//1684501573163** console. log(time);    //1684501572151}, 1000);위 코드에서 1000ms 이후 다시 Date. now() 반환값과 time 인스턴스 값을 출력했을 때, Date. now()의 값이 time의 값보다 대략 1000ms정도 큰 것을 확인 할 수 있다.  Date. now() : 현재 시간의 밀리초 타임스탬프를 반환 Date. getTime(): 특정 Date 객체의 시간을 밀리초로 반환"
    }, {
    "id": 56,
    "url": "http://localhost:4000/blog_update/",
    "title": "23.5.19 블로그 업데이트",
    "body": "2023/05/19 - 키퍼 발표가 2시간이 걸려서… (오지말걸) 이번에 키글챌 스터디(?)에도 참여한 김에 키퍼 발표를 들으며 블로그에 몇몇 기능을 추가했다. 추가 기능: 1. 게시글 내부 사이드바 추가  기존 기능이었는데 사용을 안하고 있었다.  사용하고 있는 테마의 예시 블로그를 확인하다 발견     게시글 마크다운 파일 상단에 sidebar: [] 삽입으로 제거 가능    . 2. 대망의 댓글 기능 추가  매우 간단하게 블로그에 댓글 기능을 추가할 수 있었다… 위에 있는 responses 기능도 disqus에서 함께 제공해준다. (off 가능) 심지어 블로그 테마 제작자 분이 이미 해당 기능을 위한 코드를 주석 처리해놓았다😅 코드를 더 잘 살펴보는 것이 좋겠다.      disqus사용, config. yml 파일 내 disqus 설정 존재   disqus사이트에서 설정 변경 가능. 사이트    비회원으로 댓글 작성이 가능하지만 그래도 이메일 주소는 작성해야한다.  이후 좀 더 살펴봐야겠다. 3. 블로그 배너 추가, 사이드 헤딩 변경  현재 디폴트 이미지 적용 중… 이후 변경예정 _data/defaults. yml 4. 날짜 포맷 변경  기존 미국식 날짜 표기 방식을 한국식으로 변경했다.  config. yml 파일 내 date_format:  %Y년 %m월 %d일  설정으로 변경"
    }, {
    "id": 57,
    "url": "http://localhost:4000/ch5_2/",
    "title": "P4Ch5.클래스- 상속과 instanceof ",
    "body": "2023/05/17 - 상속과 instanceof: 아래는 클래스 상속과 인스턴스 생성에 대한 예시이다. 1234567891011121314151617class A {	constructor() {}}class B extents A {	constructor() {		super()	}class C extents B{	constructor() {		super()	}}const a = new A()const b = new B()const c = new C()클래스 A는 기본 클래스로, 빈 생성자 함수를 가지고 있다. 클래스 B는 클래스 A를 상속하며, 생성자 함수 내에서 super()를 호출하여 부모 클래스 A의 생성자를 실행한다. 클래스 C는 클래스 B를 상속하며, 생성자 함수 내에서 super()를 호출하여 부모 클래스 B의 생성자를 실행한다. 클래스 A,B,C의 인스턴스를 각각 a,b,c라고 했을 때 instanceof 연산자와 constructor 속성을 통해 클래스와 인스턴스 간 관계를 확인할 수 있다.  instanceof : 왼쪽 피연산자가 오른쪽 피연산자의 인스턴스인지 여부를 판별 constructor : 인스턴스를 생성한 클래스를 참조instanceof: 1234567891011console. log(a instanceof A); //trueconsole. log(a instanceof B); //falseconsole. log(a instanceof C); //falseconsole. log(b instanceof A); //trueconsole. log(b instanceof B); //trueconsole. log(b instanceof C); //falseconsole. log(c instanceof A); //trueconsole. log(c instanceof B); //trueconsole. log(c instanceof C); //true상속된 클래스의 인스턴스는 상위 클래스와 자신의 클래스 모두의 인스턴스이다. (하위 클래스 포함x) constructor: 123console. log(c. constructor === A); //falseconsole. log(c. constructor === B); //falseconsole. log(c. constructor === C); //trueconstructor 속성은 인스턴스를 생성한 클래스만을 참조한다.  인스턴스 c는 클래스 C의 생성자 함수로 생성되었다. "
    }, {
    "id": 58,
    "url": "http://localhost:4000/ch5_1/",
    "title": "P4Ch5.클래스- Prototype과 Class",
    "body": "2023/05/16 - Prototype: prototype: 생성자 함수로부터 반환된 결과(인스턴스)에서 쓸 수 있는 속성 혹은 메소드를 등록하는 객체 fruits. includes, fruits. length 또한 프로토타입으로 등록된 속성,메소드이다. 1234567//const fruits = ['Apple', 'Banana', 'Cherry']const fruits = new Array( Apple ,  Banana ,  Cherry );Array. prototype. heropy = function () { console. log(this);};fruits. heropy(); // ['Apple', 'Banana', 'Cherry']Array라는 객체에 새로 heropy라는 프로토타입을 등록했다. 등록된 heropy를 호출하는 것으로 console. log(this)를 실행할 수 있다. 사용: 123456789101112const heropy = {	firstName: 'Heropy',	lastName: 'Park',	getFullName: function () {		return `${this. firstName} ${this. lastName}`	}const neo = {	firstName: 'Neo'	lastName: 'Anderson',}console. log(heropy. getFullName. call(neo)) // Neo Anderson객체의 firstName과 lastName을 출력하는 예시이다. neo와 heropy에서 모두 getFullName 함수를 사용하는 방법으로는 neo에서 heropy에 있는 getFullName 함수를 빌려 사용하는 방법이 있다. 하지만 이는 getFullName을 사용하는 객체가 많아질 때마다 call 함수를 사용해야 한다는 점과, 객체의 사용이 직관적이지 못하다는 단점이 있다. 1234567891011function User(first, last) { this. firstName = first; this. lastName = last;}User. prototype. getFullName = function () { return `${this. firstName} ${this. lastName}`;};const heropy = new User( Heropy ,  Park );const neo = new User( Neo ,  Anderson );console. log(heropy. getFullName()); //Heropy Park이는 getFullName을 프로퍼티로 만드는 것으로 해결할 수 있다. ES6 Class 기본 문법: 위의 코드를 Prototype대신 class를 사용해 작성할 수 있다. class를 사용함으로써 문법적으로 더 직관적이고 명확한 코드를 작성할 수 있으며 생성자와 메소드, 상속을 더 쉽게 구현할 수 있다. 1234567891011121314class User { constructor(first, last) {  this. firstName = first;  this. lastNAme = last; } getFullName() {  return `${this. firstName} ${this. lastName}`; }}const heropy = new User( Heropy ,  Park );const neo = new User( Neo ,  Anderson );console. log(heropy. getFullName()); //Heropy Parkclass 키워드를 사용해 클래스를 정의하고 생성자 함수와 getFullName 메소드를 작성했다. Prototype을 사용해 메소드를 수동으로 프로토타입에 추가한 것과 달리 class를 사용한 방식은 getFullName을 자동으로 프로토타입에 추가한다. Prototype을 사용한 방식과 class를 사용한 방식 모두 동일한 기능을 수행한다. 정적 메소드:  프로토타입 메소드     메소드 이름과 함수 정의 사이에 프로토타입 키워드 사용         Array. prototype. indefOf           정적 메소드     프로토타입 사용하지 않고 바로 클래스 혹은 함수에서 직접 호출됨.          Array. isArray()          12345678910111213141516171819202122232425class User { constructor(first, last) {  this. firstNAme = first;  this. lastNAme = last; } getFullName() {  //프로토타입 메소드  return `${this. firstName} ${this. lastName}`; } static isUser() {  //정적 메소드  if (user. firstNAme &amp;&amp; user. lastName) {   return true;  } }}const heropy = new User( Heropy ,  Park );console. log(heropy. getFullName); //Heropy Parkconsole. log(User. getFullName); //Error!console. log(User. isUser()); //trueconsole. log(heropy. isUser); //Error!getFullName: 프로토타입 메소드는 heropy와 같은 instance에서 사용하는 것으로, class에서 호출할 수는 없다. 따라서 User 클래스에서 호출했을시 Error가 발생한다. isUser: 정적메소드는 class에서 직접 호출이 가능하다. 반면에 instance에서는 사용 불가능하다. 따라서 인스턴스 heropy에서 호출했을시 Error가 발생한다. "
    }, {
    "id": 59,
    "url": "http://localhost:4000/ch4_4/",
    "title": "P4Ch4.함수- this",
    "body": "2023/05/16 - this: this는 일반 함수와 화살표 함수에서 다르게 정의된다.  일반함수: 호출 위치에서 정의 화살표 함수: 자신이 선언된 함수의 상위 스코프의 this를 상속받는다. 12345678910111213const user = {	firstName: 'Heropy'	lastNAme: 'Parl',	regularFunction: function() {		return `${this. firstName} ${this. lastName}`	}	arrowFunction: () =&gt; {		return `${this. firstName} ${this. lastName}`	}}console. log(user. regularFunction()) //Heropy Parlconsole. log(user. arrowFunction()) //undefinedregularFuntion에서의 this는 일반 함수로부터 정의되었기 때문에 user객체 데이터를 나타내고 있다. 반면 arrowFunction에서의 this는 화살표 함수로부터 정의되었다. 따라서 함수가 정의된 위치에서의 상위 스코프에서의 this를 참조한다. → 이때 상위 스코프는 전역 스코프가 되며, 전역 스코프에서 name은 정의되지 않았기 때문에 undefined가 출력된다. 1234567891011121314function user() {	this. firstName = 'Neo'	this. lastNAme = 'Anderson'	return {		firstName: 'Heropy'		lastNAme: 'Parl',		arrowFunction: () =&gt; {			return `${this. firstName} ${this. lastName}`		}	}}const u = user()console. log(u. arrowFunction()) //Neo Anderson위의 예시와 같이 함수 내부에서 화살표 함수를 통해 this를 사용한 경우 화살표 함수의 this는 화살표 함수의 상위 스코프, 즉 함수 user에서의 this를 상속받는다. 따라서 화살표 함수 내의 this는 user 함수 데이터를 나타낸다. 어떤 객체 데이터의 메소드를 다른 객체 데이터가 빌려 쓸 수 있다. : 1234567891011121314const user = {	firstName: 'Heropy'	lastNAme: 'Parl',	regularFunction: function() {		return `${this. firstName} ${this. lastName}`	}}const lewis = {	firstName: 'Lewis'	lastNAme: 'Yang',}console. log(user. regularFunction. call(lewis)) //Lewis Yang일반 함수의 this는 호출 위치에서 정의된다. 따라서 lewis 객체 데이터가 user 객체 데이터가 지닌 regularFunction을 call했을 때 정의된 this는 lewis객체 데이터가 된다. "
    }, {
    "id": 60,
    "url": "http://localhost:4000/ch4_3/",
    "title": "Ch 4. 함수- 화살표 함수, 즉시 실행 함수(IIFE)",
    "body": "2023/05/15 - 화살표 함수: 1234function sum() {}const sum = function () {};const sum = () =&gt; {}; //화살표 함수;(() =&gt; {. . . })() //즉시 실행 함수함수를 나타내는 방법은 위 네가지가 존재한다. 이 중 화살표 함수와 즉시 실행 함수에 대해 알아보자. 123456789const sum = (a, b) =&gt; { return a + b;};const sum = (a, b) =&gt; a + b; //동일하게 작동한다. const g = () =&gt; { return { a: 1 };};const g = () =&gt; ({ a: 1 }); //객체 데이터를 바로 return할때는 소괄호로 묶어주자화살표 함수내 return 외 코드가 존재하지 않는다면 return과 중괄호를 생략하고 한줄로 표현 가능하다. 만일 return 되는 값이 객체 데이터라면, return과 중괄호를 생략하는 대신 객체 데이터를 소괄호로 묶어주어야 한다. 123const a = () =&gt; {};const b = (x) =&gt; {};const c = (x, y) =&gt; {};화살표 함수에서 매개변수가 하나 뿐이라면 소괄호를 생략 가능하다. 즉시실행함수(IIFE): 1234567const a = 7;const double = () =&gt; { console. log(a * 2);};double();일반적인 함수는 위와 같이 실행코드가 존재해야 실행된다. 123(() =&gt; { console. log(a * 2);})();즉시 실행 함수는 실행코드 없이 함수 그 자체만으로 실행이 가능하다. 활용 패턴: 12345;(() =&gt; {. . . })()    // (F)();(function () {. . . })() // (F)();(function () {. . . }()) // (F());!function () {. . . }() // !F();+function () {. . . }() // +F()즉시실행함수의 매개변수: 1234567((a, b) =&gt; { console. log(a); console. log(b);})(1, 2);//1//2즉시 실행 함수는 두번째 소괄호에 들어가는 데이터들을 즉시실행함수의 매개변수로 전달 가능하다. "
    }, {
    "id": 61,
    "url": "http://localhost:4000/ch4_2/",
    "title": "Ch 4. 함수- 매개변수 패턴",
    "body": "2023/05/15 - 매개변수 패턴: 객체 구조분해할당: user 객체의 name 멤버변수를 들고오려고 한다. 이때 객체구조분해 할당을 포함해 총 3가지 방법으로 인자를 사용 가능하다. 1234567891011121314151617const user = {name:  Heropy',age: 85}fucntion getName(user) {return user. name}fucntion getName(user) {const {name} = user //객체 구조분해할당return name}fucntion getName({name}) {//객체 구조분해할당return name}console. log(getName(user))배열 구조 분해 할당: fruits 배열의 두번째 요소를 들고오려 한다. 이때 배열구조분해 할당을 사용 가능하다. 1234567891011const fruits = ['Apple','Banana','Cherry']fuction getSecondItem(array) { //일반적인 사용	return array[1]}fuction getSecondItem({,b}) { //배열구조분해할당	return b}console. log(getSecondItem(fruits)) //Banana나머지 매개변수(rest parameter): 나머지 매개변수를 사용해 들어오는 인자 개수와 상관없이 인자 자체를 배열화 시킬 수 있다. 1234567891011function sum(. . . rest) { console. log(rest); //들어온 매개변수를 배열로 지닌다.  console. log(arguments); //항상 함수 내에서 사용 가능하다.  return rest. reduce(function (acc, cur) {  return acc + cur; }, 0);}console. log(sum(1, 2)); //3console. log(sum(1, 2, 3, 4)); //10console. log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)); //55 argument : 함수로 들어오는 모든 인수의 정보를 지니고 있으나 배열 데이터가 아닌 array-like이기 때문에 활용도 떨어진다. "
    }, {
    "id": 62,
    "url": "http://localhost:4000/ch4_1/",
    "title": "Ch 4. 함수- 호이스팅(Hoisting)",
    "body": "2023/05/15 - 호이스팅(hoisting): 함수가 선언이 유효한 범위 내에서 제일 위쪽으로 함수의 선언을 끌어올려준다.  함수 선언문: function hello() {}함수 표현식: const hello = function () {}  호이스팅은 함수 선언에서만 발생한다. 12345hello();function hello() { console. log( Hello );}hello()가 read 될 시점에서 hello라는 이름의 함수가 정의되어 있지 않으나 작동에는 문제가 없다. =&gt; hoisting되었다 "
    }, {
    "id": 63,
    "url": "http://localhost:4000/ch8_8/",
    "title": "Ch 8. CSS 속성- 전환(transform)",
    "body": "2023/05/04 - 변환: transform: 요소의 변환효과 transform: 변환함수1, 변환함수2, … ; ex) 원근법, 이동, 크기, 회전, 기울임… 123456789101112131415body { padding: 100px;}. container { width: 100px; height: 100px; background-color: royalblue;}. container . item { width: 100px; height: 100px; background-color: orange; **transform: rotate(45deg) scale(1. 3);**}  이동, 크기 조절:         회전, 원근:  perspective 함수를 사용해 왜곡을 줄 수 있다.  perspective 함수는 transform의 제일 앞부분에 작성돼야 한다.         기울임: 원근: perspective: 하위 요소를 관찰하는 원근 거리를 지정하는 속성  perspective 함수 ≠ perspective 속성      속성/함수   적용대상   기준점 설정         perspective: 600px   관찰 대상의 부모   perspective-origin       transform: perspective(600px)   관찰 대상   transform-origin    뒷면 숨김: backface-visibility: 3D 변환으로 회전된 요소의 뒷면 숨김 여부  visible: 뒷면 보임 hidden: 뒷면 숨김 "
    }, {
    "id": 64,
    "url": "http://localhost:4000/ch8_7/",
    "title": "Ch 8. CSS 속성- 변환(transition)",
    "body": "2023/05/04 - 전환: transition: 요소의 전환 효과를 지정하는 단축속성 transition: 속성명(transition-property) 지속시간(transition-duration) 타이밍함수(transition-timing-function) 대기시간(transition-delay); *지속시간은 필수 속성 1234567891011div { width:100px; height: 100px; background-color: orange; **transition: 1s;**}div:hover { width: 300px; background-color: royalblue;} transition-property: 전환효과를 사용할 속성 이름을 지정  all: 모든 속성에 적용(기본값) 속성이름: 전환 효과를 사용할 속성 이름 명시1234567891011div { width: 100px; height: 100px; background-color: orange; transition: * * width * * 1s;}div:hover { width: 300px; background-color: royalblue;} transition-duration: 전환 효과 지속 시간 지정  0s: 전환효과 x 시간: 지속시간 지정12345678910111213div { width:100px; height: 100px; background-color: orange; transition:  **width . 3s,  background-color 2s;**}div:hover { width: 300px; background-color: royalblue;} transition-timing-function: 전환 효과의 Easing 함수를 지정  ease: 느-빠-느 linear: 일정하게 ease-in: 느-빠 ease-out: 빠-느 ease-in-out: 느-빠-느 transition-delay: 전환 효과가 몇초 뒤에 시작할지 대기시간 지정 1234567891011div { width:100px; height: 100px; background-color: orange; **transition: 1s . 5s;**}div:hover { width: 300px; background-color: royalblue;} "
    }, {
    "id": 65,
    "url": "http://localhost:4000/ch8_6/",
    "title": "Ch 8. CSS 속성- Flex(정렬) ",
    "body": "2023/05/03 - 플렉스(정렬) Container: 수평 정렬된 1차원 레이아웃을 만든다. 12345678910111213141516171819202122232425. container { background-color: royalblue; **/* display: flex; */**}. container . item { border: 4px dashed red; background-color: orange; width: 100px; height: 100px;}. container . item:nth-child(1) { position: relative;}. container . item:nth-child(2) { top: 50px; left: 50px;}. container . item:nth-child(3) {}     flex 적용 전       flex 적용 후   dispaly : Flex Container의 화면 출력 특성  flex: 블럭 요소와 같이 Flex Container 정의 inline-flex: 인라인 요소아 같이 Flex Container 정의        flex-direction: 주 축을 설정(수평 정렬할거냐 수직 정렬할거냐)  row: 행 축 (좌 ⇒ 우) row-reverse: 행 축 (우 ⇒ 좌) block 요소는 어치파 수직으로 쌓여서 열 축 속성(column, column-reverse)을 잘 사용하진 않는다.         flex-wrap: Flex items 묶음(줄바꿈) 여부  nowrap: 줄바꿈 없음 wrap: 여러 줄로 묶음 nowrap: 줄 바꿈이 없기 때문에 한 줄에 요소들을 다 끼워 넣는다. wrap: 줄 바꿈이 있기 때문에 요소의 크기를 유지한다. justify-content: 주 축의 정렬 방법 (수평 정렬)  flex-start: 아이템들을 시작점으로 정렬 flex-end: 아이템들을 끝점으로 정렬 center: 아이템들을 가운데 정렬 space-between: 아이템 사이를 균등하게 정렬 space-around: 아이템들의 외부 여백을 균등하게 정렬 align-content: 교차축의 여러 줄 정렬방법 (수직 정렬) 아이템들이 두 줄 이상이여야 한다  strech: 아이템들을 시작점으로 정렬 (기본값) flex-start: 아이템들을 시작점으로 정렬 flex-end: 아이템들을 끝점으로 정렬 center: 아이템들을 가운데 정렬 space-between: 아이템 사이를 균등하게 정렬   space-around: 아이템들의 외부 여백을 균등하게 정렬     strech, strech, flex-start  align-items: 교차축의 한 줄 정렬 방법  strech: 아이템들을 시작점으로 정렬 (기본값) flex-start: 아이템들을 시작점으로 정렬 flex-end: 아이템들을 끝점으로 정렬 center: 아이템들을 가운데 정렬        Flex Item: order: Flex Item의 순서  0: 순서 없음 숫자가 작을 수록 먼저 flex-grow: 아이템의 증가 너비 비율  0: 증가 비율 없음 123456789101112131415161718192021. container { background-color: royalblue; height: 300px; width: 500px; display: flex; justify-content: center; align-items: center;}. item { background-color: orange; width: 100px; height: 100px; border: 3px dashed red; **flex-grow: 1; flex-basis: 0;**}. container . item:nth-child(3){ **flex-grow: 2;**}     증가 비율 없음       flex-grow 설정 (1:1:2)  flex-shrink: 아이템의 감소 너비 비율  1: flex container 너비에 따라 감소 비율 적용 flex-basis: 아이템의 공간 배분 전 기본 너비  auto: 요소의 content 너비     flex-basis 적용 전       flex-basis 적용 후       "
    }, {
    "id": 66,
    "url": "http://localhost:4000/ch8_5/",
    "title": "Ch 8. CSS 속성- 배치: 요소 쌓임 순서 ",
    "body": "2023/05/03 - 요소 쌓임 순서(Stack order): 어떤 요소가 사용자와 더 가깝게 있는지(위에 쌓이는지) 결정  요소가 position 속성의 값이있는 경우 위에 쌓임. (기본값 static 제외) 1번 조건이 같은 경우, z-index 속성의 숫자 값이 높을 수록 위에 쌓임 1번과 2번 조건 같은 경우, HTML의 다음 구조일 수록 위에 쌓임123456789101112131415161718192021222324. container { width: 300px; background-color: royalblue; position: relative;}. container . item { border: 4px dashed red; background-color: orange; width: 100px; height: 100px;}. container . item:nth-child(1) { position: relative;}**. container . item:nth-child(2) { position: absolute; top: 50px; left: 50px;}** . container . item:nth-child(3) {}          1번,2번 item: 1번 조건 충족   2번 item: 3번 조건 충족   2 &gt; 1 &gt; 3  z-index: 요소의 쌓임 정도를 지정  auto: 부모 요소와 동일한 쌓임 요소   숫자: 숫자가 높을 수록 위에 쌓임     부모(파랑):position: relative, z-index: 0(auto)자식 1(노랑): position: static ⇒ z-index를 주는 의미가 없다. 자식 2(주황): position: absolute, z-index: 1자식 3: position: absolute, z-index: 2 주의: position 속성의 값으로 absolute, fixed가 지정된 요소는 display 속성이 block으로 변경 1&lt;span&gt;123&lt;/span&gt;1234567span { width: 100px; height: 100px; background: orange; font-size: 40px; /*position: absolute;*/}     span요소       absolute 적용  "
    }, {
    "id": 67,
    "url": "http://localhost:4000/ch8_4/",
    "title": "Ch 8. CSS 속성- 배치",
    "body": "2023/05/03 - 배치: position: 요소의 위치 지정 기준  static: 기준x relative: 요소 자신을 기준 absolute: 위치 상 부모 요소를 기준 fixed: 뷰포트(브라우저)를 기준  relative주황색 블록 자기 자신이 있었던 위치를 기준으로 top:30px, left: 30px만큼 이동했다. ⚠️relative로 배치되기 전의 위치는 시각적으로 보이지만 않을 뿐 유지된다 → 실제로 잘 안쓰임         12345678910111213141516171819202122232425262728. container { width:300px; background-color: royalblue;}. container . item { border: 4px dashed red; background-color: orange;}. container . item:nth-child(1) { width: 100px; height: 100px;;}. container . item:nth-child(2) { width: 140PX; height: 70px;	/*추가된 코드*/ **position: relative; top: 30px; left: 200px;**}. container . item:nth-child(3) { width: 70PX; height: 120px;;}  absolute위치 상 부모 요소를 기준으로 하기 때문에 더 이상 1,3번 요소와 상호작용하지 않는다 → 기존 공간 사라짐      (부모 relative x)부모를 기준으로 하지 않고 엉뚱한 위치       부모 요소에 relative를 주어야 한다.  부모 요소 기준 x 위치상 부모 요소 기준 O ⇒ 부모 요소에 position 필요함      위치상 부모 요소 = 파란색 박스       위치상 부모 요소 = 보라색 박스   fixed 뷰포트(브라우저)를 기준으로 배치 위치 상 부모 요소를 기준으로 하기 때문에 더 이상 1,3번 요소와 상호작용하지 않는다 → 기존 공간 사라짐부모요소, sibling 무시, 스크롤 내려도 뷰포트에 위치 고정됨 "
    }, {
    "id": 68,
    "url": "http://localhost:4000/ch8_3/",
    "title": "Ch 8. CSS 속성- 배경",
    "body": "2023/05/01 - 배경: 123456789div { background-color: orange; width: 200px; height: 200px; background-image: url(https://user-images. githubusercontent. com/71930280/235451440-2f238ca6-f01a-4a8d-a1ab-bf7426239a00. png); background-size: 150px; background-repeat: no-repeat; background-position: center;}background-image: background-image: url(”경로”)  영역의 사이즈보다 큰 경우 잘린다. background-size: 배경 이미지 사이즈  영역 사이즈 보다 작은 경우 반복된다.  auto: 이미지 실제 크기 cover: 비율 유지, 요소의 더 넓은 너비에 맞춤 contain: 비율 유지, 요소의 더 짧은 너비에 맞춤background-repeat: 배경 이미지 반복  repeat: 수직,수평 반복 repeat-x: 수평 반복 repeat-y: 수직 반복 no-repeat: 반복 없음background-position: 배경 이미지 위치  방향: top, bottom, left, rightm center 단위: px, em, rem… 123456789101112body { height: 3000px;}div { background-color: orange; height: 400px; background-image: url(https://user-images. githubusercontent. com/71930280/235451440-2f238ca6-f01a-4a8d-a1ab-bf7426239a00. png); background-size: cover; //body의 넓이에 맞춰진다.  background-repeat: no-repeat; background-position: center; background-attachment: fixed;}background-attachment: 배경 이미지 스크롤  scroll: 이미지가 요소를 따라서 같이 스크롤 fixed: 이미지가 뷰포트에 고정, 스크롤 x"
    }, {
    "id": 69,
    "url": "http://localhost:4000/ch8_2/",
    "title": "Ch 8. CSS 속성- 투명도, 글꼴, 문자",
    "body": "2023/05/01 - 투명도: opacity  1: 불투명(기본값) 0-1: 0부터 1사이 소숫점 숫자 (ex: . 5)글꼴: font-style: 글자 기울기 font-weight: 글자 두께  normal, 400: 기본 두께 bold, 700: 두껍게 100~900: 100단위 숫자 9개로 두께 조절line-height: 한 줄의 높이 (행간과 유사)  숫자: 요소의 글꼴 크기의 배수 단위: px, em, rem …font-family: 폰트 font-family: 글꼴1, “글꼴2”, …글꼴계열(필수);  후보와 글꼴 계열을 지정해준다. 브라우저는 제일 먼저 명시돼있는 후보를 우선적으로 가져온다. 1234567891011121314h1 { font-size: 24px; font-weight: 700; font-style: italic; font-family: serif;}p { width: 350px; padding: 10px; border: 1px solid; box-sizing: border-box; line-height: 1. 4;}문자: text-align: 문자 정렬방식 text-decoration: 문자 장식(선)  underline: 밑줄 line-through: 중앙 선text-indent: 들여쓰기/내어쓰기  양수: 들여쓰기 음수: 내어쓰기1&lt;a href= https://google. com &gt;Google&lt;/a&gt;12345678910a { background-color: orange; width: 200px; height: 100px; display: block; color: white; text-decoration: none; text-align: center; line-height: 100px;}"
    }, {
    "id": 70,
    "url": "http://localhost:4000/Git_live_lecture/",
    "title": "라이브 특강-Git 후기",
    "body": "2023/05/01 - Git 라이브 특강은 Zoom을 통해 4/23,5/1 이론과 실습 총 두 차례에 나눠 이루어졌다. 이론: 첫번째 강의에서는 강사님이 git flow에 대한 이론을 가르쳐주셨다. 나는 실제 개발에서는 Source Tree라는 GUI Repository를 사용했는데 강사님이 말씀하시길, GUI Repository를 사용하기 보다는 CLI를 사용한 git 사용에 익숙해지는 편이 좋다고 말씀하셨다. CLI를 사용해 복잡한 git 작업을 해본 건 아니었지만 간단한 정도라면 어느정도 경험이 있기에 큰 문제 없이 수업을 따라갈 수 있었다. 특히, 나는 보통 CLI를 사용할 때 git commit -m “내용”을 사용해서 commit을 작성했는데 강사님이 git commit 명령을 통해 vim으로 commit을 작성하는 법을 알려주신게 큰 꿀팁이 되었다. 두번째에는 조원과 함께 직접 실습을 하는 방향으로 이루어졌다. 2번째 강의 전에는 실습 전 예습해야 하는 내용을 영상으로 올려주셨는데 나는 예습을 하라는게 1번째 실시간 강의 내용을 예습해오라는 뜻인 줄 알고 안보고 있다가 친구가 카톡을 줘서 2번째 강의 시작 30분 전에야 겨우 확인했다–; 예습해야하는 강의는 45분 짜리라서 당연히 다 보진 못했지만… 다행히 실습 내용이 그렇게 어렵진 않았다. 실습: 실습은 팀원들과 함께 진행됐다. BullsAndCows 또는 Monty Hall Simulation 프로그램을 git울 사용해 팀원들과 협동하여 구현하는 내용이었다. 우리 팀은 BullsAndCows를 선택하였다. Monty Hall Sibulation에 비해 이해가 쉬웠기 때문이었다…ㅎㅎ팀원 4명이 BullsAndCows 프로그램을 크게 main, play, ckend, ckInput으로 나누어 맡고 팀장님은 올라온 PR들의 코드리뷰를 맡기로 했다. github에서 Organization을 만든 뒤 각자 역할에 맞게 Issue를 생성하고, CLI를 사용하여 이론 강의 때 배운 대로 git clone, 브랜치 생성, add, commit, push해 PR을 올리는 간단한 실습이었다. 사실 그렇게 어려운 내용의 실습은 아니었다. 이전에 많이 해봤던 거기도 하고… 하지만 이런 내용으로 실습이 진행될 거라(팀원들간 실습이 있을거라고 하시긴 했다😅) 예상하지 못해 제일 초반, 코드를 작성하기도 전에 꽤 버벅인 부분이 적지않아 있다. 특히 역할을 나누고 이슈를 생성하는 부분에서 버벅였던 거 같다. + 내가 fork를 안하고 push를 해버리는 바람에 뜨는 권한없음 오류 때문에 당황해서 헤매느라 시간을 썼고, 여기에 시간을 쓰느라 진행이 막힌 다른 팀원을 돕지 못했다😔 주어진 시간은 꽤 길었으나 위와 같은 이유로 종료 시간까지 테스트를 못해본 코드는 오류가 나서 돌아가지 않았다…. 슬프다! 실습은 강의 종료 15분 전에 끝났고, 남은 시간동안은 강사님이 push 시 충돌이 나는 케이스를 간단하게 시현해주셨다. github에 실습한 내용들은 강사님이 이번주 내로 피드백 해주시겠다고 한다. "
    }, {
    "id": 71,
    "url": "http://localhost:4000/flutter-layout/",
    "title": "flutter의 레이아웃 위젯",
    "body": "2023/03/30 - MaterialApp()은 flutter에서 이용할수 있는 위젯 클래스의 생성자 함수이다. MaterialApp()을 사용하면 구글이 제공하는 테마를 사용해 앱의 기본적인 구성요소를 설정할 수 있다. 또한 MaterialApp()은 앱을 구성하는 다른 위젯들의 루트 위젯으로 사용된다. 따라서 일반적으로 MaterialApp()을 사용해 앱의 시작점이 정의한다. MaterialApp()을 사용한 위젯들은 보통 구글 스타일이 강한데, 그것이 싫다면 아이폰 기본 앱 스타일의 테마를 제공하는 Cupertino~()를 사용할 수도 있다. 그렇다고 커스터마이징 위젯을 사용할 수 없는 건 아니고, MaterialApp()에서 스타일을 수정하면 된다. (MaterialApp()에서 유용한 기능들을 대부분 제공하니 처음부터 만들진 말 것) 상중하 배치: 1234567  return MaterialApp(    home: Scaffold(      appBar: AppBar(), //상단 레이아웃, 네비게이션 바를 생성해줌      body: Container(), //내용 레이아웃      bottomNavigationBar: BottomAppBar(child: Text('dsdfs'),), //하단 레이아웃    )  );가로,세로 배치: 1234567  return MaterialApp(    home: Scaffold(     body: Row(       children: const [ Icon(Icons. star),Icon(Icons. star),Icon(Icons. star),]     ),    )  ); 1234567  return MaterialApp(    home: Scaffold(     body: Column(       children: const [ Icon(Icons. star),Icon(Icons. star),Icon(Icons. star),]     ),    )  );flutter에서 child 아래에 여러 위젯을 넣고 싶을 땐 Row()나 Column()같은 레이아웃 위젯을 사용해 그룹화 해야한다. Row()나 Column() 위젯을 사용해 여러 위젯을 가로, 혹은 세로 배치할 수 있다. 중앙정렬: 12345678  return MaterialApp(    home: Scaffold(     body: Row(       **mainAxisAlignment: MainAxisAlignment. center**,       children: const [ Icon(Icons. star),Icon(Icons. star),Icon(Icons. star),]     ),    )  );mainAxisAlignment: 현재 축을 따라 정렬해준다. 위 코드는 Row의 내부에 있으므로 가로축을 기준으로 배치한다. 여러가지 방식으로 배치가 가능하다. 예를 들어 mainAxisAlignment: MainAxisAlignment. spaceEvenly를 사용하면 요소끼리 간격을 두고 중앙정렬 할 수 있다. 반대축으로 중앙 정렬: 현재 축으로 중앙정렬 받고 거기에 더해 반대축으로 중앙정렬하는 것도 알아보자. 1234567891011  return MaterialApp(    home: Scaffold(      body: Container(       height: 400,       child: Row(         mainAxisAlignment: MainAxisAlignment. center,         **crossAxisAlignment: CrossAxisAlignment. center**,         children: const [ Icon(Icons. star),Icon(Icons. star),Icon(Icons. star),]       ),      )   )  );crossAxisAlignment: CrossAxisAlignment. center를 사용하면 현재 축인 Row의 반대축을 기준으로 중앙정렬해준다. 이때 반대축을 기준으로 중앙정렬하기 위해서는 범위가 필요하다. 따라서 Container에 감싸 height나 width 성분을 넣어주어야 한다. "
    }, {
    "id": 72,
    "url": "http://localhost:4000/react-security-vulnerability/",
    "title": "React 보안 취약성",
    "body": "2023/03/24 - react는 컴포넌트란 것을 사용하여 코드 재활용성을 높혀주는 자바스크립트 라이브러리로, 주로 웹페이지 개발에 쓰입니다. 개인적인 얘기지만 저희 동아리 홈페이지도 React를 사용해서 만들었습니다. react를 사용하기 위해서는 react가 가진 보안취약성에 대해 알고있는게 좋겠죠. react가 가진 두 가지 보안 취약성에 대해 간단히 알아보겠습니다. react의 두가지 보안 취약성  dangerouslySetInnerHTML Event handler를 통한 XSS공격"
    }, {
    "id": 73,
    "url": "http://localhost:4000/javascript-feature/",
    "title": "Javascript의 특징",
    "body": "2023/03/18 - javascript는 웹 기반 응용 프로그램 및 웹 브라우저를 만들기 위해 사용되는 언어입니다. javascript를 사용하면 동적 및 대화형 웹 콘텐츠를 만들 수 있습니다. Javascript의 특징: 싱글 스레드 언어: javascript는 싱글 스레드 언어로 하나의 호출 스택과 하나의 메모리 힙을 사용합니다. 따라서 javascript는 한 테스트가 완료되기 전까지 다른 테스크를 수행하지 않습니다. 비동기적 동작 가능: 그러나 비동기적으로 동작한다는 점 또한 javascript의 특징이라 말할 수 있습니다.  비동기적 실행이란?  코드들이 비동기적으로 실행된다는 것은 코드가 실행되는 순서와 결과가 발생하는 순서가 일치하지 않는 것. 이는 javascript 코드가 브라우저를 통해 실행되기에 가능한 것입니다. javascript의 함수들을 싱글 스레드 형식으로 처리하는 콜스택과 별개로 브라우저에 비동기적으로 실행된 콜백 함수들을 보관하는콜백큐가 존재합니다. 이벤트 루프는 콜스택의 상태를 관찰하다가 콜스택이 비었을 경우 콜백큐에서 대기중인 함수를 콜스택으로 불러오게 됩니다. 따라서 먼저 실행된 비동기 함수가 콜백큐에서 대기하는 동안 그 이후에 실행된 함수가 콜스택에서 처리되어 먼저 끝나게 되는 것입니다. 인터프리터 언어: javascript는 인터프리터 언어라는 특성을 가지고 있습니다. 인터프리터 언어는 소스 코드를 한줄씩 읽어들여 바로 실행합니다. 이는 javascript의 코드가 동적으로 실행됨을 말하며, 변수의 타입이 런타임에서 결정되게 합니다. Javascript의 편리성: javascript는 위와 같은 특징으로 인한 여러 편리성을 가지고 있습니다. Javascript는 싱글스레드로 동작하기 때문에 자원 접근에 대한 동기화를 신경쓰지 않아도 되며, 비동기적 처리를 지원하기 때문에 프로그램의 성능을 높일 수 있습니다. 또한 변수의 타입이 런타임시 결정되기 때문에 변수의 타입 지정에 대해 자율성이 높습니다. 프론트 엔드, 백엔드, 어플리케이션 등 다양한 용도로 사용될 수 있다는 점 또한 Javascript의 장점입니다. Javascript의 불편성: 하지만 Javascript는 이러한 특징으로 인한 단점또한 가지고 있습니다. Javascript의 동적인 특징은 하나의 변수에 여러 타입을 지정할수 있도록 하며, 이는 변수에 예상치 못한 타입을 지정시켜 오류를 발생시킬 수 있습니다. 이러한 오류는 런타임시에만 발견 가능하기에 에러를 찾기 어렵습니다. 또한 javascript는 인터프리터 언어이기 때문에 컴파일러 언어에 비해 성능이 느릴 수 있습니다. "
    }, {
    "id": 74,
    "url": "http://localhost:4000/flutter-tag-mismatch/",
    "title": "안드로이드 스튜디오 오류: Tag mismatch!",
    "body": "2023/03/06 - An error occurred while preparing SDK package Android SDK Command-line Tools (latest): Tag mismatch!. : 안드로이드 스튜디오에서 sdk파일을 다운로드 하는 중 위와 같은 오류가 발생했다. C:\Users\user\AppData\Local\Android\Sdk 폴더의 . downloadIntermediates를 삭제 후 안드로이드를 재실행한 뒤 다시 시도하니 문제없이 작동했다. https://www. youtube. com/watch?v=TiqOCg_10n0 해결방법은 해당 영상을 참고했다. 만약 위 방식으로 해결되지 않는다면 방화벽을 해제해보길 권한다. (해당 영상 1분 50초부터. ) "
    }, {
    "id": 75,
    "url": "http://localhost:4000/flutter-defualt-code/",
    "title": "flutter의 바탕이 되는 코드와 기본적인 위젯",
    "body": "2023/03/06 - 12345678910111213141516import 'package:flutter/material. dart';void main() { runApp(const MyApp()); //어플리케이션 메인 페이지를 이 안에 넣어주자. }class MyApp extends StatelessWidget { //이것이 앱 메인페이지가 된다.  const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) {  return MaterialApp(   //실제 코드가 들어가는 부분  ); }}위는 flutter의 제일 밑바탕이 되는 코드이다. flutter는 기본적으로 ‘위젯’을 사용해 화면을 구성한다. 위젯은 대문자 이름 뒤에 소괄호가 붙는 형식을 가지고 있다. 텍스트,아이콘,이미지,네모박스 위젯의 가장 기본적인 사용법을 알아보겠다. 텍스트: Text(‘안녕’) 아이콘: Icon(Icons. shop) 이미지: Image. asset(‘경로’)메인 폴더 아래에 asset폴더를 만들어 이미지를 집어넣자. 이미지를 사용하려면 pubspec. yaml 파일 내에 이미지를 등록해야한다. 1234# The following section is specific to Flutter packages. flutter: assets:  - assets/flutter 항목 내에 assets 폴더를 등록해줬다. Image. asset(‘assets/olli-the-polite-cat. png’) 네모박스: Container() 혹은 SizedBox()를 사용해도 상관없다. Container(width: 50, height: 50, color: Colors. lightBlue,)flutter에서 숫자의 단위는 LP를 사용한다. 50LP==1. 2cm정도그러나 home에 해당 코드를 작성하면 실행해 보았을때 Box가 전체 화면을 채우고 있음을 확인할 수 있다. 박스의 크기를 지정해주기 위해서는 어디서부터 시작할지를 정해줘야한다. 이는 부모가 결정한다. 기준점 설정: Center() 자식 위젯의 기준점을 중앙으로 설정해준다. 123   home: Center(    child: Container(width: 50, height: 50, color: Colors. lightBlue,),   )이렇게 child라는 이름의 파라미터를 설정해주는 것으로 위젯 내부에 위젯을 넣을 수 있다. "
    }, {
    "id": 76,
    "url": "http://localhost:4000/quick-start-guide/",
    "title": "Let's test spoilers",
    "body": "2018/01/11 - Director Roland Suso Richter’s enigmatic psychological thriller (direct to video/DVD) was based upon screenwriter Michael Cooney’s own play “Point of Death” - a title that gave away the film’s entire plot twist premise. As in many similar films, such as Jacob’s Ladder (1990), Soul Survivors (2001), and The Butterfly Effect (2004), events and people were thoroughly distorted and confused because the protagonist was at the point of death. The tagline was misleading: “When You Don’t Have a Memory, How Can You Remember Who to Trust?” The mind-warping film opened with a hospital patient Simon Cable (Ryan Phillippe) awakening in a hospital with little knowledge (amnesia perhaps?) of what had happened, and why he was there, etc. He was told by attending Dr. Jeremy Newman (Stephen Rea) that it was July 29, 2002 (Simon thought it was the year 2000 - he was confused - he heard a doctor say 20:00 hours!) and that he had died for two minutes from cardiac arrest following the near-fatal accident – but he had been revived (“You’re as good as new”). Dr. Newman: “Simon, this is the 29th of July. The year is 2002. And your wife, whose name is Anna, is waiting outside. ” (The doctor left off four crucial additional words, revealed in the film’s ending. ) (Spoiler: Simon had died and was not resuscitated!). A major clue to everything that truly happened was the scene that played next under the credits - hospital staff failed to bring a patient back to life with a defibrillator after a car accident. Chest compressions failed and there was no pulse. A second major clue was provided by hospital orderly Travis (Stephen Graham): Everybody dies. No mystery there. But why and how everyone dies. Now, there’s a mystery worth solving. Probably the biggest mystery there is. So how do we do spoilers?: 1&lt;span class= spoiler &gt;My hidden paragraph here. &lt;/span&gt;"
    }, {
    "id": 77,
    "url": "http://localhost:4000/customer-service/",
    "title": "Inception Movie",
    "body": "2018/01/11 - Review products, books, movies, restaurant and anything you like on your Jekyll blog with Mediumish! JSON-LD ready for review property. How to use?: It’s actually really simple! Add the rating in your YAML front matter. It also supports halfs: 12345678910---layout: posttitle:  Inception Movie author: johncategories: [ Jekyll, tutorial ]tags: [red, yellow]image: assets/images/11. jpgdescription:  My review of Inception movie. Actors, directing and more.  rating: 4. 5---"
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});